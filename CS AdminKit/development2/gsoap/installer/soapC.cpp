/* soapC.cpp
   Generated by gSOAP 2.7.0d from soapheader.h
   Copyright (C) 2001-2004 Genivia, Inc. All Rights Reserved.
   This software is released under one of the following three licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
   See README.txt for further details.
*/
#include "soapH.h"

SOAP_BEGIN_NAMESPACE(soap)

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.7.0d 2007-01-22 13:48:09 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL);
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version != 1 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}

SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_xsd__byte:
		return soap_in_xsd__byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_xsd__short:
		return soap_in_xsd__short(soap, NULL, NULL, "xsd:short");
	case SOAP_TYPE_short:
		return soap_in_short(soap, NULL, NULL, "xsd:short");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_xsd__int:
		return soap_in_xsd__int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_long:
		return soap_in_long(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_xsd__long:
		return soap_in_xsd__long(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_LONG64:
		return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_xsd__float:
		return soap_in_xsd__float(soap, NULL, NULL, "xsd:float");
	case SOAP_TYPE_float:
		return soap_in_float(soap, NULL, NULL, "xsd:float");
	case SOAP_TYPE_xsd__double:
		return soap_in_xsd__double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_xsd__unsignedByte:
		return soap_in_xsd__unsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedByte:
		return soap_in_unsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_xsd__unsignedShort:
		return soap_in_xsd__unsignedShort(soap, NULL, NULL, "xsd:unsignedShort");
	case SOAP_TYPE_unsignedShort:
		return soap_in_unsignedShort(soap, NULL, NULL, "xsd:unsignedShort");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_xsd__unsignedInt:
		return soap_in_xsd__unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_unsignedLong:
		return soap_in_unsignedLong(soap, NULL, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_xsd__unsignedLong:
		return soap_in_xsd__unsignedLong(soap, NULL, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_unsignedLONG64:
		return soap_in_unsignedLONG64(soap, NULL, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_param__null:
		return soap_in_param__null(soap, NULL, NULL, "param:null");
	case SOAP_TYPE_xsd__boolean:
		return soap_in_xsd__boolean(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_SOAPPermissions:
		return soap_in_SOAPPermissions(soap, NULL, NULL, "SOAPPermissions");
	case SOAP_TYPE_param__arrayvalue:
		return soap_in_param__arrayvalue(soap, NULL, NULL, "param:arrayvalue");
	case SOAP_TYPE_param__params:
		return soap_in_param__params(soap, NULL, NULL, "param:params");
	case SOAP_TYPE_param__node:
		return soap_in_param__node(soap, NULL, NULL, "param:node");
	case SOAP_TYPE_param__entry:
		return soap_in_param__entry(soap, NULL, NULL, "param:entry");
	case SOAP_TYPE_param__value:
		return soap_in_param__value(soap, NULL, NULL, "param:value");
	case SOAP_TYPE_param_error_loc:
		return soap_in_param_error_loc(soap, NULL, NULL, "param-error-loc");
	case SOAP_TYPE_param_error_loc_args:
		return soap_in_param_error_loc_args(soap, NULL, NULL, "xsd:wstring");
	case SOAP_TYPE_SOAPComponentId:
		return soap_in_SOAPComponentId(soap, NULL, NULL, "SOAPComponentId");
	case SOAP_TYPE_xsd__hexBinary:
		return soap_in_xsd__hexBinary(soap, NULL, NULL, "xsd:hexBinary");
	case SOAP_TYPE_xsd__base64Binary:
		return soap_in_xsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_xsd__token_:
		return soap_in_xsd__token_(soap, NULL, NULL, "xsd:token");
	case SOAP_TYPE_xsd__normalizedString_:
		return soap_in_xsd__normalizedString_(soap, NULL, NULL, "xsd:normalizedString");
	case SOAP_TYPE_xsd__string_:
		return soap_in_xsd__string_(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_xsd__wstring_:
		return soap_in_xsd__wstring_(soap, NULL, NULL, "xsd:wstring");
	case SOAP_TYPE_xsd__unsignedByte_:
		return soap_in_xsd__unsignedByte_(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_xsd__unsignedShort_:
		return soap_in_xsd__unsignedShort_(soap, NULL, NULL, "xsd:unsignedShort");
	case SOAP_TYPE_xsd__unsignedInt_:
		return soap_in_xsd__unsignedInt_(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_xsd__unsignedLong_:
		return soap_in_xsd__unsignedLong_(soap, NULL, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_xsd__positiveInteger_:
		return soap_in_xsd__positiveInteger_(soap, NULL, NULL, "xsd:positiveInteger");
	case SOAP_TYPE_xsd__nonNegativeInteger_:
		return soap_in_xsd__nonNegativeInteger_(soap, NULL, NULL, "xsd:nonNegativeInteger");
	case SOAP_TYPE_xsd__negativeInteger_:
		return soap_in_xsd__negativeInteger_(soap, NULL, NULL, "xsd:negativeInteger");
	case SOAP_TYPE_xsd__nonPositiveInteger_:
		return soap_in_xsd__nonPositiveInteger_(soap, NULL, NULL, "xsd:nonPositiveInteger");
	case SOAP_TYPE_xsd__byte_:
		return soap_in_xsd__byte_(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_xsd__short_:
		return soap_in_xsd__short_(soap, NULL, NULL, "xsd:short");
	case SOAP_TYPE_xsd__int_:
		return soap_in_xsd__int_(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_xsd__long_:
		return soap_in_xsd__long_(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_xsd__integer_:
		return soap_in_xsd__integer_(soap, NULL, NULL, "xsd:integer");
	case SOAP_TYPE_xsd__decimal_:
		return soap_in_xsd__decimal_(soap, NULL, NULL, "xsd:decimal");
	case SOAP_TYPE_xsd__time_:
		return soap_in_xsd__time_(soap, NULL, NULL, "xsd:time");
	case SOAP_TYPE_xsd__float_:
		return soap_in_xsd__float_(soap, NULL, NULL, "xsd:float");
	case SOAP_TYPE_xsd__duration_:
		return soap_in_xsd__duration_(soap, NULL, NULL, "xsd:duration");
	case SOAP_TYPE_xsd__double_:
		return soap_in_xsd__double_(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_xsd__dateTime_:
		return soap_in_xsd__dateTime_(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_xsd__date_:
		return soap_in_xsd__date_(soap, NULL, NULL, "xsd:date");
	case SOAP_TYPE_xsd__boolean_:
		return soap_in_xsd__boolean_(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_xsd__anyURI_:
		return soap_in_xsd__anyURI_(soap, NULL, NULL, "xsd:anyURI");
	case SOAP_TYPE_xsd__anySimpleType:
		return soap_in_xsd__anySimpleType(soap, NULL, NULL, "xsd:anySimpleType");
	case SOAP_TYPE_xsd__anyType:
		return soap_in_xsd__anyType(soap, NULL, NULL, "xsd:anyType");
	case SOAP_TYPE_message_desc:
		return soap_in_message_desc(soap, NULL, NULL, "message-desc");
	case SOAP_TYPE_param_error:
		return soap_in_param_error(soap, NULL, NULL, "param-error");
	case SOAP_TYPE_SOAPComponentIdsList:
		return soap_in_SOAPComponentIdsList(soap, NULL, NULL, "SOAPComponentId");
	case SOAP_TYPE_PointerToparam__value:
		return soap_in_PointerToparam__value(soap, NULL, NULL, "param:value");
	case SOAP_TYPE_PointerToparam__node:
		return soap_in_PointerToparam__node(soap, NULL, NULL, "param:node");
	case SOAP_TYPE_PointerToparam__entry:
		return soap_in_PointerToparam__entry(soap, NULL, NULL, "param:entry");
	case SOAP_TYPE_PointerToxsd__anyType:
		return soap_in_PointerToxsd__anyType(soap, NULL, NULL, "xsd:anyType");
	case SOAP_TYPE_PointerToparam_error_loc:
		return soap_in_PointerToparam_error_loc(soap, NULL, NULL, "param-error-loc");
	case SOAP_TYPE_PointerToxsd__wstring:
		return soap_in_PointerToxsd__wstring(soap, NULL, NULL, "xsd:wstring");
	case SOAP_TYPE_PointerToSOAPComponentId:
		return soap_in_PointerToSOAPComponentId(soap, NULL, NULL, "SOAPComponentId");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_in_PointerTounsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_xsd__token:
	{	char **s;
		s = soap_in_xsd__token(soap, NULL, NULL, "xsd:token");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__normalizedString:
	{	char **s;
		s = soap_in_xsd__normalizedString(soap, NULL, NULL, "xsd:normalizedString");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__string:
	{	char **s;
		s = soap_in_xsd__string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__wstring:
	{	wchar_t **s;
		s = soap_in_xsd__wstring(soap, NULL, NULL, "xsd:wstring");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wstring:
	{	wchar_t **s;
		s = soap_in_wstring(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__positiveInteger:
	{	char **s;
		s = soap_in_xsd__positiveInteger(soap, NULL, NULL, "xsd:positiveInteger");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__nonNegativeInteger:
	{	char **s;
		s = soap_in_xsd__nonNegativeInteger(soap, NULL, NULL, "xsd:nonNegativeInteger");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__negativeInteger:
	{	char **s;
		s = soap_in_xsd__negativeInteger(soap, NULL, NULL, "xsd:negativeInteger");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__nonPositiveInteger:
	{	char **s;
		s = soap_in_xsd__nonPositiveInteger(soap, NULL, NULL, "xsd:nonPositiveInteger");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__integer:
	{	char **s;
		s = soap_in_xsd__integer(soap, NULL, NULL, "xsd:integer");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__decimal:
	{	char **s;
		s = soap_in_xsd__decimal(soap, NULL, NULL, "xsd:decimal");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__time:
	{	char **s;
		s = soap_in_xsd__time(soap, NULL, NULL, "xsd:time");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__duration:
	{	char **s;
		s = soap_in_xsd__duration(soap, NULL, NULL, "xsd:duration");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__dateTime:
	{	char **s;
		s = soap_in_xsd__dateTime(soap, NULL, NULL, "xsd:dateTime");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__date:
	{	char **s;
		s = soap_in_xsd__date(soap, NULL, NULL, "xsd:date");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__anyURI:
	{	char **s;
		s = soap_in_xsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
		return s ? *s : NULL;
	}
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_xsd__byte;
			return soap_in_xsd__byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:short"))
		{	*type = SOAP_TYPE_xsd__short;
			return soap_in_xsd__short(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:short"))
		{	*type = SOAP_TYPE_short;
			return soap_in_short(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_xsd__int;
			return soap_in_xsd__int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_long;
			return soap_in_long(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_xsd__long;
			return soap_in_xsd__long(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_LONG64;
			return soap_in_LONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:float"))
		{	*type = SOAP_TYPE_xsd__float;
			return soap_in_xsd__float(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:float"))
		{	*type = SOAP_TYPE_float;
			return soap_in_float(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_xsd__double;
			return soap_in_xsd__double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_xsd__unsignedByte;
			return soap_in_xsd__unsignedByte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_unsignedByte;
			return soap_in_unsignedByte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedShort"))
		{	*type = SOAP_TYPE_xsd__unsignedShort;
			return soap_in_xsd__unsignedShort(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedShort"))
		{	*type = SOAP_TYPE_unsignedShort;
			return soap_in_unsignedShort(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_xsd__unsignedInt;
			return soap_in_xsd__unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedLong"))
		{	*type = SOAP_TYPE_unsignedLong;
			return soap_in_unsignedLong(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedLong"))
		{	*type = SOAP_TYPE_xsd__unsignedLong;
			return soap_in_xsd__unsignedLong(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedLong"))
		{	*type = SOAP_TYPE_unsignedLONG64;
			return soap_in_unsignedLONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "param:null"))
		{	*type = SOAP_TYPE_param__null;
			return soap_in_param__null(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_xsd__boolean;
			return soap_in_xsd__boolean(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "SOAPPermissions"))
		{	*type = SOAP_TYPE_SOAPPermissions;
			return soap_in_SOAPPermissions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "param:arrayvalue"))
		{	*type = SOAP_TYPE_param__arrayvalue;
			return soap_in_param__arrayvalue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "param:params"))
		{	*type = SOAP_TYPE_param__params;
			return soap_in_param__params(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "param:node"))
		{	*type = SOAP_TYPE_param__node;
			return soap_in_param__node(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "param:entry"))
		{	*type = SOAP_TYPE_param__entry;
			return soap_in_param__entry(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "param:value"))
		{	*type = SOAP_TYPE_param__value;
			return soap_in_param__value(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "param-error-loc"))
		{	*type = SOAP_TYPE_param_error_loc;
			return soap_in_param_error_loc(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "xsd:wstring"))
		{	*type = SOAP_TYPE_param_error_loc_args;
			return soap_in_param_error_loc_args(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "SOAPComponentId"))
		{	*type = SOAP_TYPE_SOAPComponentId;
			return soap_in_SOAPComponentId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:hexBinary"))
		{	*type = SOAP_TYPE_xsd__hexBinary;
			return soap_in_xsd__hexBinary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:base64Binary"))
		{	*type = SOAP_TYPE_xsd__base64Binary;
			return soap_in_xsd__base64Binary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:token"))
		{	*type = SOAP_TYPE_xsd__token_;
			return soap_in_xsd__token_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:normalizedString"))
		{	*type = SOAP_TYPE_xsd__normalizedString_;
			return soap_in_xsd__normalizedString_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_xsd__string_;
			return soap_in_xsd__string_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:wstring"))
		{	*type = SOAP_TYPE_xsd__wstring_;
			return soap_in_xsd__wstring_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_xsd__unsignedByte_;
			return soap_in_xsd__unsignedByte_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedShort"))
		{	*type = SOAP_TYPE_xsd__unsignedShort_;
			return soap_in_xsd__unsignedShort_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_xsd__unsignedInt_;
			return soap_in_xsd__unsignedInt_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedLong"))
		{	*type = SOAP_TYPE_xsd__unsignedLong_;
			return soap_in_xsd__unsignedLong_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:positiveInteger"))
		{	*type = SOAP_TYPE_xsd__positiveInteger_;
			return soap_in_xsd__positiveInteger_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:nonNegativeInteger"))
		{	*type = SOAP_TYPE_xsd__nonNegativeInteger_;
			return soap_in_xsd__nonNegativeInteger_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:negativeInteger"))
		{	*type = SOAP_TYPE_xsd__negativeInteger_;
			return soap_in_xsd__negativeInteger_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:nonPositiveInteger"))
		{	*type = SOAP_TYPE_xsd__nonPositiveInteger_;
			return soap_in_xsd__nonPositiveInteger_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_xsd__byte_;
			return soap_in_xsd__byte_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:short"))
		{	*type = SOAP_TYPE_xsd__short_;
			return soap_in_xsd__short_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_xsd__int_;
			return soap_in_xsd__int_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_xsd__long_;
			return soap_in_xsd__long_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:integer"))
		{	*type = SOAP_TYPE_xsd__integer_;
			return soap_in_xsd__integer_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:decimal"))
		{	*type = SOAP_TYPE_xsd__decimal_;
			return soap_in_xsd__decimal_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:time"))
		{	*type = SOAP_TYPE_xsd__time_;
			return soap_in_xsd__time_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:float"))
		{	*type = SOAP_TYPE_xsd__float_;
			return soap_in_xsd__float_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:duration"))
		{	*type = SOAP_TYPE_xsd__duration_;
			return soap_in_xsd__duration_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_xsd__double_;
			return soap_in_xsd__double_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_xsd__dateTime_;
			return soap_in_xsd__dateTime_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:date"))
		{	*type = SOAP_TYPE_xsd__date_;
			return soap_in_xsd__date_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_xsd__boolean_;
			return soap_in_xsd__boolean_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyURI"))
		{	*type = SOAP_TYPE_xsd__anyURI_;
			return soap_in_xsd__anyURI_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anySimpleType"))
		{	*type = SOAP_TYPE_xsd__anySimpleType;
			return soap_in_xsd__anySimpleType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyType"))
		{	*type = SOAP_TYPE_xsd__anyType;
			return soap_in_xsd__anyType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "message-desc"))
		{	*type = SOAP_TYPE_message_desc;
			return soap_in_message_desc(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "param-error"))
		{	*type = SOAP_TYPE_param_error;
			return soap_in_param_error(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "SOAPComponentId"))
		{	*type = SOAP_TYPE_SOAPComponentIdsList;
			return soap_in_SOAPComponentIdsList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:token"))
		{	char **s;
			*type = SOAP_TYPE_xsd__token;
			s = soap_in_xsd__token(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:normalizedString"))
		{	char **s;
			*type = SOAP_TYPE_xsd__normalizedString;
			s = soap_in_xsd__normalizedString(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_xsd__string;
			s = soap_in_xsd__string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:positiveInteger"))
		{	char **s;
			*type = SOAP_TYPE_xsd__positiveInteger;
			s = soap_in_xsd__positiveInteger(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:nonNegativeInteger"))
		{	char **s;
			*type = SOAP_TYPE_xsd__nonNegativeInteger;
			s = soap_in_xsd__nonNegativeInteger(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:negativeInteger"))
		{	char **s;
			*type = SOAP_TYPE_xsd__negativeInteger;
			s = soap_in_xsd__negativeInteger(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:nonPositiveInteger"))
		{	char **s;
			*type = SOAP_TYPE_xsd__nonPositiveInteger;
			s = soap_in_xsd__nonPositiveInteger(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:integer"))
		{	char **s;
			*type = SOAP_TYPE_xsd__integer;
			s = soap_in_xsd__integer(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:decimal"))
		{	char **s;
			*type = SOAP_TYPE_xsd__decimal;
			s = soap_in_xsd__decimal(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:time"))
		{	char **s;
			*type = SOAP_TYPE_xsd__time;
			s = soap_in_xsd__time(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:duration"))
		{	char **s;
			*type = SOAP_TYPE_xsd__duration;
			s = soap_in_xsd__duration(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	char **s;
			*type = SOAP_TYPE_xsd__dateTime;
			s = soap_in_xsd__dateTime(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:date"))
		{	char **s;
			*type = SOAP_TYPE_xsd__date;
			s = soap_in_xsd__date(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:anyURI"))
		{	char **s;
			*type = SOAP_TYPE_xsd__anyURI;
			s = soap_in_xsd__anyURI(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{	if (!soap_peek_element(soap))
	{	int t;
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
			return soap->error = SOAP_TAG_MISMATCH;
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unknown element '%s' (level=%u, %d)\n", soap->tag, soap->level, soap->body));
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_xsd__byte:
		return soap_out_xsd__byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_xsd__short:
		return soap_out_xsd__short(soap, tag, id, (const short *)ptr, "xsd:short");
	case SOAP_TYPE_short:
		return soap_out_short(soap, tag, id, (const short *)ptr, "xsd:short");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_xsd__int:
		return soap_out_xsd__int(soap, tag, id, (const long *)ptr, "xsd:int");
	case SOAP_TYPE_long:
		return soap_out_long(soap, tag, id, (const long *)ptr, "xsd:long");
	case SOAP_TYPE_xsd__long:
		return soap_out_xsd__long(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_xsd__float:
		return soap_out_xsd__float(soap, tag, id, (const float *)ptr, "xsd:float");
	case SOAP_TYPE_float:
		return soap_out_float(soap, tag, id, (const float *)ptr, "xsd:float");
	case SOAP_TYPE_xsd__double:
		return soap_out_xsd__double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_xsd__unsignedByte:
		return soap_out_xsd__unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedByte:
		return soap_out_unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_xsd__unsignedShort:
		return soap_out_xsd__unsignedShort(soap, tag, id, (const unsigned short *)ptr, "xsd:unsignedShort");
	case SOAP_TYPE_unsignedShort:
		return soap_out_unsignedShort(soap, tag, id, (const unsigned short *)ptr, "xsd:unsignedShort");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_xsd__unsignedInt:
		return soap_out_xsd__unsignedInt(soap, tag, id, (const unsigned long *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_unsignedLong:
		return soap_out_unsignedLong(soap, tag, id, (const unsigned long *)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_xsd__unsignedLong:
		return soap_out_xsd__unsignedLong(soap, tag, id, (const ULONG64 *)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_unsignedLONG64:
		return soap_out_unsignedLONG64(soap, tag, id, (const ULONG64 *)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_param__null:
		return soap_out_param__null(soap, tag, id, (const bool *)ptr, "param:null");
	case SOAP_TYPE_xsd__boolean:
		return soap_out_xsd__boolean(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_SOAPPermissions:
		return ((SOAPPermissions *)ptr)->soap_out(soap, tag, id, "SOAPPermissions");
	case SOAP_TYPE_param__arrayvalue:
		return ((param__arrayvalue *)ptr)->soap_out(soap, tag, id, "param:arrayvalue");
	case SOAP_TYPE_param__params:
		return ((param__params *)ptr)->soap_out(soap, tag, id, "param:params");
	case SOAP_TYPE_param__node:
		return ((param__node *)ptr)->soap_out(soap, tag, id, "param:node");
	case SOAP_TYPE_param__entry:
		return ((param__entry *)ptr)->soap_out(soap, tag, id, "param:entry");
	case SOAP_TYPE_param__value:
		return ((param__value *)ptr)->soap_out(soap, tag, id, "param:value");
	case SOAP_TYPE_param_error_loc:
		return ((param_error_loc *)ptr)->soap_out(soap, tag, id, "param-error-loc");
	case SOAP_TYPE_param_error_loc_args:
		return ((param_error_loc_args *)ptr)->soap_out(soap, tag, id, "xsd:wstring");
	case SOAP_TYPE_SOAPComponentId:
		return ((SOAPComponentId *)ptr)->soap_out(soap, tag, id, "SOAPComponentId");
	case SOAP_TYPE_xsd__hexBinary:
		return ((xsd__hexBinary *)ptr)->soap_out(soap, tag, id, "xsd:hexBinary");
	case SOAP_TYPE_xsd__base64Binary:
		return ((xsd__base64Binary *)ptr)->soap_out(soap, tag, id, "xsd:base64Binary");
	case SOAP_TYPE_xsd__token_:
		return ((xsd__token_ *)ptr)->soap_out(soap, tag, id, "xsd:token");
	case SOAP_TYPE_xsd__normalizedString_:
		return ((xsd__normalizedString_ *)ptr)->soap_out(soap, tag, id, "xsd:normalizedString");
	case SOAP_TYPE_xsd__string_:
		return ((xsd__string_ *)ptr)->soap_out(soap, tag, id, "xsd:string");
	case SOAP_TYPE_xsd__wstring_:
		return ((xsd__wstring_ *)ptr)->soap_out(soap, tag, id, "xsd:wstring");
	case SOAP_TYPE_xsd__unsignedByte_:
		return ((xsd__unsignedByte_ *)ptr)->soap_out(soap, tag, id, "xsd:unsignedByte");
	case SOAP_TYPE_xsd__unsignedShort_:
		return ((xsd__unsignedShort_ *)ptr)->soap_out(soap, tag, id, "xsd:unsignedShort");
	case SOAP_TYPE_xsd__unsignedInt_:
		return ((xsd__unsignedInt_ *)ptr)->soap_out(soap, tag, id, "xsd:unsignedInt");
	case SOAP_TYPE_xsd__unsignedLong_:
		return ((xsd__unsignedLong_ *)ptr)->soap_out(soap, tag, id, "xsd:unsignedLong");
	case SOAP_TYPE_xsd__positiveInteger_:
		return ((xsd__positiveInteger_ *)ptr)->soap_out(soap, tag, id, "xsd:positiveInteger");
	case SOAP_TYPE_xsd__nonNegativeInteger_:
		return ((xsd__nonNegativeInteger_ *)ptr)->soap_out(soap, tag, id, "xsd:nonNegativeInteger");
	case SOAP_TYPE_xsd__negativeInteger_:
		return ((xsd__negativeInteger_ *)ptr)->soap_out(soap, tag, id, "xsd:negativeInteger");
	case SOAP_TYPE_xsd__nonPositiveInteger_:
		return ((xsd__nonPositiveInteger_ *)ptr)->soap_out(soap, tag, id, "xsd:nonPositiveInteger");
	case SOAP_TYPE_xsd__byte_:
		return ((xsd__byte_ *)ptr)->soap_out(soap, tag, id, "xsd:byte");
	case SOAP_TYPE_xsd__short_:
		return ((xsd__short_ *)ptr)->soap_out(soap, tag, id, "xsd:short");
	case SOAP_TYPE_xsd__int_:
		return ((xsd__int_ *)ptr)->soap_out(soap, tag, id, "xsd:int");
	case SOAP_TYPE_xsd__long_:
		return ((xsd__long_ *)ptr)->soap_out(soap, tag, id, "xsd:long");
	case SOAP_TYPE_xsd__integer_:
		return ((xsd__integer_ *)ptr)->soap_out(soap, tag, id, "xsd:integer");
	case SOAP_TYPE_xsd__decimal_:
		return ((xsd__decimal_ *)ptr)->soap_out(soap, tag, id, "xsd:decimal");
	case SOAP_TYPE_xsd__time_:
		return ((xsd__time_ *)ptr)->soap_out(soap, tag, id, "xsd:time");
	case SOAP_TYPE_xsd__float_:
		return ((xsd__float_ *)ptr)->soap_out(soap, tag, id, "xsd:float");
	case SOAP_TYPE_xsd__duration_:
		return ((xsd__duration_ *)ptr)->soap_out(soap, tag, id, "xsd:duration");
	case SOAP_TYPE_xsd__double_:
		return ((xsd__double_ *)ptr)->soap_out(soap, tag, id, "xsd:double");
	case SOAP_TYPE_xsd__dateTime_:
		return ((xsd__dateTime_ *)ptr)->soap_out(soap, tag, id, "xsd:dateTime");
	case SOAP_TYPE_xsd__date_:
		return ((xsd__date_ *)ptr)->soap_out(soap, tag, id, "xsd:date");
	case SOAP_TYPE_xsd__boolean_:
		return ((xsd__boolean_ *)ptr)->soap_out(soap, tag, id, "xsd:boolean");
	case SOAP_TYPE_xsd__anyURI_:
		return ((xsd__anyURI_ *)ptr)->soap_out(soap, tag, id, "xsd:anyURI");
	case SOAP_TYPE_xsd__anySimpleType:
		return ((xsd__anySimpleType *)ptr)->soap_out(soap, tag, id, "xsd:anySimpleType");
	case SOAP_TYPE_xsd__anyType:
		return ((xsd__anyType *)ptr)->soap_out(soap, tag, id, "xsd:anyType");
	case SOAP_TYPE_message_desc:
		return soap_out_message_desc(soap, tag, id, (const struct message_desc_t *)ptr, "message-desc");
	case SOAP_TYPE_param_error:
		return soap_out_param_error(soap, tag, id, (const struct param_error *)ptr, "param-error");
	case SOAP_TYPE_SOAPComponentIdsList:
		return soap_out_SOAPComponentIdsList(soap, tag, id, (const struct SOAPComponentIdsList *)ptr, "SOAPComponentId");
	case SOAP_TYPE_PointerToparam__value:
		return soap_out_PointerToparam__value(soap, tag, id, (param__value *const*)ptr, "param:value");
	case SOAP_TYPE_PointerToparam__node:
		return soap_out_PointerToparam__node(soap, tag, id, (param__node *const*)ptr, "param:node");
	case SOAP_TYPE_PointerToparam__entry:
		return soap_out_PointerToparam__entry(soap, tag, id, (param__entry *const*)ptr, "param:entry");
	case SOAP_TYPE_PointerToxsd__anyType:
		return soap_out_PointerToxsd__anyType(soap, tag, id, (xsd__anyType *const*)ptr, "xsd:anyType");
	case SOAP_TYPE_PointerToparam_error_loc:
		return soap_out_PointerToparam_error_loc(soap, tag, id, (param_error_loc *const*)ptr, "param-error-loc");
	case SOAP_TYPE_PointerToxsd__wstring:
		return soap_out_PointerToxsd__wstring(soap, tag, id, (wchar_t **const*)ptr, "xsd:wstring");
	case SOAP_TYPE_PointerToSOAPComponentId:
		return soap_out_PointerToSOAPComponentId(soap, tag, id, (SOAPComponentId *const*)ptr, "SOAPComponentId");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_out_PointerTounsignedByte(soap, tag, id, (unsigned char *const*)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_xsd__token:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:token");
	case SOAP_TYPE_xsd__normalizedString:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:normalizedString");
	case SOAP_TYPE_xsd__string:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:string");
	case SOAP_TYPE_xsd__wstring:
		return soap_out_wstring(soap, tag, id, (wchar_t**)&ptr, "xsd:wstring");
	case SOAP_TYPE_wstring:
		return soap_out_wstring(soap, tag, id, (wchar_t**)&ptr, "xsd:string");
	case SOAP_TYPE_xsd__positiveInteger:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:positiveInteger");
	case SOAP_TYPE_xsd__nonNegativeInteger:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:nonNegativeInteger");
	case SOAP_TYPE_xsd__negativeInteger:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:negativeInteger");
	case SOAP_TYPE_xsd__nonPositiveInteger:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:nonPositiveInteger");
	case SOAP_TYPE_xsd__integer:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:integer");
	case SOAP_TYPE_xsd__decimal:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:decimal");
	case SOAP_TYPE_xsd__time:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:time");
	case SOAP_TYPE_xsd__duration:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:duration");
	case SOAP_TYPE_xsd__dateTime:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:dateTime");
	case SOAP_TYPE_xsd__date:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:date");
	case SOAP_TYPE_xsd__anyURI:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:anyURI");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, "QName", id, (char**)&ptr, NULL);
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	switch (type)
	{
	case SOAP_TYPE_SOAPPermissions:
		((SOAPPermissions *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_param__arrayvalue:
		((param__arrayvalue *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_param__params:
		((param__params *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_param__node:
		((param__node *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_param__entry:
		((param__entry *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_param__value:
		((param__value *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_param_error_loc:
		((param_error_loc *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_param_error_loc_args:
		((param_error_loc_args *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_SOAPComponentId:
		((SOAPComponentId *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__hexBinary:
		((xsd__hexBinary *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__base64Binary:
		((xsd__base64Binary *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__token_:
		((xsd__token_ *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__normalizedString_:
		((xsd__normalizedString_ *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__string_:
		((xsd__string_ *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__wstring_:
		((xsd__wstring_ *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__unsignedByte_:
		((xsd__unsignedByte_ *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__unsignedShort_:
		((xsd__unsignedShort_ *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__unsignedInt_:
		((xsd__unsignedInt_ *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__unsignedLong_:
		((xsd__unsignedLong_ *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__positiveInteger_:
		((xsd__positiveInteger_ *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__nonNegativeInteger_:
		((xsd__nonNegativeInteger_ *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__negativeInteger_:
		((xsd__negativeInteger_ *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__nonPositiveInteger_:
		((xsd__nonPositiveInteger_ *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__byte_:
		((xsd__byte_ *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__short_:
		((xsd__short_ *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__int_:
		((xsd__int_ *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__long_:
		((xsd__long_ *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__integer_:
		((xsd__integer_ *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__decimal_:
		((xsd__decimal_ *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__time_:
		((xsd__time_ *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__float_:
		((xsd__float_ *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__duration_:
		((xsd__duration_ *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__double_:
		((xsd__double_ *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__dateTime_:
		((xsd__dateTime_ *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__date_:
		((xsd__date_ *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__boolean_:
		((xsd__boolean_ *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__anyURI_:
		((xsd__anyURI_ *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__anySimpleType:
		((xsd__anySimpleType *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__anyType:
		((xsd__anyType *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_message_desc:
		soap_mark_message_desc(soap, (const struct message_desc_t *)ptr);
		break;
	case SOAP_TYPE_param_error:
		soap_mark_param_error(soap, (const struct param_error *)ptr);
		break;
	case SOAP_TYPE_SOAPComponentIdsList:
		soap_mark_SOAPComponentIdsList(soap, (const struct SOAPComponentIdsList *)ptr);
		break;
	case SOAP_TYPE_PointerToparam__value:
		soap_mark_PointerToparam__value(soap, (param__value *const*)ptr);
		break;
	case SOAP_TYPE_PointerToparam__node:
		soap_mark_PointerToparam__node(soap, (param__node *const*)ptr);
		break;
	case SOAP_TYPE_PointerToparam__entry:
		soap_mark_PointerToparam__entry(soap, (param__entry *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__anyType:
		soap_mark_PointerToxsd__anyType(soap, (xsd__anyType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToparam_error_loc:
		soap_mark_PointerToparam_error_loc(soap, (param_error_loc *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__wstring:
		soap_mark_PointerToxsd__wstring(soap, (wchar_t **const*)ptr);
		break;
	case SOAP_TYPE_PointerToSOAPComponentId:
		soap_mark_PointerToSOAPComponentId(soap, (SOAPComponentId *const*)ptr);
		break;
	case SOAP_TYPE_PointerTounsignedByte:
		soap_mark_PointerTounsignedByte(soap, (unsigned char *const*)ptr);
		break;
	case SOAP_TYPE_xsd__token:
		soap_mark_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_xsd__normalizedString:
		soap_mark_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_xsd__string:
		soap_mark_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_xsd__wstring:
		soap_mark_wstring(soap, (wchar_t**)&ptr);
		break;
	case SOAP_TYPE_wstring:
		soap_mark_wstring(soap, (wchar_t**)&ptr);
		break;
	case SOAP_TYPE_xsd__positiveInteger:
		soap_mark_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_xsd__nonNegativeInteger:
		soap_mark_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_xsd__negativeInteger:
		soap_mark_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_xsd__nonPositiveInteger:
		soap_mark_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_xsd__integer:
		soap_mark_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_xsd__decimal:
		soap_mark_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_xsd__time:
		soap_mark_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_xsd__duration:
		soap_mark_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_xsd__dateTime:
		soap_mark_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_xsd__date:
		soap_mark_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_xsd__anyURI:
		soap_mark_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE__QName:
		soap_mark_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_mark_string(soap, (char**)&ptr);
		break;
	}
}

#ifndef WITH_LEANER
SOAP_FMAC3 int SOAP_FMAC4 soap_resolve_attachments(struct soap *soap)
{
	if (!(soap->mode & SOAP_ENC_DIME))
		return SOAP_OK;
	while (soap->dime.flags & SOAP_DIME_CF)
	{	if (soap_getdimehdr(soap))
			return soap->error;
		if (soap_move(soap, soap->dime.size))
			return soap->error = SOAP_EOF;
	}
	if (soap_move(soap, ((soap->dime.size+3)&(~3))-soap_tell(soap)))
		return soap->error = SOAP_EOF;
	for (;;)
	{	if (soap_getdime(soap))
			break;
		switch (soap_lookup_type(soap, soap->dime.id))
		{
		case SOAP_TYPE_xsd__hexBinary:
		{	xsd__hexBinary * a;
			a = (xsd__hexBinary *)soap_class_id_enter(soap, soap->dime.id, NULL, SOAP_TYPE_xsd__hexBinary, sizeof(xsd__hexBinary), NULL, NULL);
			if (!a)
				return soap->error;
			a->__ptr = (unsigned char*)soap->dime.ptr;
			a->__size = soap->dime.size;
			break;
		}
		case SOAP_TYPE_xsd__base64Binary:
		{	xsd__base64Binary * a;
			a = (xsd__base64Binary *)soap_class_id_enter(soap, soap->dime.id, NULL, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), NULL, NULL);
			if (!a)
				return soap->error;
			a->__ptr = (unsigned char*)soap->dime.ptr;
			a->__size = soap->dime.size;
			break;
		}
		}
	}
	if (soap->error == SOAP_DIME_END)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_xsd__anyType:
		return (void*)soap_instantiate_xsd__anyType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__anySimpleType:
		return (void*)soap_instantiate_xsd__anySimpleType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__anyURI_:
		return (void*)soap_instantiate_xsd__anyURI_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__boolean_:
		return (void*)soap_instantiate_xsd__boolean_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__date_:
		return (void*)soap_instantiate_xsd__date_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__dateTime_:
		return (void*)soap_instantiate_xsd__dateTime_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__double_:
		return (void*)soap_instantiate_xsd__double_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__duration_:
		return (void*)soap_instantiate_xsd__duration_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__float_:
		return (void*)soap_instantiate_xsd__float_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__time_:
		return (void*)soap_instantiate_xsd__time_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__decimal_:
		return (void*)soap_instantiate_xsd__decimal_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__integer_:
		return (void*)soap_instantiate_xsd__integer_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__long_:
		return (void*)soap_instantiate_xsd__long_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__int_:
		return (void*)soap_instantiate_xsd__int_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__short_:
		return (void*)soap_instantiate_xsd__short_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__byte_:
		return (void*)soap_instantiate_xsd__byte_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__nonPositiveInteger_:
		return (void*)soap_instantiate_xsd__nonPositiveInteger_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__negativeInteger_:
		return (void*)soap_instantiate_xsd__negativeInteger_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__nonNegativeInteger_:
		return (void*)soap_instantiate_xsd__nonNegativeInteger_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__positiveInteger_:
		return (void*)soap_instantiate_xsd__positiveInteger_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__unsignedLong_:
		return (void*)soap_instantiate_xsd__unsignedLong_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__unsignedInt_:
		return (void*)soap_instantiate_xsd__unsignedInt_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__unsignedShort_:
		return (void*)soap_instantiate_xsd__unsignedShort_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__unsignedByte_:
		return (void*)soap_instantiate_xsd__unsignedByte_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__wstring_:
		return (void*)soap_instantiate_xsd__wstring_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__string_:
		return (void*)soap_instantiate_xsd__string_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__normalizedString_:
		return (void*)soap_instantiate_xsd__normalizedString_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__token_:
		return (void*)soap_instantiate_xsd__token_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__base64Binary:
		return (void*)soap_instantiate_xsd__base64Binary(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__hexBinary:
		return (void*)soap_instantiate_xsd__hexBinary(soap, -1, type, arrayType, n);
	case SOAP_TYPE_SOAPComponentId:
		return (void*)soap_instantiate_SOAPComponentId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_param_error_loc_args:
		return (void*)soap_instantiate_param_error_loc_args(soap, -1, type, arrayType, n);
	case SOAP_TYPE_param_error_loc:
		return (void*)soap_instantiate_param_error_loc(soap, -1, type, arrayType, n);
	case SOAP_TYPE_param__value:
		return (void*)soap_instantiate_param__value(soap, -1, type, arrayType, n);
	case SOAP_TYPE_param__entry:
		return (void*)soap_instantiate_param__entry(soap, -1, type, arrayType, n);
	case SOAP_TYPE_param__node:
		return (void*)soap_instantiate_param__node(soap, -1, type, arrayType, n);
	case SOAP_TYPE_param__params:
		return (void*)soap_instantiate_param__params(soap, -1, type, arrayType, n);
	case SOAP_TYPE_param__arrayvalue:
		return (void*)soap_instantiate_param__arrayvalue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_SOAPPermissions:
		return (void*)soap_instantiate_SOAPPermissions(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_xsd__anyType:
		if (p->size < 0)
			delete (xsd__anyType*)p->ptr;
		else
			delete[] (xsd__anyType*)p->ptr;
		break;
	case SOAP_TYPE_xsd__anySimpleType:
		if (p->size < 0)
			delete (xsd__anySimpleType*)p->ptr;
		else
			delete[] (xsd__anySimpleType*)p->ptr;
		break;
	case SOAP_TYPE_xsd__anyURI_:
		if (p->size < 0)
			delete (xsd__anyURI_*)p->ptr;
		else
			delete[] (xsd__anyURI_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__boolean_:
		if (p->size < 0)
			delete (xsd__boolean_*)p->ptr;
		else
			delete[] (xsd__boolean_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__date_:
		if (p->size < 0)
			delete (xsd__date_*)p->ptr;
		else
			delete[] (xsd__date_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__dateTime_:
		if (p->size < 0)
			delete (xsd__dateTime_*)p->ptr;
		else
			delete[] (xsd__dateTime_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__double_:
		if (p->size < 0)
			delete (xsd__double_*)p->ptr;
		else
			delete[] (xsd__double_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__duration_:
		if (p->size < 0)
			delete (xsd__duration_*)p->ptr;
		else
			delete[] (xsd__duration_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__float_:
		if (p->size < 0)
			delete (xsd__float_*)p->ptr;
		else
			delete[] (xsd__float_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__time_:
		if (p->size < 0)
			delete (xsd__time_*)p->ptr;
		else
			delete[] (xsd__time_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__decimal_:
		if (p->size < 0)
			delete (xsd__decimal_*)p->ptr;
		else
			delete[] (xsd__decimal_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__integer_:
		if (p->size < 0)
			delete (xsd__integer_*)p->ptr;
		else
			delete[] (xsd__integer_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__long_:
		if (p->size < 0)
			delete (xsd__long_*)p->ptr;
		else
			delete[] (xsd__long_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__int_:
		if (p->size < 0)
			delete (xsd__int_*)p->ptr;
		else
			delete[] (xsd__int_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__short_:
		if (p->size < 0)
			delete (xsd__short_*)p->ptr;
		else
			delete[] (xsd__short_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__byte_:
		if (p->size < 0)
			delete (xsd__byte_*)p->ptr;
		else
			delete[] (xsd__byte_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__nonPositiveInteger_:
		if (p->size < 0)
			delete (xsd__nonPositiveInteger_*)p->ptr;
		else
			delete[] (xsd__nonPositiveInteger_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__negativeInteger_:
		if (p->size < 0)
			delete (xsd__negativeInteger_*)p->ptr;
		else
			delete[] (xsd__negativeInteger_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__nonNegativeInteger_:
		if (p->size < 0)
			delete (xsd__nonNegativeInteger_*)p->ptr;
		else
			delete[] (xsd__nonNegativeInteger_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__positiveInteger_:
		if (p->size < 0)
			delete (xsd__positiveInteger_*)p->ptr;
		else
			delete[] (xsd__positiveInteger_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__unsignedLong_:
		if (p->size < 0)
			delete (xsd__unsignedLong_*)p->ptr;
		else
			delete[] (xsd__unsignedLong_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__unsignedInt_:
		if (p->size < 0)
			delete (xsd__unsignedInt_*)p->ptr;
		else
			delete[] (xsd__unsignedInt_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__unsignedShort_:
		if (p->size < 0)
			delete (xsd__unsignedShort_*)p->ptr;
		else
			delete[] (xsd__unsignedShort_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__unsignedByte_:
		if (p->size < 0)
			delete (xsd__unsignedByte_*)p->ptr;
		else
			delete[] (xsd__unsignedByte_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__wstring_:
		if (p->size < 0)
			delete (xsd__wstring_*)p->ptr;
		else
			delete[] (xsd__wstring_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__string_:
		if (p->size < 0)
			delete (xsd__string_*)p->ptr;
		else
			delete[] (xsd__string_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__normalizedString_:
		if (p->size < 0)
			delete (xsd__normalizedString_*)p->ptr;
		else
			delete[] (xsd__normalizedString_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__token_:
		if (p->size < 0)
			delete (xsd__token_*)p->ptr;
		else
			delete[] (xsd__token_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__base64Binary:
		if (p->size < 0)
			delete (xsd__base64Binary*)p->ptr;
		else
			delete[] (xsd__base64Binary*)p->ptr;
		break;
	case SOAP_TYPE_xsd__hexBinary:
		if (p->size < 0)
			delete (xsd__hexBinary*)p->ptr;
		else
			delete[] (xsd__hexBinary*)p->ptr;
		break;
	case SOAP_TYPE_SOAPComponentId:
		if (p->size < 0)
			delete (SOAPComponentId*)p->ptr;
		else
			delete[] (SOAPComponentId*)p->ptr;
		break;
	case SOAP_TYPE_param_error_loc_args:
		if (p->size < 0)
			delete (param_error_loc_args*)p->ptr;
		else
			delete[] (param_error_loc_args*)p->ptr;
		break;
	case SOAP_TYPE_param_error_loc:
		if (p->size < 0)
			delete (param_error_loc*)p->ptr;
		else
			delete[] (param_error_loc*)p->ptr;
		break;
	case SOAP_TYPE_param__value:
		if (p->size < 0)
			delete (param__value*)p->ptr;
		else
			delete[] (param__value*)p->ptr;
		break;
	case SOAP_TYPE_param__entry:
		if (p->size < 0)
			delete (param__entry*)p->ptr;
		else
			delete[] (param__entry*)p->ptr;
		break;
	case SOAP_TYPE_param__node:
		if (p->size < 0)
			delete (param__node*)p->ptr;
		else
			delete[] (param__node*)p->ptr;
		break;
	case SOAP_TYPE_param__params:
		if (p->size < 0)
			delete (param__params*)p->ptr;
		else
			delete[] (param__params*)p->ptr;
		break;
	case SOAP_TYPE_param__arrayvalue:
		if (p->size < 0)
			delete (param__arrayvalue*)p->ptr;
		else
			delete[] (param__arrayvalue*)p->ptr;
		break;
	case SOAP_TYPE_SOAPPermissions:
		if (p->size < 0)
			delete (SOAPPermissions*)p->ptr;
		else
			delete[] (SOAPPermissions*)p->ptr;
		break;
	}
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__byte(struct soap *soap, char *a)
{
#ifdef SOAP_DEFAULT_xsd__byte
	*a = SOAP_DEFAULT_xsd__byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__byte(struct soap *soap, char const*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__byte);
	if (soap_out_xsd__byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_xsd__byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_xsd__byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__byte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_xsd__byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	return soap_inbyte(soap, tag, a, type, SOAP_TYPE_xsd__byte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_byte(struct soap *soap, char const*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	return soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__short(struct soap *soap, short *a)
{
#ifdef SOAP_DEFAULT_xsd__short
	*a = SOAP_DEFAULT_xsd__short;
#else
	*a = (short)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__short(struct soap *soap, short const*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__short(struct soap *soap, const short *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__short);
	if (soap_out_xsd__short(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__short(struct soap *soap, const char *tag, int id, const short *a, const char *type)
{
	return soap_outshort(soap, tag, id, a, type, SOAP_TYPE_xsd__short);
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_get_xsd__short(struct soap *soap, short *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__short(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_in_xsd__short(struct soap *soap, const char *tag, short *a, const char *type)
{
	return soap_inshort(soap, tag, a, type, SOAP_TYPE_xsd__short);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_short(struct soap *soap, short *a)
{
#ifdef SOAP_DEFAULT_short
	*a = SOAP_DEFAULT_short;
#else
	*a = (short)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_short(struct soap *soap, short const*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_short(struct soap *soap, const short *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_short);
	if (soap_out_short(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_short(struct soap *soap, const char *tag, int id, const short *a, const char *type)
{
	return soap_outshort(soap, tag, id, a, type, SOAP_TYPE_short);
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_get_short(struct soap *soap, short *p, const char *tag, const char *type)
{
	if ((p = soap_in_short(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_in_short(struct soap *soap, const char *tag, short *a, const char *type)
{
	return soap_inshort(soap, tag, a, type, SOAP_TYPE_short);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_int(struct soap *soap, int const*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__int(struct soap *soap, long *a)
{
#ifdef SOAP_DEFAULT_xsd__int
	*a = SOAP_DEFAULT_xsd__int;
#else
	*a = (long)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__int(struct soap *soap, long const*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__int(struct soap *soap, const long *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__int);
	if (soap_out_xsd__int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__int(struct soap *soap, const char *tag, int id, const long *a, const char *type)
{
	return soap_outlong(soap, tag, id, a, type, SOAP_TYPE_xsd__int);
}

SOAP_FMAC3 long * SOAP_FMAC4 soap_get_xsd__int(struct soap *soap, long *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__int(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 long * SOAP_FMAC4 soap_in_xsd__int(struct soap *soap, const char *tag, long *a, const char *type)
{
	return soap_inlong(soap, tag, a, type, SOAP_TYPE_xsd__int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_long(struct soap *soap, long *a)
{
#ifdef SOAP_DEFAULT_long
	*a = SOAP_DEFAULT_long;
#else
	*a = (long)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_long(struct soap *soap, long const*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_long(struct soap *soap, const long *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_long);
	if (soap_out_long(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_long(struct soap *soap, const char *tag, int id, const long *a, const char *type)
{
	return soap_outlong(soap, tag, id, a, type, SOAP_TYPE_long);
}

SOAP_FMAC3 long * SOAP_FMAC4 soap_get_long(struct soap *soap, long *p, const char *tag, const char *type)
{
	if ((p = soap_in_long(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 long * SOAP_FMAC4 soap_in_long(struct soap *soap, const char *tag, long *a, const char *type)
{
	return soap_inlong(soap, tag, a, type, SOAP_TYPE_long);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__long(struct soap *soap, LONG64 *a)
{
#ifdef SOAP_DEFAULT_xsd__long
	*a = SOAP_DEFAULT_xsd__long;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__long(struct soap *soap, LONG64 const*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__long(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__long);
	if (soap_out_xsd__long(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__long(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_xsd__long);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_xsd__long(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__long(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_xsd__long(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{
	return soap_inLONG64(soap, tag, a, type, SOAP_TYPE_xsd__long);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap *soap, LONG64 *a)
{
#ifdef SOAP_DEFAULT_LONG64
	*a = SOAP_DEFAULT_LONG64;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_LONG64(struct soap *soap, LONG64 const*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_LONG64);
	if (soap_out_LONG64(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{
	return soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__float(struct soap *soap, float *a)
{
#ifdef SOAP_DEFAULT_xsd__float
	*a = SOAP_DEFAULT_xsd__float;
#else
	*a = (float)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__float(struct soap *soap, float const*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__float(struct soap *soap, const float *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__float);
	if (soap_out_xsd__float(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__float(struct soap *soap, const char *tag, int id, const float *a, const char *type)
{
	return soap_outfloat(soap, tag, id, a, type, SOAP_TYPE_xsd__float);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_get_xsd__float(struct soap *soap, float *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__float(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_in_xsd__float(struct soap *soap, const char *tag, float *a, const char *type)
{
	return soap_infloat(soap, tag, a, type, SOAP_TYPE_xsd__float);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_float(struct soap *soap, float *a)
{
#ifdef SOAP_DEFAULT_float
	*a = SOAP_DEFAULT_float;
#else
	*a = (float)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_float(struct soap *soap, float const*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_float(struct soap *soap, const float *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_float);
	if (soap_out_float(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_float(struct soap *soap, const char *tag, int id, const float *a, const char *type)
{
	return soap_outfloat(soap, tag, id, a, type, SOAP_TYPE_float);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_get_float(struct soap *soap, float *p, const char *tag, const char *type)
{
	if ((p = soap_in_float(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_in_float(struct soap *soap, const char *tag, float *a, const char *type)
{
	return soap_infloat(soap, tag, a, type, SOAP_TYPE_float);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__double(struct soap *soap, double *a)
{
#ifdef SOAP_DEFAULT_xsd__double
	*a = SOAP_DEFAULT_xsd__double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__double(struct soap *soap, double const*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__double);
	if (soap_out_xsd__double(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_xsd__double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_xsd__double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__double(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_xsd__double(struct soap *soap, const char *tag, double *a, const char *type)
{
	return soap_indouble(soap, tag, a, type, SOAP_TYPE_xsd__double);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap *soap, double *a)
{
#ifdef SOAP_DEFAULT_double
	*a = SOAP_DEFAULT_double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_double(struct soap *soap, double const*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_double);
	if (soap_out_double(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{
	return soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__unsignedByte(struct soap *soap, unsigned char *a)
{
#ifdef SOAP_DEFAULT_xsd__unsignedByte
	*a = SOAP_DEFAULT_xsd__unsignedByte;
#else
	*a = (unsigned char)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__unsignedByte(struct soap *soap, unsigned char const*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__unsignedByte);
	if (soap_out_xsd__unsignedByte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_xsd__unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_xsd__unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__unsignedByte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_xsd__unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{
	return soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_xsd__unsignedByte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedByte(struct soap *soap, unsigned char *a)
{
#ifdef SOAP_DEFAULT_unsignedByte
	*a = SOAP_DEFAULT_unsignedByte;
#else
	*a = (unsigned char)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_unsignedByte(struct soap *soap, unsigned char const*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedByte);
	if (soap_out_unsignedByte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedByte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{
	return soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__unsignedShort(struct soap *soap, unsigned short *a)
{
#ifdef SOAP_DEFAULT_xsd__unsignedShort
	*a = SOAP_DEFAULT_xsd__unsignedShort;
#else
	*a = (unsigned short)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__unsignedShort(struct soap *soap, unsigned short const*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__unsignedShort(struct soap *soap, const unsigned short *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__unsignedShort);
	if (soap_out_xsd__unsignedShort(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__unsignedShort(struct soap *soap, const char *tag, int id, const unsigned short *a, const char *type)
{
	return soap_outunsignedShort(soap, tag, id, a, type, SOAP_TYPE_xsd__unsignedShort);
}

SOAP_FMAC3 unsigned short * SOAP_FMAC4 soap_get_xsd__unsignedShort(struct soap *soap, unsigned short *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__unsignedShort(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned short * SOAP_FMAC4 soap_in_xsd__unsignedShort(struct soap *soap, const char *tag, unsigned short *a, const char *type)
{
	return soap_inunsignedShort(soap, tag, a, type, SOAP_TYPE_xsd__unsignedShort);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedShort(struct soap *soap, unsigned short *a)
{
#ifdef SOAP_DEFAULT_unsignedShort
	*a = SOAP_DEFAULT_unsignedShort;
#else
	*a = (unsigned short)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_unsignedShort(struct soap *soap, unsigned short const*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedShort(struct soap *soap, const unsigned short *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedShort);
	if (soap_out_unsignedShort(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedShort(struct soap *soap, const char *tag, int id, const unsigned short *a, const char *type)
{
	return soap_outunsignedShort(soap, tag, id, a, type, SOAP_TYPE_unsignedShort);
}

SOAP_FMAC3 unsigned short * SOAP_FMAC4 soap_get_unsignedShort(struct soap *soap, unsigned short *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedShort(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned short * SOAP_FMAC4 soap_in_unsignedShort(struct soap *soap, const char *tag, unsigned short *a, const char *type)
{
	return soap_inunsignedShort(soap, tag, a, type, SOAP_TYPE_unsignedShort);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap *soap, unsigned int *a)
{
#ifdef SOAP_DEFAULT_unsignedInt
	*a = SOAP_DEFAULT_unsignedInt;
#else
	*a = (unsigned int)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_unsignedInt(struct soap *soap, unsigned int const*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedInt);
	if (soap_out_unsignedInt(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{
	return soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__unsignedInt(struct soap *soap, unsigned long *a)
{
#ifdef SOAP_DEFAULT_xsd__unsignedInt
	*a = SOAP_DEFAULT_xsd__unsignedInt;
#else
	*a = (unsigned long)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__unsignedInt(struct soap *soap, unsigned long const*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__unsignedInt(struct soap *soap, const unsigned long *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__unsignedInt);
	if (soap_out_xsd__unsignedInt(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__unsignedInt(struct soap *soap, const char *tag, int id, const unsigned long *a, const char *type)
{
	return soap_outunsignedLong(soap, tag, id, a, type, SOAP_TYPE_xsd__unsignedInt);
}

SOAP_FMAC3 unsigned long * SOAP_FMAC4 soap_get_xsd__unsignedInt(struct soap *soap, unsigned long *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__unsignedInt(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned long * SOAP_FMAC4 soap_in_xsd__unsignedInt(struct soap *soap, const char *tag, unsigned long *a, const char *type)
{
	return soap_inunsignedLong(soap, tag, a, type, SOAP_TYPE_xsd__unsignedInt);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedLong(struct soap *soap, unsigned long *a)
{
#ifdef SOAP_DEFAULT_unsignedLong
	*a = SOAP_DEFAULT_unsignedLong;
#else
	*a = (unsigned long)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_unsignedLong(struct soap *soap, unsigned long const*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedLong(struct soap *soap, const unsigned long *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedLong);
	if (soap_out_unsignedLong(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedLong(struct soap *soap, const char *tag, int id, const unsigned long *a, const char *type)
{
	return soap_outunsignedLong(soap, tag, id, a, type, SOAP_TYPE_unsignedLong);
}

SOAP_FMAC3 unsigned long * SOAP_FMAC4 soap_get_unsignedLong(struct soap *soap, unsigned long *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedLong(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned long * SOAP_FMAC4 soap_in_unsignedLong(struct soap *soap, const char *tag, unsigned long *a, const char *type)
{
	return soap_inunsignedLong(soap, tag, a, type, SOAP_TYPE_unsignedLong);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__unsignedLong(struct soap *soap, ULONG64 *a)
{
#ifdef SOAP_DEFAULT_xsd__unsignedLong
	*a = SOAP_DEFAULT_xsd__unsignedLong;
#else
	*a = (ULONG64)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__unsignedLong(struct soap *soap, ULONG64 const*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__unsignedLong(struct soap *soap, const ULONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__unsignedLong);
	if (soap_out_xsd__unsignedLong(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__unsignedLong(struct soap *soap, const char *tag, int id, const ULONG64 *a, const char *type)
{
	return soap_outULONG64(soap, tag, id, a, type, SOAP_TYPE_xsd__unsignedLong);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_get_xsd__unsignedLong(struct soap *soap, ULONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__unsignedLong(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_in_xsd__unsignedLong(struct soap *soap, const char *tag, ULONG64 *a, const char *type)
{
	return soap_inULONG64(soap, tag, a, type, SOAP_TYPE_xsd__unsignedLong);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedLONG64(struct soap *soap, ULONG64 *a)
{
#ifdef SOAP_DEFAULT_unsignedLONG64
	*a = SOAP_DEFAULT_unsignedLONG64;
#else
	*a = (ULONG64)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_unsignedLONG64(struct soap *soap, ULONG64 const*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedLONG64(struct soap *soap, const ULONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedLONG64);
	if (soap_out_unsignedLONG64(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedLONG64(struct soap *soap, const char *tag, int id, const ULONG64 *a, const char *type)
{
	return soap_outULONG64(soap, tag, id, a, type, SOAP_TYPE_unsignedLONG64);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_get_unsignedLONG64(struct soap *soap, ULONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedLONG64(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_in_unsignedLONG64(struct soap *soap, const char *tag, ULONG64 *a, const char *type)
{
	return soap_inULONG64(soap, tag, a, type, SOAP_TYPE_unsignedLONG64);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_param__null(struct soap *soap, bool *a)
{
#ifdef SOAP_DEFAULT_param__null
	*a = SOAP_DEFAULT_param__null;
#else
	*a = (bool)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_param__null(struct soap *soap, bool const*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_param__null(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_param__null);
	if (soap_out_param__null(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_param__null[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3 const char* SOAP_FMAC4 soap_param__null2s(struct soap *soap, bool n)
{	const char *s = soap_str_code(soap_codes_param__null, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_param__null(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_param__null), type);
	soap_send(soap, soap_param__null2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_param__null(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_param__null(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_s2param__null(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_param__null, s);
	if (map)
		*a = (bool)map->code;
	else if (soap->mode & SOAP_XML_STRICT)
		return soap->error = SOAP_TYPE;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
			return soap->error;
		*a = (bool)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_param__null(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, "xsd:boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_param__null, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2param__null(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_param__null, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__boolean(struct soap *soap, bool *a)
{
#ifdef SOAP_DEFAULT_xsd__boolean
	*a = SOAP_DEFAULT_xsd__boolean;
#else
	*a = (bool)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__boolean(struct soap *soap, bool const*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__boolean(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__boolean);
	if (soap_out_xsd__boolean(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_xsd__boolean[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3 const char* SOAP_FMAC4 soap_xsd__boolean2s(struct soap *soap, bool n)
{	const char *s = soap_str_code(soap_codes_xsd__boolean, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__boolean(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xsd__boolean), type);
	soap_send(soap, soap_xsd__boolean2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_xsd__boolean(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__boolean(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_s2xsd__boolean(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_xsd__boolean, s);
	if (map)
		*a = (bool)map->code;
	else if (soap->mode & SOAP_XML_STRICT)
		return soap->error = SOAP_TYPE;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
			return soap->error;
		*a = (bool)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_xsd__boolean(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, "xsd:boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__boolean, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2xsd__boolean(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_xsd__boolean, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bool(struct soap *soap, bool const*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3 const char* SOAP_FMAC4 soap_bool2s(struct soap *soap, bool n)
{	const char *s = soap_str_code(soap_codes_bool, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type);
	soap_send(soap, soap_bool2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)map->code;
	else if (soap->mode & SOAP_XML_STRICT)
		return soap->error = SOAP_TYPE;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
			return soap->error;
		*a = (bool)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

void SOAPPermissions::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void SOAPPermissions::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((SOAPPermissions*)this)->Allow, SOAP_TYPE_xsd__unsignedLong);
	soap_embedded(soap, &((SOAPPermissions*)this)->Deny, SOAP_TYPE_xsd__unsignedLong);
	soap_embedded(soap, &((SOAPPermissions*)this)->UserAccountName, SOAP_TYPE_xsd__wstring);
	soap_mark_xsd__wstring(soap, &((SOAPPermissions*)this)->UserAccountName);
}

void SOAPPermissions::soap_default(struct soap *soap)
{
	soap_default_xsd__unsignedLong(soap, &((SOAPPermissions*)this)->Allow);
	soap_default_xsd__unsignedLong(soap, &((SOAPPermissions*)this)->Deny);
	((SOAPPermissions*)this)->UserAccountName = NULL;
}

int SOAPPermissions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_SOAPPermissions);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int SOAPPermissions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_SOAPPermissions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAPPermissions(struct soap *soap, const char *tag, int id, const SOAPPermissions *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAPPermissions), type);
	soap_out_xsd__unsignedLong(soap, "Allow", -1, &(((SOAPPermissions*)a)->Allow), "");
	soap_out_xsd__unsignedLong(soap, "Deny", -1, &(((SOAPPermissions*)a)->Deny), "");
	soap_out_xsd__wstring(soap, "UserAccountName", -1, &(((SOAPPermissions*)a)->UserAccountName), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *SOAPPermissions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_SOAPPermissions(soap, this, tag, type);
}

SOAP_FMAC3 SOAPPermissions * SOAP_FMAC4 soap_get_SOAPPermissions(struct soap *soap, SOAPPermissions *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAPPermissions(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *SOAPPermissions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_SOAPPermissions(soap, tag, this, type);
}

SOAP_FMAC3 SOAPPermissions * SOAP_FMAC4 soap_in_SOAPPermissions(struct soap *soap, const char *tag, SOAPPermissions *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (SOAPPermissions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_SOAPPermissions, sizeof(SOAPPermissions), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_SOAPPermissions)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (SOAPPermissions *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_Allow1 = 1, soap_flag_Deny1 = 1, soap_flag_UserAccountName1 = 1;
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Allow1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__unsignedLong(soap, "Allow", &(((SOAPPermissions*)a)->Allow), "xsd:unsignedLong"))
				{	soap_flag_Allow1 = 0;
					continue;
				}
			if (soap_flag_Deny1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__unsignedLong(soap, "Deny", &(((SOAPPermissions*)a)->Deny), "xsd:unsignedLong"))
				{	soap_flag_Deny1 = 0;
					continue;
				}
			if (soap_flag_UserAccountName1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__wstring(soap, "UserAccountName", &(((SOAPPermissions*)a)->UserAccountName), "xsd:wstring"))
				{	soap_flag_UserAccountName1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Allow1 || soap_flag_Deny1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (SOAPPermissions *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_SOAPPermissions, 0, sizeof(SOAPPermissions), 0, soap_copy_SOAPPermissions);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 SOAPPermissions * SOAP_FMAC6 soap_new_SOAPPermissions(struct soap *soap, int n)
{	return soap_instantiate_SOAPPermissions(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAPPermissions(struct soap *soap, SOAPPermissions *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 SOAPPermissions * SOAP_FMAC6 soap_instantiate_SOAPPermissions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAPPermissions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAPPermissions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new SOAPPermissions;
		if (size)
			*size = sizeof(SOAPPermissions);
	}
	else
	{	cp->ptr = (void*)new SOAPPermissions[n];
		if (size)
			*size = n * sizeof(SOAPPermissions);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (SOAPPermissions*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_SOAPPermissions(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying SOAPPermissions %p -> %p\n", q, p));
	*(SOAPPermissions*)p = *(SOAPPermissions*)q;
}

void param__arrayvalue::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void param__arrayvalue::soap_mark(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_param__arrayvalue))
		for (int i = 0; i < this->__size; i++)
		{	soap_embedded(soap, this->__ptr + i, SOAP_TYPE_param__value);
			this->__ptr[i].soap_mark(soap);
		}
}

void param__arrayvalue::soap_default(struct soap *soap)
{
	this->__size = 0;
	this->__ptr = NULL;
}

int param__arrayvalue::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_param__arrayvalue);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int param__arrayvalue::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_param__arrayvalue(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_param__arrayvalue(struct soap *soap, const char *tag, int id, const param__arrayvalue *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_param__arrayvalue);
	if (id < 0)
		return soap->error;
	soap_element_begin_out(soap, tag, id, "param:arrayvalue");
	for (i = 0; i < n; i++)
	{
		soap_out_param__value(soap, "item", -1, &a->__ptr[i], "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *param__arrayvalue::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_param__arrayvalue(soap, this, tag, type);
}

SOAP_FMAC3 param__arrayvalue * SOAP_FMAC4 soap_get_param__arrayvalue(struct soap *soap, param__arrayvalue *p, const char *tag, const char *type)
{
	if ((p = soap_in_param__arrayvalue(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *param__arrayvalue::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_param__arrayvalue(soap, tag, this, type);
}

SOAP_FMAC3 param__arrayvalue * SOAP_FMAC4 soap_in_param__arrayvalue(struct soap *soap, const char *tag, param__arrayvalue *a, const char *type)
{	int i, j;
	param__value *p;
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (param__arrayvalue *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_param__arrayvalue, sizeof(param__arrayvalue), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = soap_new_param__value(soap, a->__size);
			for (i = 0; i < a->__size; i++)
				(a->__ptr+i)->param__value::soap_default(soap);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_param__value(soap, NULL, a->__ptr + i, "param:value"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	param__value q;
			soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (param__value *)soap_push_block(soap, sizeof(param__value));
				if (!p)
					return NULL;
				memcpy(p, &q, sizeof(param__value));
				p->soap_default(soap);
				if (!soap_in_param__value(soap, NULL, p, "param:value"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			if (soap->blist->size)
				a->__ptr = soap_new_param__value(soap, soap->blist->size/sizeof(param__value));
			else
				a->__ptr = NULL;
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (param__arrayvalue *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_param__arrayvalue, 0, sizeof(param__arrayvalue), 0, soap_copy_param__arrayvalue);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 param__arrayvalue * SOAP_FMAC6 soap_new_param__arrayvalue(struct soap *soap, int n)
{	return soap_instantiate_param__arrayvalue(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_param__arrayvalue(struct soap *soap, param__arrayvalue *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 param__arrayvalue * SOAP_FMAC6 soap_instantiate_param__arrayvalue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_param__arrayvalue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_param__arrayvalue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new param__arrayvalue;
		if (size)
			*size = sizeof(param__arrayvalue);
	}
	else
	{	cp->ptr = (void*)new param__arrayvalue[n];
		if (size)
			*size = n * sizeof(param__arrayvalue);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (param__arrayvalue*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_param__arrayvalue(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying param__arrayvalue %p -> %p\n", q, p));
	*(param__arrayvalue*)p = *(param__arrayvalue*)q;
}

void param__params::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void param__params::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((param__params*)this)->node, SOAP_TYPE_PointerToparam__node);
	soap_mark_PointerToparam__node(soap, &((param__params*)this)->node);
	soap_embedded(soap, &((param__params*)this)->checksum, SOAP_TYPE_xsd__int);
	soap_embedded(soap, &((param__params*)this)->binfmt, SOAP_TYPE_xsd__base64Binary);
	((param__params*)this)->binfmt.soap_mark(soap);
}

void param__params::soap_default(struct soap *soap)
{
	((param__params*)this)->node = NULL;
	soap_default_xsd__int(soap, &((param__params*)this)->checksum);
	((param__params*)this)->binfmt.xsd__base64Binary::soap_default(soap);
}

int param__params::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_param__params);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int param__params::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_param__params(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_param__params(struct soap *soap, const char *tag, int id, const param__params *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_param__params), "param:params");
	soap_out_PointerToparam__node(soap, "node", -1, &(((param__params*)a)->node), "");
	soap_out_xsd__int(soap, "checksum", -1, &(((param__params*)a)->checksum), "");
	(((param__params*)a)->binfmt).soap_out(soap, "binfmt", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *param__params::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_param__params(soap, this, tag, type);
}

SOAP_FMAC3 param__params * SOAP_FMAC4 soap_get_param__params(struct soap *soap, param__params *p, const char *tag, const char *type)
{
	if ((p = soap_in_param__params(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *param__params::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_param__params(soap, tag, this, type);
}

SOAP_FMAC3 param__params * SOAP_FMAC4 soap_in_param__params(struct soap *soap, const char *tag, param__params *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (param__params *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_param__params, sizeof(param__params), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_param__params)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (param__params *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_node1 = 1, soap_flag_checksum1 = 1, soap_flag_binfmt1 = 1;
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_node1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToparam__node(soap, "node", &(((param__params*)a)->node), "param:node"))
				{	soap_flag_node1 = 0;
					continue;
				}
			if (soap_flag_checksum1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "checksum", &(((param__params*)a)->checksum), "xsd:int"))
				{	soap_flag_checksum1 = 0;
					continue;
				}
			if (soap_flag_binfmt1 && soap->error == SOAP_TAG_MISMATCH)
				if ((((param__params*)a)->binfmt).soap_in(soap, "binfmt", "xsd:base64Binary"))
				{	soap_flag_binfmt1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_checksum1 || soap_flag_binfmt1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (param__params *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_param__params, 0, sizeof(param__params), 0, soap_copy_param__params);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 param__params * SOAP_FMAC6 soap_new_param__params(struct soap *soap, int n)
{	return soap_instantiate_param__params(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_param__params(struct soap *soap, param__params *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 param__params * SOAP_FMAC6 soap_instantiate_param__params(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_param__params(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_param__params, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new param__params;
		if (size)
			*size = sizeof(param__params);
	}
	else
	{	cp->ptr = (void*)new param__params[n];
		if (size)
			*size = n * sizeof(param__params);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (param__params*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_param__params(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying param__params %p -> %p\n", q, p));
	*(param__params*)p = *(param__params*)q;
}

void param__node::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void param__node::soap_mark(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_param__node))
		for (int i = 0; i < this->__size; i++)
		{	soap_embedded(soap, this->__ptr + i, SOAP_TYPE_param__entry);
			this->__ptr[i].soap_mark(soap);
		}
}

void param__node::soap_default(struct soap *soap)
{
	this->__size = 0;
	this->__ptr = NULL;
}

int param__node::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_param__node);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int param__node::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_param__node(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_param__node(struct soap *soap, const char *tag, int id, const param__node *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_param__node);
	if (id < 0)
		return soap->error;
	soap_element_begin_out(soap, tag, id, type);
	for (i = 0; i < n; i++)
	{
		soap_out_param__entry(soap, "item", -1, &a->__ptr[i], "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *param__node::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_param__node(soap, this, tag, type);
}

SOAP_FMAC3 param__node * SOAP_FMAC4 soap_get_param__node(struct soap *soap, param__node *p, const char *tag, const char *type)
{
	if ((p = soap_in_param__node(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *param__node::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_param__node(soap, tag, this, type);
}

SOAP_FMAC3 param__node * SOAP_FMAC4 soap_in_param__node(struct soap *soap, const char *tag, param__node *a, const char *type)
{	int i, j;
	param__entry *p;
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (param__node *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_param__node, sizeof(param__node), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = soap_new_param__entry(soap, a->__size);
			for (i = 0; i < a->__size; i++)
				(a->__ptr+i)->param__entry::soap_default(soap);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_param__entry(soap, NULL, a->__ptr + i, "param:entry"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	param__entry q;
			soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (param__entry *)soap_push_block(soap, sizeof(param__entry));
				if (!p)
					return NULL;
				memcpy(p, &q, sizeof(param__entry));
				p->soap_default(soap);
				if (!soap_in_param__entry(soap, NULL, p, "param:entry"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			if (soap->blist->size)
				a->__ptr = soap_new_param__entry(soap, soap->blist->size/sizeof(param__entry));
			else
				a->__ptr = NULL;
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (param__node *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_param__node, 0, sizeof(param__node), 0, soap_copy_param__node);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 param__node * SOAP_FMAC6 soap_new_param__node(struct soap *soap, int n)
{	return soap_instantiate_param__node(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_param__node(struct soap *soap, param__node *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 param__node * SOAP_FMAC6 soap_instantiate_param__node(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_param__node(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_param__node, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new param__node;
		if (size)
			*size = sizeof(param__node);
	}
	else
	{	cp->ptr = (void*)new param__node[n];
		if (size)
			*size = n * sizeof(param__node);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (param__node*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_param__node(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying param__node %p -> %p\n", q, p));
	*(param__node*)p = *(param__node*)q;
}

void param__entry::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void param__entry::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((param__entry*)this)->name, SOAP_TYPE_xsd__wstring);
	soap_mark_xsd__wstring(soap, &((param__entry*)this)->name);
	soap_embedded(soap, &((param__entry*)this)->value, SOAP_TYPE_param__value);
	((param__entry*)this)->value.soap_mark(soap);
}

void param__entry::soap_default(struct soap *soap)
{
	((param__entry*)this)->name = NULL;
	((param__entry*)this)->value.param__value::soap_default(soap);
}

int param__entry::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_param__entry);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int param__entry::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_param__entry(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_param__entry(struct soap *soap, const char *tag, int id, const param__entry *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_param__entry), type);
	soap_out_xsd__wstring(soap, "name", -1, &(((param__entry*)a)->name), "");
	(((param__entry*)a)->value).soap_out(soap, "value", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *param__entry::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_param__entry(soap, this, tag, type);
}

SOAP_FMAC3 param__entry * SOAP_FMAC4 soap_get_param__entry(struct soap *soap, param__entry *p, const char *tag, const char *type)
{
	if ((p = soap_in_param__entry(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *param__entry::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_param__entry(soap, tag, this, type);
}

SOAP_FMAC3 param__entry * SOAP_FMAC4 soap_in_param__entry(struct soap *soap, const char *tag, param__entry *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (param__entry *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_param__entry, sizeof(param__entry), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_param__entry)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (param__entry *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_name1 = 1, soap_flag_value1 = 1;
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__wstring(soap, "name", &(((param__entry*)a)->name), "xsd:wstring"))
				{	soap_flag_name1 = 0;
					continue;
				}
			if (soap_flag_value1 && soap->error == SOAP_TAG_MISMATCH)
				if ((((param__entry*)a)->value).soap_in(soap, "value", "param:value"))
				{	soap_flag_value1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_value1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (param__entry *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_param__entry, 0, sizeof(param__entry), 0, soap_copy_param__entry);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 param__entry * SOAP_FMAC6 soap_new_param__entry(struct soap *soap, int n)
{	return soap_instantiate_param__entry(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_param__entry(struct soap *soap, param__entry *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 param__entry * SOAP_FMAC6 soap_instantiate_param__entry(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_param__entry(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_param__entry, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new param__entry;
		if (size)
			*size = sizeof(param__entry);
	}
	else
	{	cp->ptr = (void*)new param__entry[n];
		if (size)
			*size = n * sizeof(param__entry);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (param__entry*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_param__entry(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying param__entry %p -> %p\n", q, p));
	*(param__entry*)p = *(param__entry*)q;
}

void param__value::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void param__value::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((param__value*)this)->data, SOAP_TYPE_PointerToxsd__anyType);
	soap_mark_PointerToxsd__anyType(soap, &((param__value*)this)->data);
}

void param__value::soap_default(struct soap *soap)
{
	((param__value*)this)->data = NULL;
}

int param__value::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_param__value);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int param__value::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_param__value(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_param__value(struct soap *soap, const char *tag, int id, const param__value *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_param__value), type);
	soap_out_PointerToxsd__anyType(soap, "data", -1, &(((param__value*)a)->data), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *param__value::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_param__value(soap, this, tag, type);
}

SOAP_FMAC3 param__value * SOAP_FMAC4 soap_get_param__value(struct soap *soap, param__value *p, const char *tag, const char *type)
{
	if ((p = soap_in_param__value(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *param__value::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_param__value(soap, tag, this, type);
}

SOAP_FMAC3 param__value * SOAP_FMAC4 soap_in_param__value(struct soap *soap, const char *tag, param__value *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (param__value *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_param__value, sizeof(param__value), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_param__value)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (param__value *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_data1 = 1;
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_data1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "data", &(((param__value*)a)->data), "xsd:anyType"))
				{	soap_flag_data1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (param__value *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_param__value, 0, sizeof(param__value), 0, soap_copy_param__value);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 param__value * SOAP_FMAC6 soap_new_param__value(struct soap *soap, int n)
{	return soap_instantiate_param__value(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_param__value(struct soap *soap, param__value *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 param__value * SOAP_FMAC6 soap_instantiate_param__value(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_param__value(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_param__value, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new param__value;
		if (size)
			*size = sizeof(param__value);
	}
	else
	{	cp->ptr = (void*)new param__value[n];
		if (size)
			*size = n * sizeof(param__value);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (param__value*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_param__value(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying param__value %p -> %p\n", q, p));
	*(param__value*)p = *(param__value*)q;
}

void param_error_loc::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void param_error_loc::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((param_error_loc*)this)->format_id, SOAP_TYPE_xsd__int);
	soap_embedded(soap, &((param_error_loc*)this)->format, SOAP_TYPE_xsd__wstring);
	soap_mark_xsd__wstring(soap, &((param_error_loc*)this)->format);
	soap_embedded(soap, &((param_error_loc*)this)->locmodule, SOAP_TYPE_xsd__wstring);
	soap_mark_xsd__wstring(soap, &((param_error_loc*)this)->locmodule);
	soap_embedded(soap, &((param_error_loc*)this)->args, SOAP_TYPE_param_error_loc_args);
	((param_error_loc*)this)->args.soap_mark(soap);
}

void param_error_loc::soap_default(struct soap *soap)
{
	soap_default_xsd__int(soap, &((param_error_loc*)this)->format_id);
	((param_error_loc*)this)->format = NULL;
	((param_error_loc*)this)->locmodule = NULL;
	((param_error_loc*)this)->args.param_error_loc_args::soap_default(soap);
}

int param_error_loc::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_param_error_loc);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int param_error_loc::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_param_error_loc(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_param_error_loc(struct soap *soap, const char *tag, int id, const param_error_loc *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_param_error_loc), type);
	soap_out_xsd__int(soap, "format-id", -1, &(((param_error_loc*)a)->format_id), "");
	soap_out_xsd__wstring(soap, "format", -1, &(((param_error_loc*)a)->format), "");
	soap_out_xsd__wstring(soap, "locmodule", -1, &(((param_error_loc*)a)->locmodule), "");
	(((param_error_loc*)a)->args).soap_out(soap, "args", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *param_error_loc::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_param_error_loc(soap, this, tag, type);
}

SOAP_FMAC3 param_error_loc * SOAP_FMAC4 soap_get_param_error_loc(struct soap *soap, param_error_loc *p, const char *tag, const char *type)
{
	if ((p = soap_in_param_error_loc(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *param_error_loc::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_param_error_loc(soap, tag, this, type);
}

SOAP_FMAC3 param_error_loc * SOAP_FMAC4 soap_in_param_error_loc(struct soap *soap, const char *tag, param_error_loc *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (param_error_loc *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_param_error_loc, sizeof(param_error_loc), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_param_error_loc)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (param_error_loc *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_format_id1 = 1, soap_flag_format1 = 1, soap_flag_locmodule1 = 1, soap_flag_args1 = 1;
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_format_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "format-id", &(((param_error_loc*)a)->format_id), "xsd:int"))
				{	soap_flag_format_id1 = 0;
					continue;
				}
			if (soap_flag_format1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__wstring(soap, "format", &(((param_error_loc*)a)->format), "xsd:wstring"))
				{	soap_flag_format1 = 0;
					continue;
				}
			if (soap_flag_locmodule1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__wstring(soap, "locmodule", &(((param_error_loc*)a)->locmodule), "xsd:wstring"))
				{	soap_flag_locmodule1 = 0;
					continue;
				}
			if (soap_flag_args1 && soap->error == SOAP_TAG_MISMATCH)
				if ((((param_error_loc*)a)->args).soap_in(soap, "args", "xsd:wstring"))
				{	soap_flag_args1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_format_id1 || soap_flag_args1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (param_error_loc *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_param_error_loc, 0, sizeof(param_error_loc), 0, soap_copy_param_error_loc);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 param_error_loc * SOAP_FMAC6 soap_new_param_error_loc(struct soap *soap, int n)
{	return soap_instantiate_param_error_loc(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_param_error_loc(struct soap *soap, param_error_loc *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 param_error_loc * SOAP_FMAC6 soap_instantiate_param_error_loc(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_param_error_loc(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_param_error_loc, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new param_error_loc;
		if (size)
			*size = sizeof(param_error_loc);
	}
	else
	{	cp->ptr = (void*)new param_error_loc[n];
		if (size)
			*size = n * sizeof(param_error_loc);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (param_error_loc*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_param_error_loc(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying param_error_loc %p -> %p\n", q, p));
	*(param_error_loc*)p = *(param_error_loc*)q;
}

void param_error_loc_args::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void param_error_loc_args::soap_mark(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_param_error_loc_args))
		for (int i = 0; i < this->__size; i++)
		{	soap_embedded(soap, this->__ptr + i, SOAP_TYPE_xsd__wstring);
			soap_mark_xsd__wstring(soap, this->__ptr + i);
		}
}

void param_error_loc_args::soap_default(struct soap *soap)
{
	this->__size = 0;
	this->__ptr = NULL;
}

int param_error_loc_args::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_param_error_loc_args);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int param_error_loc_args::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_param_error_loc_args(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_param_error_loc_args(struct soap *soap, const char *tag, int id, const param_error_loc_args *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "xsd:wstring", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_param_error_loc_args);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_xsd__wstring(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *param_error_loc_args::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_param_error_loc_args(soap, this, tag, type);
}

SOAP_FMAC3 param_error_loc_args * SOAP_FMAC4 soap_get_param_error_loc_args(struct soap *soap, param_error_loc_args *p, const char *tag, const char *type)
{
	if ((p = soap_in_param_error_loc_args(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *param_error_loc_args::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_param_error_loc_args(soap, tag, this, type);
}

SOAP_FMAC3 param_error_loc_args * SOAP_FMAC4 soap_in_param_error_loc_args(struct soap *soap, const char *tag, param_error_loc_args *a, const char *type)
{	int i, j;
	wchar_t **p;
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (param_error_loc_args *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_param_error_loc_args, sizeof(param_error_loc_args), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (wchar_t **)soap_malloc(soap, sizeof(wchar_t *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_xsd__wstring(soap, NULL, a->__ptr + i, "xsd:wstring"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (wchar_t **)soap_push_block(soap, sizeof(wchar_t *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_xsd__wstring(soap, NULL, p, "xsd:wstring"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (wchar_t **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 0);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (param_error_loc_args *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_param_error_loc_args, 0, sizeof(param_error_loc_args), 0, soap_copy_param_error_loc_args);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 param_error_loc_args * SOAP_FMAC6 soap_new_param_error_loc_args(struct soap *soap, int n)
{	return soap_instantiate_param_error_loc_args(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_param_error_loc_args(struct soap *soap, param_error_loc_args *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 param_error_loc_args * SOAP_FMAC6 soap_instantiate_param_error_loc_args(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_param_error_loc_args(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_param_error_loc_args, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new param_error_loc_args;
		if (size)
			*size = sizeof(param_error_loc_args);
	}
	else
	{	cp->ptr = (void*)new param_error_loc_args[n];
		if (size)
			*size = n * sizeof(param_error_loc_args);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (param_error_loc_args*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_param_error_loc_args(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying param_error_loc_args %p -> %p\n", q, p));
	*(param_error_loc_args*)p = *(param_error_loc_args*)q;
}

void SOAPComponentId::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void SOAPComponentId::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((SOAPComponentId*)this)->productName, SOAP_TYPE_xsd__wstring);
	soap_mark_xsd__wstring(soap, &((SOAPComponentId*)this)->productName);
	soap_embedded(soap, &((SOAPComponentId*)this)->version, SOAP_TYPE_xsd__wstring);
	soap_mark_xsd__wstring(soap, &((SOAPComponentId*)this)->version);
	soap_embedded(soap, &((SOAPComponentId*)this)->componentName, SOAP_TYPE_xsd__wstring);
	soap_mark_xsd__wstring(soap, &((SOAPComponentId*)this)->componentName);
	soap_embedded(soap, &((SOAPComponentId*)this)->instanceId, SOAP_TYPE_xsd__wstring);
	soap_mark_xsd__wstring(soap, &((SOAPComponentId*)this)->instanceId);
}

void SOAPComponentId::soap_default(struct soap *soap)
{
	((SOAPComponentId*)this)->productName = NULL;
	((SOAPComponentId*)this)->version = NULL;
	((SOAPComponentId*)this)->componentName = NULL;
	((SOAPComponentId*)this)->instanceId = NULL;
}

int SOAPComponentId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_SOAPComponentId);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int SOAPComponentId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_SOAPComponentId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAPComponentId(struct soap *soap, const char *tag, int id, const SOAPComponentId *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAPComponentId), type);
	soap_out_xsd__wstring(soap, "productName", -1, &(((SOAPComponentId*)a)->productName), "");
	soap_out_xsd__wstring(soap, "version", -1, &(((SOAPComponentId*)a)->version), "");
	soap_out_xsd__wstring(soap, "componentName", -1, &(((SOAPComponentId*)a)->componentName), "");
	soap_out_xsd__wstring(soap, "instanceId", -1, &(((SOAPComponentId*)a)->instanceId), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *SOAPComponentId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_SOAPComponentId(soap, this, tag, type);
}

SOAP_FMAC3 SOAPComponentId * SOAP_FMAC4 soap_get_SOAPComponentId(struct soap *soap, SOAPComponentId *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAPComponentId(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *SOAPComponentId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_SOAPComponentId(soap, tag, this, type);
}

SOAP_FMAC3 SOAPComponentId * SOAP_FMAC4 soap_in_SOAPComponentId(struct soap *soap, const char *tag, SOAPComponentId *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (SOAPComponentId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_SOAPComponentId, sizeof(SOAPComponentId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_SOAPComponentId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (SOAPComponentId *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_productName1 = 1, soap_flag_version1 = 1, soap_flag_componentName1 = 1, soap_flag_instanceId1 = 1;
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_productName1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__wstring(soap, "productName", &(((SOAPComponentId*)a)->productName), "xsd:wstring"))
				{	soap_flag_productName1 = 0;
					continue;
				}
			if (soap_flag_version1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__wstring(soap, "version", &(((SOAPComponentId*)a)->version), "xsd:wstring"))
				{	soap_flag_version1 = 0;
					continue;
				}
			if (soap_flag_componentName1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__wstring(soap, "componentName", &(((SOAPComponentId*)a)->componentName), "xsd:wstring"))
				{	soap_flag_componentName1 = 0;
					continue;
				}
			if (soap_flag_instanceId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__wstring(soap, "instanceId", &(((SOAPComponentId*)a)->instanceId), "xsd:wstring"))
				{	soap_flag_instanceId1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (SOAPComponentId *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_SOAPComponentId, 0, sizeof(SOAPComponentId), 0, soap_copy_SOAPComponentId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 SOAPComponentId * SOAP_FMAC6 soap_new_SOAPComponentId(struct soap *soap, int n)
{	return soap_instantiate_SOAPComponentId(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAPComponentId(struct soap *soap, SOAPComponentId *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 SOAPComponentId * SOAP_FMAC6 soap_instantiate_SOAPComponentId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAPComponentId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAPComponentId, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new SOAPComponentId;
		if (size)
			*size = sizeof(SOAPComponentId);
	}
	else
	{	cp->ptr = (void*)new SOAPComponentId[n];
		if (size)
			*size = n * sizeof(SOAPComponentId);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (SOAPComponentId*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_SOAPComponentId(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying SOAPComponentId %p -> %p\n", q, p));
	*(SOAPComponentId*)p = *(SOAPComponentId*)q;
}

void xsd__hexBinary::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__hexBinary::soap_mark(struct soap *soap) const
{
	if (this->__ptr)
		soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_xsd__hexBinary);
}

void xsd__hexBinary::soap_default(struct soap *soap)
{
	this->__size = 0;
	this->__ptr = NULL;
}

int xsd__hexBinary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_xsd__hexBinary);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__hexBinary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_xsd__hexBinary(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__hexBinary(struct soap *soap, const char *tag, int id, const xsd__hexBinary *a, const char *type)
{
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_xsd__hexBinary);
	if (id < 0)
		return soap->error;
	soap_element_begin_out(soap, tag, id, "xsd:hexBinary");
	soap_puthex(soap, a->__ptr, a->__size);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *xsd__hexBinary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__hexBinary(soap, this, tag, type);
}

SOAP_FMAC3 xsd__hexBinary * SOAP_FMAC4 soap_get_xsd__hexBinary(struct soap *soap, xsd__hexBinary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__hexBinary(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__hexBinary::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__hexBinary(soap, tag, this, type);
}

SOAP_FMAC3 xsd__hexBinary * SOAP_FMAC4 soap_in_xsd__hexBinary(struct soap *soap, const char *tag, xsd__hexBinary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":hexBinary"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__hexBinary *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__hexBinary, sizeof(xsd__hexBinary), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_gethex(soap, &a->__size);
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (xsd__hexBinary *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_xsd__hexBinary, 0, sizeof(xsd__hexBinary), 0, soap_copy_xsd__hexBinary);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 xsd__hexBinary * SOAP_FMAC6 soap_new_xsd__hexBinary(struct soap *soap, int n)
{	return soap_instantiate_xsd__hexBinary(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__hexBinary(struct soap *soap, xsd__hexBinary *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__hexBinary * SOAP_FMAC6 soap_instantiate_xsd__hexBinary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__hexBinary(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__hexBinary, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__hexBinary;
		if (size)
			*size = sizeof(xsd__hexBinary);
	}
	else
	{	cp->ptr = (void*)new xsd__hexBinary[n];
		if (size)
			*size = n * sizeof(xsd__hexBinary);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__hexBinary*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__hexBinary(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__hexBinary %p -> %p\n", q, p));
	*(xsd__hexBinary*)p = *(xsd__hexBinary*)q;
}

void xsd__base64Binary::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__base64Binary::soap_mark(struct soap *soap) const
{
	if (this->__ptr)
		soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_xsd__base64Binary);
}

void xsd__base64Binary::soap_default(struct soap *soap)
{
	this->__size = 0;
	this->__ptr = NULL;
}

int xsd__base64Binary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_xsd__base64Binary);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__base64Binary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_xsd__base64Binary(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary(struct soap *soap, const char *tag, int id, const xsd__base64Binary *a, const char *type)
{
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_xsd__base64Binary);
	if (id < 0)
		return soap->error;
	soap_element_begin_out(soap, tag, id, "xsd:base64Binary");
	soap_putbase64(soap, a->__ptr, a->__size);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *xsd__base64Binary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__base64Binary(soap, this, tag, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_get_xsd__base64Binary(struct soap *soap, xsd__base64Binary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__base64Binary(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__base64Binary::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__base64Binary(soap, tag, this, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_in_xsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__base64Binary *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (xsd__base64Binary *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_xsd__base64Binary, 0, sizeof(xsd__base64Binary), 0, soap_copy_xsd__base64Binary);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 xsd__base64Binary * SOAP_FMAC6 soap_new_xsd__base64Binary(struct soap *soap, int n)
{	return soap_instantiate_xsd__base64Binary(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__base64Binary(struct soap *soap, xsd__base64Binary *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__base64Binary * SOAP_FMAC6 soap_instantiate_xsd__base64Binary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__base64Binary(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__base64Binary, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__base64Binary;
		if (size)
			*size = sizeof(xsd__base64Binary);
	}
	else
	{	cp->ptr = (void*)new xsd__base64Binary[n];
		if (size)
			*size = n * sizeof(xsd__base64Binary);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__base64Binary*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__base64Binary(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__base64Binary %p -> %p\n", q, p));
	*(xsd__base64Binary*)p = *(xsd__base64Binary*)q;
}

void xsd__token_::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__token_::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((xsd__token_*)this)->__item, SOAP_TYPE_xsd__token);
	soap_mark_xsd__token(soap, &((xsd__token_*)this)->__item);
	soap_embedded(soap, &((xsd__normalizedString_*)this)->__item, SOAP_TYPE_xsd__normalizedString);
	soap_mark_xsd__normalizedString(soap, &((xsd__normalizedString_*)this)->__item);
	soap_embedded(soap, &((xsd__string_*)this)->__item, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &((xsd__string_*)this)->__item);
}

void xsd__token_::soap_default(struct soap *soap)
{
	((xsd__token_*)this)->__item = NULL;
	((xsd__normalizedString_*)this)->__item = NULL;
	((xsd__string_*)this)->__item = NULL;
}

int xsd__token_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__token_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__token_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__token_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__token_(struct soap *soap, const char *tag, int id, const xsd__token_ *a, const char *type)
{
	soap_out_xsd__token(soap, tag, id, &(((xsd__token_*)a)->__item), "xsd:token");
	return SOAP_OK;
}

void *xsd__token_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__token_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__token_ * SOAP_FMAC4 soap_get_xsd__token_(struct soap *soap, xsd__token_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__token_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__token_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__token_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__token_ * SOAP_FMAC4 soap_in_xsd__token_(struct soap *soap, const char *tag, xsd__token_ *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (xsd__token_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__token_, sizeof(xsd__token_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__token_)
			return (xsd__token_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__token(soap, tag, &(((xsd__token_*)a)->__item), "xsd:token"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__token_ * SOAP_FMAC6 soap_new_xsd__token_(struct soap *soap, int n)
{	return soap_instantiate_xsd__token_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__token_(struct soap *soap, xsd__token_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__token_ * SOAP_FMAC6 soap_instantiate_xsd__token_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__token_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__token_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__token_;
		if (size)
			*size = sizeof(xsd__token_);
	}
	else
	{	cp->ptr = (void*)new xsd__token_[n];
		if (size)
			*size = n * sizeof(xsd__token_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__token_*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__token_(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__token_ %p -> %p\n", q, p));
	*(xsd__token_*)p = *(xsd__token_*)q;
}

void xsd__normalizedString_::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__normalizedString_::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((xsd__normalizedString_*)this)->__item, SOAP_TYPE_xsd__normalizedString);
	soap_mark_xsd__normalizedString(soap, &((xsd__normalizedString_*)this)->__item);
	soap_embedded(soap, &((xsd__string_*)this)->__item, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &((xsd__string_*)this)->__item);
}

void xsd__normalizedString_::soap_default(struct soap *soap)
{
	((xsd__normalizedString_*)this)->__item = NULL;
	((xsd__string_*)this)->__item = NULL;
}

int xsd__normalizedString_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__normalizedString_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__normalizedString_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__normalizedString_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__normalizedString_(struct soap *soap, const char *tag, int id, const xsd__normalizedString_ *a, const char *type)
{
	soap_out_xsd__normalizedString(soap, tag, id, &(((xsd__normalizedString_*)a)->__item), "xsd:normalizedString");
	return SOAP_OK;
}

void *xsd__normalizedString_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__normalizedString_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__normalizedString_ * SOAP_FMAC4 soap_get_xsd__normalizedString_(struct soap *soap, xsd__normalizedString_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__normalizedString_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__normalizedString_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__normalizedString_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__normalizedString_ * SOAP_FMAC4 soap_in_xsd__normalizedString_(struct soap *soap, const char *tag, xsd__normalizedString_ *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (xsd__normalizedString_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__normalizedString_, sizeof(xsd__normalizedString_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__normalizedString_)
			return (xsd__normalizedString_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__normalizedString(soap, tag, &(((xsd__normalizedString_*)a)->__item), "xsd:normalizedString"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__normalizedString_ * SOAP_FMAC6 soap_new_xsd__normalizedString_(struct soap *soap, int n)
{	return soap_instantiate_xsd__normalizedString_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__normalizedString_(struct soap *soap, xsd__normalizedString_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__normalizedString_ * SOAP_FMAC6 soap_instantiate_xsd__normalizedString_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__normalizedString_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__normalizedString_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "xsd:token"))
	{	cp->type = SOAP_TYPE_xsd__token_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__token_;
			if (size)
				*size = sizeof(xsd__token_);
		}
		else
		{	cp->ptr = (void*)new xsd__token_[n];
			if (size)
				*size = n * sizeof(xsd__token_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__token_*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new xsd__normalizedString_;
		if (size)
			*size = sizeof(xsd__normalizedString_);
	}
	else
	{	cp->ptr = (void*)new xsd__normalizedString_[n];
		if (size)
			*size = n * sizeof(xsd__normalizedString_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__normalizedString_*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__normalizedString_(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__normalizedString_ %p -> %p\n", q, p));
	*(xsd__normalizedString_*)p = *(xsd__normalizedString_*)q;
}

void xsd__string_::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__string_::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((xsd__string_*)this)->__item, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &((xsd__string_*)this)->__item);
}

void xsd__string_::soap_default(struct soap *soap)
{
	((xsd__string_*)this)->__item = NULL;
}

int xsd__string_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__string_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__string_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__string_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__string_(struct soap *soap, const char *tag, int id, const xsd__string_ *a, const char *type)
{
	soap_out_xsd__string(soap, tag, id, &(((xsd__string_*)a)->__item), "xsd:string");
	return SOAP_OK;
}

void *xsd__string_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__string_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__string_ * SOAP_FMAC4 soap_get_xsd__string_(struct soap *soap, xsd__string_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__string_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__string_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__string_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__string_ * SOAP_FMAC4 soap_in_xsd__string_(struct soap *soap, const char *tag, xsd__string_ *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (xsd__string_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__string_, sizeof(xsd__string_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__string_)
			return (xsd__string_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__string(soap, tag, &(((xsd__string_*)a)->__item), "xsd:string"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__string_ * SOAP_FMAC6 soap_new_xsd__string_(struct soap *soap, int n)
{	return soap_instantiate_xsd__string_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__string_(struct soap *soap, xsd__string_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__string_ * SOAP_FMAC6 soap_instantiate_xsd__string_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__string_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__string_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "xsd:normalizedString"))
	{	cp->type = SOAP_TYPE_xsd__normalizedString_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__normalizedString_;
			if (size)
				*size = sizeof(xsd__normalizedString_);
		}
		else
		{	cp->ptr = (void*)new xsd__normalizedString_[n];
			if (size)
				*size = n * sizeof(xsd__normalizedString_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__normalizedString_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:token"))
	{	cp->type = SOAP_TYPE_xsd__token_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__token_;
			if (size)
				*size = sizeof(xsd__token_);
		}
		else
		{	cp->ptr = (void*)new xsd__token_[n];
			if (size)
				*size = n * sizeof(xsd__token_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__token_*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new xsd__string_;
		if (size)
			*size = sizeof(xsd__string_);
	}
	else
	{	cp->ptr = (void*)new xsd__string_[n];
		if (size)
			*size = n * sizeof(xsd__string_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__string_*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__string_(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__string_ %p -> %p\n", q, p));
	*(xsd__string_*)p = *(xsd__string_*)q;
}

void xsd__wstring_::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__wstring_::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((xsd__wstring_*)this)->__item, SOAP_TYPE_xsd__wstring);
	soap_mark_xsd__wstring(soap, &((xsd__wstring_*)this)->__item);
}

void xsd__wstring_::soap_default(struct soap *soap)
{
	((xsd__wstring_*)this)->__item = NULL;
}

int xsd__wstring_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__wstring_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__wstring_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__wstring_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__wstring_(struct soap *soap, const char *tag, int id, const xsd__wstring_ *a, const char *type)
{
	soap_out_xsd__wstring(soap, tag, id, &(((xsd__wstring_*)a)->__item), "xsd:wstring");
	return SOAP_OK;
}

void *xsd__wstring_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__wstring_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__wstring_ * SOAP_FMAC4 soap_get_xsd__wstring_(struct soap *soap, xsd__wstring_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__wstring_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__wstring_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__wstring_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__wstring_ * SOAP_FMAC4 soap_in_xsd__wstring_(struct soap *soap, const char *tag, xsd__wstring_ *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (xsd__wstring_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__wstring_, sizeof(xsd__wstring_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__wstring_)
			return (xsd__wstring_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__wstring(soap, tag, &(((xsd__wstring_*)a)->__item), "xsd:wstring"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__wstring_ * SOAP_FMAC6 soap_new_xsd__wstring_(struct soap *soap, int n)
{	return soap_instantiate_xsd__wstring_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__wstring_(struct soap *soap, xsd__wstring_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__wstring_ * SOAP_FMAC6 soap_instantiate_xsd__wstring_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__wstring_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__wstring_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__wstring_;
		if (size)
			*size = sizeof(xsd__wstring_);
	}
	else
	{	cp->ptr = (void*)new xsd__wstring_[n];
		if (size)
			*size = n * sizeof(xsd__wstring_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__wstring_*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__wstring_(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__wstring_ %p -> %p\n", q, p));
	*(xsd__wstring_*)p = *(xsd__wstring_*)q;
}

void xsd__unsignedByte_::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__unsignedByte_::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((xsd__unsignedByte_*)this)->__item, SOAP_TYPE_xsd__unsignedByte);
	soap_embedded(soap, &((xsd__unsignedShort_*)this)->__item, SOAP_TYPE_xsd__unsignedShort);
	soap_embedded(soap, &((xsd__unsignedInt_*)this)->__item, SOAP_TYPE_xsd__unsignedInt);
	soap_embedded(soap, &((xsd__unsignedLong_*)this)->__item, SOAP_TYPE_xsd__unsignedLong);
	soap_embedded(soap, &((xsd__nonNegativeInteger_*)this)->__item, SOAP_TYPE_xsd__nonNegativeInteger);
	soap_mark_xsd__nonNegativeInteger(soap, &((xsd__nonNegativeInteger_*)this)->__item);
	soap_embedded(soap, &((xsd__integer_*)this)->__item, SOAP_TYPE_xsd__integer);
	soap_mark_xsd__integer(soap, &((xsd__integer_*)this)->__item);
	soap_embedded(soap, &((xsd__decimal_*)this)->__item, SOAP_TYPE_xsd__decimal);
	soap_mark_xsd__decimal(soap, &((xsd__decimal_*)this)->__item);
}

void xsd__unsignedByte_::soap_default(struct soap *soap)
{
	soap_default_xsd__unsignedByte(soap, &((xsd__unsignedByte_*)this)->__item);
	soap_default_xsd__unsignedShort(soap, &((xsd__unsignedShort_*)this)->__item);
	soap_default_xsd__unsignedInt(soap, &((xsd__unsignedInt_*)this)->__item);
	soap_default_xsd__unsignedLong(soap, &((xsd__unsignedLong_*)this)->__item);
	((xsd__nonNegativeInteger_*)this)->__item = NULL;
	((xsd__integer_*)this)->__item = NULL;
	((xsd__decimal_*)this)->__item = NULL;
}

int xsd__unsignedByte_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__unsignedByte_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__unsignedByte_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__unsignedByte_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__unsignedByte_(struct soap *soap, const char *tag, int id, const xsd__unsignedByte_ *a, const char *type)
{
	soap_out_xsd__unsignedByte(soap, tag, id, &(((xsd__unsignedByte_*)a)->__item), "xsd:unsignedByte");
	return SOAP_OK;
}

void *xsd__unsignedByte_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__unsignedByte_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__unsignedByte_ * SOAP_FMAC4 soap_get_xsd__unsignedByte_(struct soap *soap, xsd__unsignedByte_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__unsignedByte_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__unsignedByte_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__unsignedByte_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__unsignedByte_ * SOAP_FMAC4 soap_in_xsd__unsignedByte_(struct soap *soap, const char *tag, xsd__unsignedByte_ *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (xsd__unsignedByte_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__unsignedByte_, sizeof(xsd__unsignedByte_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__unsignedByte_)
			return (xsd__unsignedByte_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__unsignedByte(soap, tag, &(((xsd__unsignedByte_*)a)->__item), "xsd:unsignedByte"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__unsignedByte_ * SOAP_FMAC6 soap_new_xsd__unsignedByte_(struct soap *soap, int n)
{	return soap_instantiate_xsd__unsignedByte_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__unsignedByte_(struct soap *soap, xsd__unsignedByte_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__unsignedByte_ * SOAP_FMAC6 soap_instantiate_xsd__unsignedByte_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__unsignedByte_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__unsignedByte_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__unsignedByte_;
		if (size)
			*size = sizeof(xsd__unsignedByte_);
	}
	else
	{	cp->ptr = (void*)new xsd__unsignedByte_[n];
		if (size)
			*size = n * sizeof(xsd__unsignedByte_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__unsignedByte_*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__unsignedByte_(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__unsignedByte_ %p -> %p\n", q, p));
	*(xsd__unsignedByte_*)p = *(xsd__unsignedByte_*)q;
}

void xsd__unsignedShort_::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__unsignedShort_::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((xsd__unsignedShort_*)this)->__item, SOAP_TYPE_xsd__unsignedShort);
	soap_embedded(soap, &((xsd__unsignedInt_*)this)->__item, SOAP_TYPE_xsd__unsignedInt);
	soap_embedded(soap, &((xsd__unsignedLong_*)this)->__item, SOAP_TYPE_xsd__unsignedLong);
	soap_embedded(soap, &((xsd__nonNegativeInteger_*)this)->__item, SOAP_TYPE_xsd__nonNegativeInteger);
	soap_mark_xsd__nonNegativeInteger(soap, &((xsd__nonNegativeInteger_*)this)->__item);
	soap_embedded(soap, &((xsd__integer_*)this)->__item, SOAP_TYPE_xsd__integer);
	soap_mark_xsd__integer(soap, &((xsd__integer_*)this)->__item);
	soap_embedded(soap, &((xsd__decimal_*)this)->__item, SOAP_TYPE_xsd__decimal);
	soap_mark_xsd__decimal(soap, &((xsd__decimal_*)this)->__item);
}

void xsd__unsignedShort_::soap_default(struct soap *soap)
{
	soap_default_xsd__unsignedShort(soap, &((xsd__unsignedShort_*)this)->__item);
	soap_default_xsd__unsignedInt(soap, &((xsd__unsignedInt_*)this)->__item);
	soap_default_xsd__unsignedLong(soap, &((xsd__unsignedLong_*)this)->__item);
	((xsd__nonNegativeInteger_*)this)->__item = NULL;
	((xsd__integer_*)this)->__item = NULL;
	((xsd__decimal_*)this)->__item = NULL;
}

int xsd__unsignedShort_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__unsignedShort_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__unsignedShort_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__unsignedShort_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__unsignedShort_(struct soap *soap, const char *tag, int id, const xsd__unsignedShort_ *a, const char *type)
{
	soap_out_xsd__unsignedShort(soap, tag, id, &(((xsd__unsignedShort_*)a)->__item), "xsd:unsignedShort");
	return SOAP_OK;
}

void *xsd__unsignedShort_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__unsignedShort_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__unsignedShort_ * SOAP_FMAC4 soap_get_xsd__unsignedShort_(struct soap *soap, xsd__unsignedShort_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__unsignedShort_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__unsignedShort_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__unsignedShort_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__unsignedShort_ * SOAP_FMAC4 soap_in_xsd__unsignedShort_(struct soap *soap, const char *tag, xsd__unsignedShort_ *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (xsd__unsignedShort_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__unsignedShort_, sizeof(xsd__unsignedShort_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__unsignedShort_)
			return (xsd__unsignedShort_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__unsignedShort(soap, tag, &(((xsd__unsignedShort_*)a)->__item), "xsd:unsignedShort"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__unsignedShort_ * SOAP_FMAC6 soap_new_xsd__unsignedShort_(struct soap *soap, int n)
{	return soap_instantiate_xsd__unsignedShort_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__unsignedShort_(struct soap *soap, xsd__unsignedShort_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__unsignedShort_ * SOAP_FMAC6 soap_instantiate_xsd__unsignedShort_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__unsignedShort_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__unsignedShort_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "xsd:unsignedByte"))
	{	cp->type = SOAP_TYPE_xsd__unsignedByte_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedByte_;
			if (size)
				*size = sizeof(xsd__unsignedByte_);
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedByte_[n];
			if (size)
				*size = n * sizeof(xsd__unsignedByte_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedByte_*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new xsd__unsignedShort_;
		if (size)
			*size = sizeof(xsd__unsignedShort_);
	}
	else
	{	cp->ptr = (void*)new xsd__unsignedShort_[n];
		if (size)
			*size = n * sizeof(xsd__unsignedShort_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__unsignedShort_*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__unsignedShort_(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__unsignedShort_ %p -> %p\n", q, p));
	*(xsd__unsignedShort_*)p = *(xsd__unsignedShort_*)q;
}

void xsd__unsignedInt_::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__unsignedInt_::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((xsd__unsignedInt_*)this)->__item, SOAP_TYPE_xsd__unsignedInt);
	soap_embedded(soap, &((xsd__unsignedLong_*)this)->__item, SOAP_TYPE_xsd__unsignedLong);
	soap_embedded(soap, &((xsd__nonNegativeInteger_*)this)->__item, SOAP_TYPE_xsd__nonNegativeInteger);
	soap_mark_xsd__nonNegativeInteger(soap, &((xsd__nonNegativeInteger_*)this)->__item);
	soap_embedded(soap, &((xsd__integer_*)this)->__item, SOAP_TYPE_xsd__integer);
	soap_mark_xsd__integer(soap, &((xsd__integer_*)this)->__item);
	soap_embedded(soap, &((xsd__decimal_*)this)->__item, SOAP_TYPE_xsd__decimal);
	soap_mark_xsd__decimal(soap, &((xsd__decimal_*)this)->__item);
}

void xsd__unsignedInt_::soap_default(struct soap *soap)
{
	soap_default_xsd__unsignedInt(soap, &((xsd__unsignedInt_*)this)->__item);
	soap_default_xsd__unsignedLong(soap, &((xsd__unsignedLong_*)this)->__item);
	((xsd__nonNegativeInteger_*)this)->__item = NULL;
	((xsd__integer_*)this)->__item = NULL;
	((xsd__decimal_*)this)->__item = NULL;
}

int xsd__unsignedInt_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__unsignedInt_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__unsignedInt_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__unsignedInt_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__unsignedInt_(struct soap *soap, const char *tag, int id, const xsd__unsignedInt_ *a, const char *type)
{
	soap_out_xsd__unsignedInt(soap, tag, id, &(((xsd__unsignedInt_*)a)->__item), "xsd:unsignedInt");
	return SOAP_OK;
}

void *xsd__unsignedInt_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__unsignedInt_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__unsignedInt_ * SOAP_FMAC4 soap_get_xsd__unsignedInt_(struct soap *soap, xsd__unsignedInt_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__unsignedInt_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__unsignedInt_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__unsignedInt_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__unsignedInt_ * SOAP_FMAC4 soap_in_xsd__unsignedInt_(struct soap *soap, const char *tag, xsd__unsignedInt_ *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (xsd__unsignedInt_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__unsignedInt_, sizeof(xsd__unsignedInt_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__unsignedInt_)
			return (xsd__unsignedInt_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__unsignedInt(soap, tag, &(((xsd__unsignedInt_*)a)->__item), "xsd:unsignedInt"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__unsignedInt_ * SOAP_FMAC6 soap_new_xsd__unsignedInt_(struct soap *soap, int n)
{	return soap_instantiate_xsd__unsignedInt_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__unsignedInt_(struct soap *soap, xsd__unsignedInt_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__unsignedInt_ * SOAP_FMAC6 soap_instantiate_xsd__unsignedInt_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__unsignedInt_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__unsignedInt_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "xsd:unsignedShort"))
	{	cp->type = SOAP_TYPE_xsd__unsignedShort_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedShort_;
			if (size)
				*size = sizeof(xsd__unsignedShort_);
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedShort_[n];
			if (size)
				*size = n * sizeof(xsd__unsignedShort_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedShort_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedByte"))
	{	cp->type = SOAP_TYPE_xsd__unsignedByte_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedByte_;
			if (size)
				*size = sizeof(xsd__unsignedByte_);
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedByte_[n];
			if (size)
				*size = n * sizeof(xsd__unsignedByte_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedByte_*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new xsd__unsignedInt_;
		if (size)
			*size = sizeof(xsd__unsignedInt_);
	}
	else
	{	cp->ptr = (void*)new xsd__unsignedInt_[n];
		if (size)
			*size = n * sizeof(xsd__unsignedInt_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__unsignedInt_*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__unsignedInt_(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__unsignedInt_ %p -> %p\n", q, p));
	*(xsd__unsignedInt_*)p = *(xsd__unsignedInt_*)q;
}

void xsd__unsignedLong_::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__unsignedLong_::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((xsd__unsignedLong_*)this)->__item, SOAP_TYPE_xsd__unsignedLong);
	soap_embedded(soap, &((xsd__nonNegativeInteger_*)this)->__item, SOAP_TYPE_xsd__nonNegativeInteger);
	soap_mark_xsd__nonNegativeInteger(soap, &((xsd__nonNegativeInteger_*)this)->__item);
	soap_embedded(soap, &((xsd__integer_*)this)->__item, SOAP_TYPE_xsd__integer);
	soap_mark_xsd__integer(soap, &((xsd__integer_*)this)->__item);
	soap_embedded(soap, &((xsd__decimal_*)this)->__item, SOAP_TYPE_xsd__decimal);
	soap_mark_xsd__decimal(soap, &((xsd__decimal_*)this)->__item);
}

void xsd__unsignedLong_::soap_default(struct soap *soap)
{
	soap_default_xsd__unsignedLong(soap, &((xsd__unsignedLong_*)this)->__item);
	((xsd__nonNegativeInteger_*)this)->__item = NULL;
	((xsd__integer_*)this)->__item = NULL;
	((xsd__decimal_*)this)->__item = NULL;
}

int xsd__unsignedLong_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__unsignedLong_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__unsignedLong_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__unsignedLong_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__unsignedLong_(struct soap *soap, const char *tag, int id, const xsd__unsignedLong_ *a, const char *type)
{
	soap_out_xsd__unsignedLong(soap, tag, id, &(((xsd__unsignedLong_*)a)->__item), "xsd:unsignedLong");
	return SOAP_OK;
}

void *xsd__unsignedLong_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__unsignedLong_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__unsignedLong_ * SOAP_FMAC4 soap_get_xsd__unsignedLong_(struct soap *soap, xsd__unsignedLong_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__unsignedLong_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__unsignedLong_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__unsignedLong_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__unsignedLong_ * SOAP_FMAC4 soap_in_xsd__unsignedLong_(struct soap *soap, const char *tag, xsd__unsignedLong_ *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (xsd__unsignedLong_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__unsignedLong_, sizeof(xsd__unsignedLong_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__unsignedLong_)
			return (xsd__unsignedLong_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__unsignedLong(soap, tag, &(((xsd__unsignedLong_*)a)->__item), "xsd:unsignedLong"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__unsignedLong_ * SOAP_FMAC6 soap_new_xsd__unsignedLong_(struct soap *soap, int n)
{	return soap_instantiate_xsd__unsignedLong_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__unsignedLong_(struct soap *soap, xsd__unsignedLong_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__unsignedLong_ * SOAP_FMAC6 soap_instantiate_xsd__unsignedLong_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__unsignedLong_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__unsignedLong_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "xsd:unsignedInt"))
	{	cp->type = SOAP_TYPE_xsd__unsignedInt_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedInt_;
			if (size)
				*size = sizeof(xsd__unsignedInt_);
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedInt_[n];
			if (size)
				*size = n * sizeof(xsd__unsignedInt_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedInt_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedShort"))
	{	cp->type = SOAP_TYPE_xsd__unsignedShort_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedShort_;
			if (size)
				*size = sizeof(xsd__unsignedShort_);
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedShort_[n];
			if (size)
				*size = n * sizeof(xsd__unsignedShort_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedShort_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedByte"))
	{	cp->type = SOAP_TYPE_xsd__unsignedByte_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedByte_;
			if (size)
				*size = sizeof(xsd__unsignedByte_);
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedByte_[n];
			if (size)
				*size = n * sizeof(xsd__unsignedByte_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedByte_*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new xsd__unsignedLong_;
		if (size)
			*size = sizeof(xsd__unsignedLong_);
	}
	else
	{	cp->ptr = (void*)new xsd__unsignedLong_[n];
		if (size)
			*size = n * sizeof(xsd__unsignedLong_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__unsignedLong_*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__unsignedLong_(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__unsignedLong_ %p -> %p\n", q, p));
	*(xsd__unsignedLong_*)p = *(xsd__unsignedLong_*)q;
}

void xsd__positiveInteger_::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__positiveInteger_::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((xsd__positiveInteger_*)this)->__item, SOAP_TYPE_xsd__positiveInteger);
	soap_mark_xsd__positiveInteger(soap, &((xsd__positiveInteger_*)this)->__item);
	soap_embedded(soap, &((xsd__nonNegativeInteger_*)this)->__item, SOAP_TYPE_xsd__nonNegativeInteger);
	soap_mark_xsd__nonNegativeInteger(soap, &((xsd__nonNegativeInteger_*)this)->__item);
	soap_embedded(soap, &((xsd__integer_*)this)->__item, SOAP_TYPE_xsd__integer);
	soap_mark_xsd__integer(soap, &((xsd__integer_*)this)->__item);
	soap_embedded(soap, &((xsd__decimal_*)this)->__item, SOAP_TYPE_xsd__decimal);
	soap_mark_xsd__decimal(soap, &((xsd__decimal_*)this)->__item);
}

void xsd__positiveInteger_::soap_default(struct soap *soap)
{
	((xsd__positiveInteger_*)this)->__item = NULL;
	((xsd__nonNegativeInteger_*)this)->__item = NULL;
	((xsd__integer_*)this)->__item = NULL;
	((xsd__decimal_*)this)->__item = NULL;
}

int xsd__positiveInteger_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__positiveInteger_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__positiveInteger_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__positiveInteger_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__positiveInteger_(struct soap *soap, const char *tag, int id, const xsd__positiveInteger_ *a, const char *type)
{
	soap_out_xsd__positiveInteger(soap, tag, id, &(((xsd__positiveInteger_*)a)->__item), "xsd:positiveInteger");
	return SOAP_OK;
}

void *xsd__positiveInteger_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__positiveInteger_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__positiveInteger_ * SOAP_FMAC4 soap_get_xsd__positiveInteger_(struct soap *soap, xsd__positiveInteger_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__positiveInteger_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__positiveInteger_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__positiveInteger_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__positiveInteger_ * SOAP_FMAC4 soap_in_xsd__positiveInteger_(struct soap *soap, const char *tag, xsd__positiveInteger_ *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (xsd__positiveInteger_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__positiveInteger_, sizeof(xsd__positiveInteger_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__positiveInteger_)
			return (xsd__positiveInteger_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__positiveInteger(soap, tag, &(((xsd__positiveInteger_*)a)->__item), "xsd:positiveInteger"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__positiveInteger_ * SOAP_FMAC6 soap_new_xsd__positiveInteger_(struct soap *soap, int n)
{	return soap_instantiate_xsd__positiveInteger_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__positiveInteger_(struct soap *soap, xsd__positiveInteger_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__positiveInteger_ * SOAP_FMAC6 soap_instantiate_xsd__positiveInteger_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__positiveInteger_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__positiveInteger_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__positiveInteger_;
		if (size)
			*size = sizeof(xsd__positiveInteger_);
	}
	else
	{	cp->ptr = (void*)new xsd__positiveInteger_[n];
		if (size)
			*size = n * sizeof(xsd__positiveInteger_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__positiveInteger_*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__positiveInteger_(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__positiveInteger_ %p -> %p\n", q, p));
	*(xsd__positiveInteger_*)p = *(xsd__positiveInteger_*)q;
}

void xsd__nonNegativeInteger_::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__nonNegativeInteger_::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((xsd__nonNegativeInteger_*)this)->__item, SOAP_TYPE_xsd__nonNegativeInteger);
	soap_mark_xsd__nonNegativeInteger(soap, &((xsd__nonNegativeInteger_*)this)->__item);
	soap_embedded(soap, &((xsd__integer_*)this)->__item, SOAP_TYPE_xsd__integer);
	soap_mark_xsd__integer(soap, &((xsd__integer_*)this)->__item);
	soap_embedded(soap, &((xsd__decimal_*)this)->__item, SOAP_TYPE_xsd__decimal);
	soap_mark_xsd__decimal(soap, &((xsd__decimal_*)this)->__item);
}

void xsd__nonNegativeInteger_::soap_default(struct soap *soap)
{
	((xsd__nonNegativeInteger_*)this)->__item = NULL;
	((xsd__integer_*)this)->__item = NULL;
	((xsd__decimal_*)this)->__item = NULL;
}

int xsd__nonNegativeInteger_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__nonNegativeInteger_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__nonNegativeInteger_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__nonNegativeInteger_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__nonNegativeInteger_(struct soap *soap, const char *tag, int id, const xsd__nonNegativeInteger_ *a, const char *type)
{
	soap_out_xsd__nonNegativeInteger(soap, tag, id, &(((xsd__nonNegativeInteger_*)a)->__item), "xsd:nonNegativeInteger");
	return SOAP_OK;
}

void *xsd__nonNegativeInteger_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__nonNegativeInteger_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__nonNegativeInteger_ * SOAP_FMAC4 soap_get_xsd__nonNegativeInteger_(struct soap *soap, xsd__nonNegativeInteger_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__nonNegativeInteger_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__nonNegativeInteger_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__nonNegativeInteger_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__nonNegativeInteger_ * SOAP_FMAC4 soap_in_xsd__nonNegativeInteger_(struct soap *soap, const char *tag, xsd__nonNegativeInteger_ *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (xsd__nonNegativeInteger_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__nonNegativeInteger_, sizeof(xsd__nonNegativeInteger_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__nonNegativeInteger_)
			return (xsd__nonNegativeInteger_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__nonNegativeInteger(soap, tag, &(((xsd__nonNegativeInteger_*)a)->__item), "xsd:nonNegativeInteger"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__nonNegativeInteger_ * SOAP_FMAC6 soap_new_xsd__nonNegativeInteger_(struct soap *soap, int n)
{	return soap_instantiate_xsd__nonNegativeInteger_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__nonNegativeInteger_(struct soap *soap, xsd__nonNegativeInteger_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__nonNegativeInteger_ * SOAP_FMAC6 soap_instantiate_xsd__nonNegativeInteger_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__nonNegativeInteger_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__nonNegativeInteger_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "xsd:positiveInteger"))
	{	cp->type = SOAP_TYPE_xsd__positiveInteger_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__positiveInteger_;
			if (size)
				*size = sizeof(xsd__positiveInteger_);
		}
		else
		{	cp->ptr = (void*)new xsd__positiveInteger_[n];
			if (size)
				*size = n * sizeof(xsd__positiveInteger_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__positiveInteger_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedLong"))
	{	cp->type = SOAP_TYPE_xsd__unsignedLong_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedLong_;
			if (size)
				*size = sizeof(xsd__unsignedLong_);
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedLong_[n];
			if (size)
				*size = n * sizeof(xsd__unsignedLong_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedLong_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedInt"))
	{	cp->type = SOAP_TYPE_xsd__unsignedInt_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedInt_;
			if (size)
				*size = sizeof(xsd__unsignedInt_);
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedInt_[n];
			if (size)
				*size = n * sizeof(xsd__unsignedInt_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedInt_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedShort"))
	{	cp->type = SOAP_TYPE_xsd__unsignedShort_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedShort_;
			if (size)
				*size = sizeof(xsd__unsignedShort_);
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedShort_[n];
			if (size)
				*size = n * sizeof(xsd__unsignedShort_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedShort_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedByte"))
	{	cp->type = SOAP_TYPE_xsd__unsignedByte_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedByte_;
			if (size)
				*size = sizeof(xsd__unsignedByte_);
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedByte_[n];
			if (size)
				*size = n * sizeof(xsd__unsignedByte_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedByte_*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new xsd__nonNegativeInteger_;
		if (size)
			*size = sizeof(xsd__nonNegativeInteger_);
	}
	else
	{	cp->ptr = (void*)new xsd__nonNegativeInteger_[n];
		if (size)
			*size = n * sizeof(xsd__nonNegativeInteger_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__nonNegativeInteger_*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__nonNegativeInteger_(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__nonNegativeInteger_ %p -> %p\n", q, p));
	*(xsd__nonNegativeInteger_*)p = *(xsd__nonNegativeInteger_*)q;
}

void xsd__negativeInteger_::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__negativeInteger_::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((xsd__negativeInteger_*)this)->__item, SOAP_TYPE_xsd__negativeInteger);
	soap_mark_xsd__negativeInteger(soap, &((xsd__negativeInteger_*)this)->__item);
	soap_embedded(soap, &((xsd__nonPositiveInteger_*)this)->__item, SOAP_TYPE_xsd__nonPositiveInteger);
	soap_mark_xsd__nonPositiveInteger(soap, &((xsd__nonPositiveInteger_*)this)->__item);
	soap_embedded(soap, &((xsd__integer_*)this)->__item, SOAP_TYPE_xsd__integer);
	soap_mark_xsd__integer(soap, &((xsd__integer_*)this)->__item);
	soap_embedded(soap, &((xsd__decimal_*)this)->__item, SOAP_TYPE_xsd__decimal);
	soap_mark_xsd__decimal(soap, &((xsd__decimal_*)this)->__item);
}

void xsd__negativeInteger_::soap_default(struct soap *soap)
{
	((xsd__negativeInteger_*)this)->__item = NULL;
	((xsd__nonPositiveInteger_*)this)->__item = NULL;
	((xsd__integer_*)this)->__item = NULL;
	((xsd__decimal_*)this)->__item = NULL;
}

int xsd__negativeInteger_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__negativeInteger_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__negativeInteger_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__negativeInteger_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__negativeInteger_(struct soap *soap, const char *tag, int id, const xsd__negativeInteger_ *a, const char *type)
{
	soap_out_xsd__negativeInteger(soap, tag, id, &(((xsd__negativeInteger_*)a)->__item), "xsd:negativeInteger");
	return SOAP_OK;
}

void *xsd__negativeInteger_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__negativeInteger_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__negativeInteger_ * SOAP_FMAC4 soap_get_xsd__negativeInteger_(struct soap *soap, xsd__negativeInteger_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__negativeInteger_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__negativeInteger_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__negativeInteger_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__negativeInteger_ * SOAP_FMAC4 soap_in_xsd__negativeInteger_(struct soap *soap, const char *tag, xsd__negativeInteger_ *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (xsd__negativeInteger_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__negativeInteger_, sizeof(xsd__negativeInteger_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__negativeInteger_)
			return (xsd__negativeInteger_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__negativeInteger(soap, tag, &(((xsd__negativeInteger_*)a)->__item), "xsd:negativeInteger"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__negativeInteger_ * SOAP_FMAC6 soap_new_xsd__negativeInteger_(struct soap *soap, int n)
{	return soap_instantiate_xsd__negativeInteger_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__negativeInteger_(struct soap *soap, xsd__negativeInteger_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__negativeInteger_ * SOAP_FMAC6 soap_instantiate_xsd__negativeInteger_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__negativeInteger_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__negativeInteger_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__negativeInteger_;
		if (size)
			*size = sizeof(xsd__negativeInteger_);
	}
	else
	{	cp->ptr = (void*)new xsd__negativeInteger_[n];
		if (size)
			*size = n * sizeof(xsd__negativeInteger_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__negativeInteger_*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__negativeInteger_(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__negativeInteger_ %p -> %p\n", q, p));
	*(xsd__negativeInteger_*)p = *(xsd__negativeInteger_*)q;
}

void xsd__nonPositiveInteger_::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__nonPositiveInteger_::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((xsd__nonPositiveInteger_*)this)->__item, SOAP_TYPE_xsd__nonPositiveInteger);
	soap_mark_xsd__nonPositiveInteger(soap, &((xsd__nonPositiveInteger_*)this)->__item);
	soap_embedded(soap, &((xsd__integer_*)this)->__item, SOAP_TYPE_xsd__integer);
	soap_mark_xsd__integer(soap, &((xsd__integer_*)this)->__item);
	soap_embedded(soap, &((xsd__decimal_*)this)->__item, SOAP_TYPE_xsd__decimal);
	soap_mark_xsd__decimal(soap, &((xsd__decimal_*)this)->__item);
}

void xsd__nonPositiveInteger_::soap_default(struct soap *soap)
{
	((xsd__nonPositiveInteger_*)this)->__item = NULL;
	((xsd__integer_*)this)->__item = NULL;
	((xsd__decimal_*)this)->__item = NULL;
}

int xsd__nonPositiveInteger_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__nonPositiveInteger_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__nonPositiveInteger_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__nonPositiveInteger_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__nonPositiveInteger_(struct soap *soap, const char *tag, int id, const xsd__nonPositiveInteger_ *a, const char *type)
{
	soap_out_xsd__nonPositiveInteger(soap, tag, id, &(((xsd__nonPositiveInteger_*)a)->__item), "xsd:nonPositiveInteger");
	return SOAP_OK;
}

void *xsd__nonPositiveInteger_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__nonPositiveInteger_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__nonPositiveInteger_ * SOAP_FMAC4 soap_get_xsd__nonPositiveInteger_(struct soap *soap, xsd__nonPositiveInteger_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__nonPositiveInteger_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__nonPositiveInteger_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__nonPositiveInteger_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__nonPositiveInteger_ * SOAP_FMAC4 soap_in_xsd__nonPositiveInteger_(struct soap *soap, const char *tag, xsd__nonPositiveInteger_ *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (xsd__nonPositiveInteger_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__nonPositiveInteger_, sizeof(xsd__nonPositiveInteger_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__nonPositiveInteger_)
			return (xsd__nonPositiveInteger_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__nonPositiveInteger(soap, tag, &(((xsd__nonPositiveInteger_*)a)->__item), "xsd:nonPositiveInteger"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__nonPositiveInteger_ * SOAP_FMAC6 soap_new_xsd__nonPositiveInteger_(struct soap *soap, int n)
{	return soap_instantiate_xsd__nonPositiveInteger_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__nonPositiveInteger_(struct soap *soap, xsd__nonPositiveInteger_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__nonPositiveInteger_ * SOAP_FMAC6 soap_instantiate_xsd__nonPositiveInteger_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__nonPositiveInteger_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__nonPositiveInteger_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "xsd:negativeInteger"))
	{	cp->type = SOAP_TYPE_xsd__negativeInteger_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__negativeInteger_;
			if (size)
				*size = sizeof(xsd__negativeInteger_);
		}
		else
		{	cp->ptr = (void*)new xsd__negativeInteger_[n];
			if (size)
				*size = n * sizeof(xsd__negativeInteger_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__negativeInteger_*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new xsd__nonPositiveInteger_;
		if (size)
			*size = sizeof(xsd__nonPositiveInteger_);
	}
	else
	{	cp->ptr = (void*)new xsd__nonPositiveInteger_[n];
		if (size)
			*size = n * sizeof(xsd__nonPositiveInteger_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__nonPositiveInteger_*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__nonPositiveInteger_(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__nonPositiveInteger_ %p -> %p\n", q, p));
	*(xsd__nonPositiveInteger_*)p = *(xsd__nonPositiveInteger_*)q;
}

void xsd__byte_::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__byte_::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((xsd__byte_*)this)->__item, SOAP_TYPE_xsd__byte);
	soap_embedded(soap, &((xsd__short_*)this)->__item, SOAP_TYPE_xsd__short);
	soap_embedded(soap, &((xsd__int_*)this)->__item, SOAP_TYPE_xsd__int);
	soap_embedded(soap, &((xsd__long_*)this)->__item, SOAP_TYPE_xsd__long);
	soap_embedded(soap, &((xsd__integer_*)this)->__item, SOAP_TYPE_xsd__integer);
	soap_mark_xsd__integer(soap, &((xsd__integer_*)this)->__item);
	soap_embedded(soap, &((xsd__decimal_*)this)->__item, SOAP_TYPE_xsd__decimal);
	soap_mark_xsd__decimal(soap, &((xsd__decimal_*)this)->__item);
}

void xsd__byte_::soap_default(struct soap *soap)
{
	soap_default_xsd__byte(soap, &((xsd__byte_*)this)->__item);
	soap_default_xsd__short(soap, &((xsd__short_*)this)->__item);
	soap_default_xsd__int(soap, &((xsd__int_*)this)->__item);
	soap_default_xsd__long(soap, &((xsd__long_*)this)->__item);
	((xsd__integer_*)this)->__item = NULL;
	((xsd__decimal_*)this)->__item = NULL;
}

int xsd__byte_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__byte_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__byte_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__byte_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__byte_(struct soap *soap, const char *tag, int id, const xsd__byte_ *a, const char *type)
{
	soap_out_xsd__byte(soap, tag, id, &(((xsd__byte_*)a)->__item), "xsd:byte");
	return SOAP_OK;
}

void *xsd__byte_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__byte_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__byte_ * SOAP_FMAC4 soap_get_xsd__byte_(struct soap *soap, xsd__byte_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__byte_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__byte_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__byte_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__byte_ * SOAP_FMAC4 soap_in_xsd__byte_(struct soap *soap, const char *tag, xsd__byte_ *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (xsd__byte_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__byte_, sizeof(xsd__byte_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__byte_)
			return (xsd__byte_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__byte(soap, tag, &(((xsd__byte_*)a)->__item), "xsd:byte"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__byte_ * SOAP_FMAC6 soap_new_xsd__byte_(struct soap *soap, int n)
{	return soap_instantiate_xsd__byte_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__byte_(struct soap *soap, xsd__byte_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__byte_ * SOAP_FMAC6 soap_instantiate_xsd__byte_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__byte_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__byte_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__byte_;
		if (size)
			*size = sizeof(xsd__byte_);
	}
	else
	{	cp->ptr = (void*)new xsd__byte_[n];
		if (size)
			*size = n * sizeof(xsd__byte_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__byte_*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__byte_(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__byte_ %p -> %p\n", q, p));
	*(xsd__byte_*)p = *(xsd__byte_*)q;
}

void xsd__short_::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__short_::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((xsd__short_*)this)->__item, SOAP_TYPE_xsd__short);
	soap_embedded(soap, &((xsd__int_*)this)->__item, SOAP_TYPE_xsd__int);
	soap_embedded(soap, &((xsd__long_*)this)->__item, SOAP_TYPE_xsd__long);
	soap_embedded(soap, &((xsd__integer_*)this)->__item, SOAP_TYPE_xsd__integer);
	soap_mark_xsd__integer(soap, &((xsd__integer_*)this)->__item);
	soap_embedded(soap, &((xsd__decimal_*)this)->__item, SOAP_TYPE_xsd__decimal);
	soap_mark_xsd__decimal(soap, &((xsd__decimal_*)this)->__item);
}

void xsd__short_::soap_default(struct soap *soap)
{
	soap_default_xsd__short(soap, &((xsd__short_*)this)->__item);
	soap_default_xsd__int(soap, &((xsd__int_*)this)->__item);
	soap_default_xsd__long(soap, &((xsd__long_*)this)->__item);
	((xsd__integer_*)this)->__item = NULL;
	((xsd__decimal_*)this)->__item = NULL;
}

int xsd__short_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__short_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__short_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__short_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__short_(struct soap *soap, const char *tag, int id, const xsd__short_ *a, const char *type)
{
	soap_out_xsd__short(soap, tag, id, &(((xsd__short_*)a)->__item), "xsd:short");
	return SOAP_OK;
}

void *xsd__short_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__short_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__short_ * SOAP_FMAC4 soap_get_xsd__short_(struct soap *soap, xsd__short_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__short_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__short_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__short_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__short_ * SOAP_FMAC4 soap_in_xsd__short_(struct soap *soap, const char *tag, xsd__short_ *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (xsd__short_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__short_, sizeof(xsd__short_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__short_)
			return (xsd__short_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__short(soap, tag, &(((xsd__short_*)a)->__item), "xsd:short"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__short_ * SOAP_FMAC6 soap_new_xsd__short_(struct soap *soap, int n)
{	return soap_instantiate_xsd__short_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__short_(struct soap *soap, xsd__short_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__short_ * SOAP_FMAC6 soap_instantiate_xsd__short_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__short_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__short_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "xsd:byte"))
	{	cp->type = SOAP_TYPE_xsd__byte_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__byte_;
			if (size)
				*size = sizeof(xsd__byte_);
		}
		else
		{	cp->ptr = (void*)new xsd__byte_[n];
			if (size)
				*size = n * sizeof(xsd__byte_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__byte_*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new xsd__short_;
		if (size)
			*size = sizeof(xsd__short_);
	}
	else
	{	cp->ptr = (void*)new xsd__short_[n];
		if (size)
			*size = n * sizeof(xsd__short_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__short_*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__short_(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__short_ %p -> %p\n", q, p));
	*(xsd__short_*)p = *(xsd__short_*)q;
}

void xsd__int_::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__int_::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((xsd__int_*)this)->__item, SOAP_TYPE_xsd__int);
	soap_embedded(soap, &((xsd__long_*)this)->__item, SOAP_TYPE_xsd__long);
	soap_embedded(soap, &((xsd__integer_*)this)->__item, SOAP_TYPE_xsd__integer);
	soap_mark_xsd__integer(soap, &((xsd__integer_*)this)->__item);
	soap_embedded(soap, &((xsd__decimal_*)this)->__item, SOAP_TYPE_xsd__decimal);
	soap_mark_xsd__decimal(soap, &((xsd__decimal_*)this)->__item);
}

void xsd__int_::soap_default(struct soap *soap)
{
	soap_default_xsd__int(soap, &((xsd__int_*)this)->__item);
	soap_default_xsd__long(soap, &((xsd__long_*)this)->__item);
	((xsd__integer_*)this)->__item = NULL;
	((xsd__decimal_*)this)->__item = NULL;
}

int xsd__int_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__int_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__int_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__int_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__int_(struct soap *soap, const char *tag, int id, const xsd__int_ *a, const char *type)
{
	soap_out_xsd__int(soap, tag, id, &(((xsd__int_*)a)->__item), "xsd:int");
	return SOAP_OK;
}

void *xsd__int_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__int_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__int_ * SOAP_FMAC4 soap_get_xsd__int_(struct soap *soap, xsd__int_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__int_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__int_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__int_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__int_ * SOAP_FMAC4 soap_in_xsd__int_(struct soap *soap, const char *tag, xsd__int_ *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (xsd__int_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__int_, sizeof(xsd__int_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__int_)
			return (xsd__int_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__int(soap, tag, &(((xsd__int_*)a)->__item), "xsd:int"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__int_ * SOAP_FMAC6 soap_new_xsd__int_(struct soap *soap, int n)
{	return soap_instantiate_xsd__int_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__int_(struct soap *soap, xsd__int_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__int_ * SOAP_FMAC6 soap_instantiate_xsd__int_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__int_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__int_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "xsd:short"))
	{	cp->type = SOAP_TYPE_xsd__short_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__short_;
			if (size)
				*size = sizeof(xsd__short_);
		}
		else
		{	cp->ptr = (void*)new xsd__short_[n];
			if (size)
				*size = n * sizeof(xsd__short_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__short_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:byte"))
	{	cp->type = SOAP_TYPE_xsd__byte_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__byte_;
			if (size)
				*size = sizeof(xsd__byte_);
		}
		else
		{	cp->ptr = (void*)new xsd__byte_[n];
			if (size)
				*size = n * sizeof(xsd__byte_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__byte_*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new xsd__int_;
		if (size)
			*size = sizeof(xsd__int_);
	}
	else
	{	cp->ptr = (void*)new xsd__int_[n];
		if (size)
			*size = n * sizeof(xsd__int_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__int_*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__int_(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__int_ %p -> %p\n", q, p));
	*(xsd__int_*)p = *(xsd__int_*)q;
}

void xsd__long_::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__long_::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((xsd__long_*)this)->__item, SOAP_TYPE_xsd__long);
	soap_embedded(soap, &((xsd__integer_*)this)->__item, SOAP_TYPE_xsd__integer);
	soap_mark_xsd__integer(soap, &((xsd__integer_*)this)->__item);
	soap_embedded(soap, &((xsd__decimal_*)this)->__item, SOAP_TYPE_xsd__decimal);
	soap_mark_xsd__decimal(soap, &((xsd__decimal_*)this)->__item);
}

void xsd__long_::soap_default(struct soap *soap)
{
	soap_default_xsd__long(soap, &((xsd__long_*)this)->__item);
	((xsd__integer_*)this)->__item = NULL;
	((xsd__decimal_*)this)->__item = NULL;
}

int xsd__long_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__long_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__long_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__long_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__long_(struct soap *soap, const char *tag, int id, const xsd__long_ *a, const char *type)
{
	soap_out_xsd__long(soap, tag, id, &(((xsd__long_*)a)->__item), "xsd:long");
	return SOAP_OK;
}

void *xsd__long_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__long_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__long_ * SOAP_FMAC4 soap_get_xsd__long_(struct soap *soap, xsd__long_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__long_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__long_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__long_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__long_ * SOAP_FMAC4 soap_in_xsd__long_(struct soap *soap, const char *tag, xsd__long_ *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (xsd__long_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__long_, sizeof(xsd__long_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__long_)
			return (xsd__long_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__long(soap, tag, &(((xsd__long_*)a)->__item), "xsd:long"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__long_ * SOAP_FMAC6 soap_new_xsd__long_(struct soap *soap, int n)
{	return soap_instantiate_xsd__long_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__long_(struct soap *soap, xsd__long_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__long_ * SOAP_FMAC6 soap_instantiate_xsd__long_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__long_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__long_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "xsd:int"))
	{	cp->type = SOAP_TYPE_xsd__int_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__int_;
			if (size)
				*size = sizeof(xsd__int_);
		}
		else
		{	cp->ptr = (void*)new xsd__int_[n];
			if (size)
				*size = n * sizeof(xsd__int_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__int_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:short"))
	{	cp->type = SOAP_TYPE_xsd__short_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__short_;
			if (size)
				*size = sizeof(xsd__short_);
		}
		else
		{	cp->ptr = (void*)new xsd__short_[n];
			if (size)
				*size = n * sizeof(xsd__short_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__short_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:byte"))
	{	cp->type = SOAP_TYPE_xsd__byte_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__byte_;
			if (size)
				*size = sizeof(xsd__byte_);
		}
		else
		{	cp->ptr = (void*)new xsd__byte_[n];
			if (size)
				*size = n * sizeof(xsd__byte_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__byte_*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new xsd__long_;
		if (size)
			*size = sizeof(xsd__long_);
	}
	else
	{	cp->ptr = (void*)new xsd__long_[n];
		if (size)
			*size = n * sizeof(xsd__long_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__long_*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__long_(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__long_ %p -> %p\n", q, p));
	*(xsd__long_*)p = *(xsd__long_*)q;
}

void xsd__integer_::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__integer_::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((xsd__integer_*)this)->__item, SOAP_TYPE_xsd__integer);
	soap_mark_xsd__integer(soap, &((xsd__integer_*)this)->__item);
	soap_embedded(soap, &((xsd__decimal_*)this)->__item, SOAP_TYPE_xsd__decimal);
	soap_mark_xsd__decimal(soap, &((xsd__decimal_*)this)->__item);
}

void xsd__integer_::soap_default(struct soap *soap)
{
	((xsd__integer_*)this)->__item = NULL;
	((xsd__decimal_*)this)->__item = NULL;
}

int xsd__integer_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__integer_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__integer_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__integer_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__integer_(struct soap *soap, const char *tag, int id, const xsd__integer_ *a, const char *type)
{
	soap_out_xsd__integer(soap, tag, id, &(((xsd__integer_*)a)->__item), "xsd:integer");
	return SOAP_OK;
}

void *xsd__integer_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__integer_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__integer_ * SOAP_FMAC4 soap_get_xsd__integer_(struct soap *soap, xsd__integer_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__integer_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__integer_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__integer_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__integer_ * SOAP_FMAC4 soap_in_xsd__integer_(struct soap *soap, const char *tag, xsd__integer_ *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (xsd__integer_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__integer_, sizeof(xsd__integer_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__integer_)
			return (xsd__integer_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__integer(soap, tag, &(((xsd__integer_*)a)->__item), "xsd:integer"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__integer_ * SOAP_FMAC6 soap_new_xsd__integer_(struct soap *soap, int n)
{	return soap_instantiate_xsd__integer_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__integer_(struct soap *soap, xsd__integer_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__integer_ * SOAP_FMAC6 soap_instantiate_xsd__integer_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__integer_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__integer_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "xsd:long"))
	{	cp->type = SOAP_TYPE_xsd__long_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__long_;
			if (size)
				*size = sizeof(xsd__long_);
		}
		else
		{	cp->ptr = (void*)new xsd__long_[n];
			if (size)
				*size = n * sizeof(xsd__long_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__long_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:int"))
	{	cp->type = SOAP_TYPE_xsd__int_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__int_;
			if (size)
				*size = sizeof(xsd__int_);
		}
		else
		{	cp->ptr = (void*)new xsd__int_[n];
			if (size)
				*size = n * sizeof(xsd__int_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__int_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:short"))
	{	cp->type = SOAP_TYPE_xsd__short_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__short_;
			if (size)
				*size = sizeof(xsd__short_);
		}
		else
		{	cp->ptr = (void*)new xsd__short_[n];
			if (size)
				*size = n * sizeof(xsd__short_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__short_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:byte"))
	{	cp->type = SOAP_TYPE_xsd__byte_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__byte_;
			if (size)
				*size = sizeof(xsd__byte_);
		}
		else
		{	cp->ptr = (void*)new xsd__byte_[n];
			if (size)
				*size = n * sizeof(xsd__byte_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__byte_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:nonPositiveInteger"))
	{	cp->type = SOAP_TYPE_xsd__nonPositiveInteger_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__nonPositiveInteger_;
			if (size)
				*size = sizeof(xsd__nonPositiveInteger_);
		}
		else
		{	cp->ptr = (void*)new xsd__nonPositiveInteger_[n];
			if (size)
				*size = n * sizeof(xsd__nonPositiveInteger_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__nonPositiveInteger_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:negativeInteger"))
	{	cp->type = SOAP_TYPE_xsd__negativeInteger_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__negativeInteger_;
			if (size)
				*size = sizeof(xsd__negativeInteger_);
		}
		else
		{	cp->ptr = (void*)new xsd__negativeInteger_[n];
			if (size)
				*size = n * sizeof(xsd__negativeInteger_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__negativeInteger_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:nonNegativeInteger"))
	{	cp->type = SOAP_TYPE_xsd__nonNegativeInteger_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__nonNegativeInteger_;
			if (size)
				*size = sizeof(xsd__nonNegativeInteger_);
		}
		else
		{	cp->ptr = (void*)new xsd__nonNegativeInteger_[n];
			if (size)
				*size = n * sizeof(xsd__nonNegativeInteger_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__nonNegativeInteger_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:positiveInteger"))
	{	cp->type = SOAP_TYPE_xsd__positiveInteger_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__positiveInteger_;
			if (size)
				*size = sizeof(xsd__positiveInteger_);
		}
		else
		{	cp->ptr = (void*)new xsd__positiveInteger_[n];
			if (size)
				*size = n * sizeof(xsd__positiveInteger_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__positiveInteger_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedLong"))
	{	cp->type = SOAP_TYPE_xsd__unsignedLong_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedLong_;
			if (size)
				*size = sizeof(xsd__unsignedLong_);
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedLong_[n];
			if (size)
				*size = n * sizeof(xsd__unsignedLong_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedLong_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedInt"))
	{	cp->type = SOAP_TYPE_xsd__unsignedInt_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedInt_;
			if (size)
				*size = sizeof(xsd__unsignedInt_);
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedInt_[n];
			if (size)
				*size = n * sizeof(xsd__unsignedInt_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedInt_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedShort"))
	{	cp->type = SOAP_TYPE_xsd__unsignedShort_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedShort_;
			if (size)
				*size = sizeof(xsd__unsignedShort_);
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedShort_[n];
			if (size)
				*size = n * sizeof(xsd__unsignedShort_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedShort_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedByte"))
	{	cp->type = SOAP_TYPE_xsd__unsignedByte_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedByte_;
			if (size)
				*size = sizeof(xsd__unsignedByte_);
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedByte_[n];
			if (size)
				*size = n * sizeof(xsd__unsignedByte_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedByte_*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new xsd__integer_;
		if (size)
			*size = sizeof(xsd__integer_);
	}
	else
	{	cp->ptr = (void*)new xsd__integer_[n];
		if (size)
			*size = n * sizeof(xsd__integer_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__integer_*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__integer_(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__integer_ %p -> %p\n", q, p));
	*(xsd__integer_*)p = *(xsd__integer_*)q;
}

void xsd__decimal_::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__decimal_::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((xsd__decimal_*)this)->__item, SOAP_TYPE_xsd__decimal);
	soap_mark_xsd__decimal(soap, &((xsd__decimal_*)this)->__item);
}

void xsd__decimal_::soap_default(struct soap *soap)
{
	((xsd__decimal_*)this)->__item = NULL;
}

int xsd__decimal_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__decimal_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__decimal_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__decimal_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__decimal_(struct soap *soap, const char *tag, int id, const xsd__decimal_ *a, const char *type)
{
	soap_out_xsd__decimal(soap, tag, id, &(((xsd__decimal_*)a)->__item), "xsd:decimal");
	return SOAP_OK;
}

void *xsd__decimal_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__decimal_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__decimal_ * SOAP_FMAC4 soap_get_xsd__decimal_(struct soap *soap, xsd__decimal_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__decimal_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__decimal_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__decimal_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__decimal_ * SOAP_FMAC4 soap_in_xsd__decimal_(struct soap *soap, const char *tag, xsd__decimal_ *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (xsd__decimal_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__decimal_, sizeof(xsd__decimal_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__decimal_)
			return (xsd__decimal_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__decimal(soap, tag, &(((xsd__decimal_*)a)->__item), "xsd:decimal"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__decimal_ * SOAP_FMAC6 soap_new_xsd__decimal_(struct soap *soap, int n)
{	return soap_instantiate_xsd__decimal_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__decimal_(struct soap *soap, xsd__decimal_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__decimal_ * SOAP_FMAC6 soap_instantiate_xsd__decimal_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__decimal_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__decimal_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "xsd:integer"))
	{	cp->type = SOAP_TYPE_xsd__integer_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__integer_;
			if (size)
				*size = sizeof(xsd__integer_);
		}
		else
		{	cp->ptr = (void*)new xsd__integer_[n];
			if (size)
				*size = n * sizeof(xsd__integer_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__integer_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:long"))
	{	cp->type = SOAP_TYPE_xsd__long_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__long_;
			if (size)
				*size = sizeof(xsd__long_);
		}
		else
		{	cp->ptr = (void*)new xsd__long_[n];
			if (size)
				*size = n * sizeof(xsd__long_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__long_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:int"))
	{	cp->type = SOAP_TYPE_xsd__int_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__int_;
			if (size)
				*size = sizeof(xsd__int_);
		}
		else
		{	cp->ptr = (void*)new xsd__int_[n];
			if (size)
				*size = n * sizeof(xsd__int_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__int_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:short"))
	{	cp->type = SOAP_TYPE_xsd__short_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__short_;
			if (size)
				*size = sizeof(xsd__short_);
		}
		else
		{	cp->ptr = (void*)new xsd__short_[n];
			if (size)
				*size = n * sizeof(xsd__short_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__short_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:byte"))
	{	cp->type = SOAP_TYPE_xsd__byte_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__byte_;
			if (size)
				*size = sizeof(xsd__byte_);
		}
		else
		{	cp->ptr = (void*)new xsd__byte_[n];
			if (size)
				*size = n * sizeof(xsd__byte_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__byte_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:nonPositiveInteger"))
	{	cp->type = SOAP_TYPE_xsd__nonPositiveInteger_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__nonPositiveInteger_;
			if (size)
				*size = sizeof(xsd__nonPositiveInteger_);
		}
		else
		{	cp->ptr = (void*)new xsd__nonPositiveInteger_[n];
			if (size)
				*size = n * sizeof(xsd__nonPositiveInteger_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__nonPositiveInteger_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:negativeInteger"))
	{	cp->type = SOAP_TYPE_xsd__negativeInteger_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__negativeInteger_;
			if (size)
				*size = sizeof(xsd__negativeInteger_);
		}
		else
		{	cp->ptr = (void*)new xsd__negativeInteger_[n];
			if (size)
				*size = n * sizeof(xsd__negativeInteger_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__negativeInteger_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:nonNegativeInteger"))
	{	cp->type = SOAP_TYPE_xsd__nonNegativeInteger_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__nonNegativeInteger_;
			if (size)
				*size = sizeof(xsd__nonNegativeInteger_);
		}
		else
		{	cp->ptr = (void*)new xsd__nonNegativeInteger_[n];
			if (size)
				*size = n * sizeof(xsd__nonNegativeInteger_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__nonNegativeInteger_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:positiveInteger"))
	{	cp->type = SOAP_TYPE_xsd__positiveInteger_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__positiveInteger_;
			if (size)
				*size = sizeof(xsd__positiveInteger_);
		}
		else
		{	cp->ptr = (void*)new xsd__positiveInteger_[n];
			if (size)
				*size = n * sizeof(xsd__positiveInteger_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__positiveInteger_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedLong"))
	{	cp->type = SOAP_TYPE_xsd__unsignedLong_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedLong_;
			if (size)
				*size = sizeof(xsd__unsignedLong_);
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedLong_[n];
			if (size)
				*size = n * sizeof(xsd__unsignedLong_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedLong_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedInt"))
	{	cp->type = SOAP_TYPE_xsd__unsignedInt_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedInt_;
			if (size)
				*size = sizeof(xsd__unsignedInt_);
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedInt_[n];
			if (size)
				*size = n * sizeof(xsd__unsignedInt_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedInt_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedShort"))
	{	cp->type = SOAP_TYPE_xsd__unsignedShort_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedShort_;
			if (size)
				*size = sizeof(xsd__unsignedShort_);
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedShort_[n];
			if (size)
				*size = n * sizeof(xsd__unsignedShort_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedShort_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedByte"))
	{	cp->type = SOAP_TYPE_xsd__unsignedByte_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedByte_;
			if (size)
				*size = sizeof(xsd__unsignedByte_);
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedByte_[n];
			if (size)
				*size = n * sizeof(xsd__unsignedByte_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedByte_*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new xsd__decimal_;
		if (size)
			*size = sizeof(xsd__decimal_);
	}
	else
	{	cp->ptr = (void*)new xsd__decimal_[n];
		if (size)
			*size = n * sizeof(xsd__decimal_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__decimal_*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__decimal_(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__decimal_ %p -> %p\n", q, p));
	*(xsd__decimal_*)p = *(xsd__decimal_*)q;
}

void xsd__time_::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__time_::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((xsd__time_*)this)->__item, SOAP_TYPE_xsd__time);
	soap_mark_xsd__time(soap, &((xsd__time_*)this)->__item);
}

void xsd__time_::soap_default(struct soap *soap)
{
	((xsd__time_*)this)->__item = NULL;
}

int xsd__time_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__time_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__time_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__time_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__time_(struct soap *soap, const char *tag, int id, const xsd__time_ *a, const char *type)
{
	soap_out_xsd__time(soap, tag, id, &(((xsd__time_*)a)->__item), "xsd:time");
	return SOAP_OK;
}

void *xsd__time_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__time_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__time_ * SOAP_FMAC4 soap_get_xsd__time_(struct soap *soap, xsd__time_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__time_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__time_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__time_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__time_ * SOAP_FMAC4 soap_in_xsd__time_(struct soap *soap, const char *tag, xsd__time_ *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (xsd__time_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__time_, sizeof(xsd__time_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__time_)
			return (xsd__time_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__time(soap, tag, &(((xsd__time_*)a)->__item), "xsd:time"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__time_ * SOAP_FMAC6 soap_new_xsd__time_(struct soap *soap, int n)
{	return soap_instantiate_xsd__time_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__time_(struct soap *soap, xsd__time_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__time_ * SOAP_FMAC6 soap_instantiate_xsd__time_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__time_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__time_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__time_;
		if (size)
			*size = sizeof(xsd__time_);
	}
	else
	{	cp->ptr = (void*)new xsd__time_[n];
		if (size)
			*size = n * sizeof(xsd__time_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__time_*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__time_(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__time_ %p -> %p\n", q, p));
	*(xsd__time_*)p = *(xsd__time_*)q;
}

void xsd__float_::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__float_::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((xsd__float_*)this)->__item, SOAP_TYPE_xsd__float);
}

void xsd__float_::soap_default(struct soap *soap)
{
	soap_default_xsd__float(soap, &((xsd__float_*)this)->__item);
}

int xsd__float_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__float_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__float_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__float_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__float_(struct soap *soap, const char *tag, int id, const xsd__float_ *a, const char *type)
{
	soap_out_xsd__float(soap, tag, id, &(((xsd__float_*)a)->__item), "xsd:float");
	return SOAP_OK;
}

void *xsd__float_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__float_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__float_ * SOAP_FMAC4 soap_get_xsd__float_(struct soap *soap, xsd__float_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__float_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__float_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__float_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__float_ * SOAP_FMAC4 soap_in_xsd__float_(struct soap *soap, const char *tag, xsd__float_ *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (xsd__float_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__float_, sizeof(xsd__float_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__float_)
			return (xsd__float_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__float(soap, tag, &(((xsd__float_*)a)->__item), "xsd:float"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__float_ * SOAP_FMAC6 soap_new_xsd__float_(struct soap *soap, int n)
{	return soap_instantiate_xsd__float_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__float_(struct soap *soap, xsd__float_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__float_ * SOAP_FMAC6 soap_instantiate_xsd__float_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__float_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__float_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__float_;
		if (size)
			*size = sizeof(xsd__float_);
	}
	else
	{	cp->ptr = (void*)new xsd__float_[n];
		if (size)
			*size = n * sizeof(xsd__float_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__float_*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__float_(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__float_ %p -> %p\n", q, p));
	*(xsd__float_*)p = *(xsd__float_*)q;
}

void xsd__duration_::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__duration_::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((xsd__duration_*)this)->__item, SOAP_TYPE_xsd__duration);
	soap_mark_xsd__duration(soap, &((xsd__duration_*)this)->__item);
}

void xsd__duration_::soap_default(struct soap *soap)
{
	((xsd__duration_*)this)->__item = NULL;
}

int xsd__duration_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__duration_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__duration_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__duration_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__duration_(struct soap *soap, const char *tag, int id, const xsd__duration_ *a, const char *type)
{
	soap_out_xsd__duration(soap, tag, id, &(((xsd__duration_*)a)->__item), "xsd:duration");
	return SOAP_OK;
}

void *xsd__duration_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__duration_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__duration_ * SOAP_FMAC4 soap_get_xsd__duration_(struct soap *soap, xsd__duration_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__duration_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__duration_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__duration_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__duration_ * SOAP_FMAC4 soap_in_xsd__duration_(struct soap *soap, const char *tag, xsd__duration_ *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (xsd__duration_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__duration_, sizeof(xsd__duration_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__duration_)
			return (xsd__duration_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__duration(soap, tag, &(((xsd__duration_*)a)->__item), "xsd:duration"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__duration_ * SOAP_FMAC6 soap_new_xsd__duration_(struct soap *soap, int n)
{	return soap_instantiate_xsd__duration_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__duration_(struct soap *soap, xsd__duration_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__duration_ * SOAP_FMAC6 soap_instantiate_xsd__duration_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__duration_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__duration_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__duration_;
		if (size)
			*size = sizeof(xsd__duration_);
	}
	else
	{	cp->ptr = (void*)new xsd__duration_[n];
		if (size)
			*size = n * sizeof(xsd__duration_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__duration_*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__duration_(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__duration_ %p -> %p\n", q, p));
	*(xsd__duration_*)p = *(xsd__duration_*)q;
}

void xsd__double_::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__double_::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((xsd__double_*)this)->__item, SOAP_TYPE_xsd__double);
}

void xsd__double_::soap_default(struct soap *soap)
{
	soap_default_xsd__double(soap, &((xsd__double_*)this)->__item);
}

int xsd__double_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__double_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__double_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__double_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__double_(struct soap *soap, const char *tag, int id, const xsd__double_ *a, const char *type)
{
	soap_out_xsd__double(soap, tag, id, &(((xsd__double_*)a)->__item), "xsd:double");
	return SOAP_OK;
}

void *xsd__double_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__double_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__double_ * SOAP_FMAC4 soap_get_xsd__double_(struct soap *soap, xsd__double_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__double_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__double_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__double_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__double_ * SOAP_FMAC4 soap_in_xsd__double_(struct soap *soap, const char *tag, xsd__double_ *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (xsd__double_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__double_, sizeof(xsd__double_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__double_)
			return (xsd__double_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__double(soap, tag, &(((xsd__double_*)a)->__item), "xsd:double"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__double_ * SOAP_FMAC6 soap_new_xsd__double_(struct soap *soap, int n)
{	return soap_instantiate_xsd__double_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__double_(struct soap *soap, xsd__double_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__double_ * SOAP_FMAC6 soap_instantiate_xsd__double_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__double_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__double_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__double_;
		if (size)
			*size = sizeof(xsd__double_);
	}
	else
	{	cp->ptr = (void*)new xsd__double_[n];
		if (size)
			*size = n * sizeof(xsd__double_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__double_*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__double_(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__double_ %p -> %p\n", q, p));
	*(xsd__double_*)p = *(xsd__double_*)q;
}

void xsd__dateTime_::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__dateTime_::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((xsd__dateTime_*)this)->__item, SOAP_TYPE_xsd__dateTime);
	soap_mark_xsd__dateTime(soap, &((xsd__dateTime_*)this)->__item);
}

void xsd__dateTime_::soap_default(struct soap *soap)
{
	((xsd__dateTime_*)this)->__item = NULL;
}

int xsd__dateTime_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__dateTime_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__dateTime_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__dateTime_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__dateTime_(struct soap *soap, const char *tag, int id, const xsd__dateTime_ *a, const char *type)
{
	soap_out_xsd__dateTime(soap, tag, id, &(((xsd__dateTime_*)a)->__item), "xsd:dateTime");
	return SOAP_OK;
}

void *xsd__dateTime_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__dateTime_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__dateTime_ * SOAP_FMAC4 soap_get_xsd__dateTime_(struct soap *soap, xsd__dateTime_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__dateTime_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__dateTime_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__dateTime_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__dateTime_ * SOAP_FMAC4 soap_in_xsd__dateTime_(struct soap *soap, const char *tag, xsd__dateTime_ *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (xsd__dateTime_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__dateTime_, sizeof(xsd__dateTime_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__dateTime_)
			return (xsd__dateTime_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__dateTime(soap, tag, &(((xsd__dateTime_*)a)->__item), "xsd:dateTime"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__dateTime_ * SOAP_FMAC6 soap_new_xsd__dateTime_(struct soap *soap, int n)
{	return soap_instantiate_xsd__dateTime_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__dateTime_(struct soap *soap, xsd__dateTime_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__dateTime_ * SOAP_FMAC6 soap_instantiate_xsd__dateTime_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__dateTime_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__dateTime_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__dateTime_;
		if (size)
			*size = sizeof(xsd__dateTime_);
	}
	else
	{	cp->ptr = (void*)new xsd__dateTime_[n];
		if (size)
			*size = n * sizeof(xsd__dateTime_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__dateTime_*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__dateTime_(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__dateTime_ %p -> %p\n", q, p));
	*(xsd__dateTime_*)p = *(xsd__dateTime_*)q;
}

void xsd__date_::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__date_::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((xsd__date_*)this)->__item, SOAP_TYPE_xsd__date);
	soap_mark_xsd__date(soap, &((xsd__date_*)this)->__item);
}

void xsd__date_::soap_default(struct soap *soap)
{
	((xsd__date_*)this)->__item = NULL;
}

int xsd__date_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__date_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__date_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__date_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__date_(struct soap *soap, const char *tag, int id, const xsd__date_ *a, const char *type)
{
	soap_out_xsd__date(soap, tag, id, &(((xsd__date_*)a)->__item), "xsd:date");
	return SOAP_OK;
}

void *xsd__date_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__date_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__date_ * SOAP_FMAC4 soap_get_xsd__date_(struct soap *soap, xsd__date_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__date_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__date_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__date_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__date_ * SOAP_FMAC4 soap_in_xsd__date_(struct soap *soap, const char *tag, xsd__date_ *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (xsd__date_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__date_, sizeof(xsd__date_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__date_)
			return (xsd__date_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__date(soap, tag, &(((xsd__date_*)a)->__item), "xsd:date"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__date_ * SOAP_FMAC6 soap_new_xsd__date_(struct soap *soap, int n)
{	return soap_instantiate_xsd__date_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__date_(struct soap *soap, xsd__date_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__date_ * SOAP_FMAC6 soap_instantiate_xsd__date_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__date_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__date_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__date_;
		if (size)
			*size = sizeof(xsd__date_);
	}
	else
	{	cp->ptr = (void*)new xsd__date_[n];
		if (size)
			*size = n * sizeof(xsd__date_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__date_*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__date_(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__date_ %p -> %p\n", q, p));
	*(xsd__date_*)p = *(xsd__date_*)q;
}

void xsd__boolean_::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__boolean_::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((xsd__boolean_*)this)->__item, SOAP_TYPE_xsd__boolean);
}

void xsd__boolean_::soap_default(struct soap *soap)
{
	soap_default_xsd__boolean(soap, &((xsd__boolean_*)this)->__item);
}

int xsd__boolean_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__boolean_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__boolean_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__boolean_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__boolean_(struct soap *soap, const char *tag, int id, const xsd__boolean_ *a, const char *type)
{
	soap_out_xsd__boolean(soap, tag, id, &(((xsd__boolean_*)a)->__item), "xsd:boolean");
	return SOAP_OK;
}

void *xsd__boolean_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__boolean_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__boolean_ * SOAP_FMAC4 soap_get_xsd__boolean_(struct soap *soap, xsd__boolean_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__boolean_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__boolean_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__boolean_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__boolean_ * SOAP_FMAC4 soap_in_xsd__boolean_(struct soap *soap, const char *tag, xsd__boolean_ *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (xsd__boolean_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__boolean_, sizeof(xsd__boolean_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__boolean_)
			return (xsd__boolean_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__boolean(soap, tag, &(((xsd__boolean_*)a)->__item), "xsd:boolean"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__boolean_ * SOAP_FMAC6 soap_new_xsd__boolean_(struct soap *soap, int n)
{	return soap_instantiate_xsd__boolean_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__boolean_(struct soap *soap, xsd__boolean_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__boolean_ * SOAP_FMAC6 soap_instantiate_xsd__boolean_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__boolean_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__boolean_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__boolean_;
		if (size)
			*size = sizeof(xsd__boolean_);
	}
	else
	{	cp->ptr = (void*)new xsd__boolean_[n];
		if (size)
			*size = n * sizeof(xsd__boolean_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__boolean_*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__boolean_(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__boolean_ %p -> %p\n", q, p));
	*(xsd__boolean_*)p = *(xsd__boolean_*)q;
}

void xsd__anyURI_::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__anyURI_::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((xsd__anyURI_*)this)->__item, SOAP_TYPE_xsd__anyURI);
	soap_mark_xsd__anyURI(soap, &((xsd__anyURI_*)this)->__item);
}

void xsd__anyURI_::soap_default(struct soap *soap)
{
	((xsd__anyURI_*)this)->__item = NULL;
}

int xsd__anyURI_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__anyURI_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__anyURI_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__anyURI_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI_(struct soap *soap, const char *tag, int id, const xsd__anyURI_ *a, const char *type)
{
	soap_out_xsd__anyURI(soap, tag, id, &(((xsd__anyURI_*)a)->__item), "xsd:anyURI");
	return SOAP_OK;
}

void *xsd__anyURI_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__anyURI_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__anyURI_ * SOAP_FMAC4 soap_get_xsd__anyURI_(struct soap *soap, xsd__anyURI_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__anyURI_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__anyURI_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__anyURI_ * SOAP_FMAC4 soap_in_xsd__anyURI_(struct soap *soap, const char *tag, xsd__anyURI_ *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (xsd__anyURI_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__anyURI_, sizeof(xsd__anyURI_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__anyURI_)
			return (xsd__anyURI_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__anyURI(soap, tag, &(((xsd__anyURI_*)a)->__item), "xsd:anyURI"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__anyURI_ * SOAP_FMAC6 soap_new_xsd__anyURI_(struct soap *soap, int n)
{	return soap_instantiate_xsd__anyURI_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__anyURI_(struct soap *soap, xsd__anyURI_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__anyURI_ * SOAP_FMAC6 soap_instantiate_xsd__anyURI_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__anyURI_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__anyURI_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__anyURI_;
		if (size)
			*size = sizeof(xsd__anyURI_);
	}
	else
	{	cp->ptr = (void*)new xsd__anyURI_[n];
		if (size)
			*size = n * sizeof(xsd__anyURI_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__anyURI_*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__anyURI_(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__anyURI_ %p -> %p\n", q, p));
	*(xsd__anyURI_*)p = *(xsd__anyURI_*)q;
}

void xsd__anySimpleType::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__anySimpleType::soap_mark(struct soap *soap) const
{
}

void xsd__anySimpleType::soap_default(struct soap *soap)
{
}

int xsd__anySimpleType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__anySimpleType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__anySimpleType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__anySimpleType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anySimpleType(struct soap *soap, const char *tag, int id, const xsd__anySimpleType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xsd__anySimpleType), "xsd:anySimpleType");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *xsd__anySimpleType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__anySimpleType(soap, this, tag, type);
}

SOAP_FMAC3 xsd__anySimpleType * SOAP_FMAC4 soap_get_xsd__anySimpleType(struct soap *soap, xsd__anySimpleType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anySimpleType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__anySimpleType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__anySimpleType(soap, tag, this, type);
}

SOAP_FMAC3 xsd__anySimpleType * SOAP_FMAC4 soap_in_xsd__anySimpleType(struct soap *soap, const char *tag, xsd__anySimpleType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (xsd__anySimpleType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__anySimpleType, sizeof(xsd__anySimpleType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__anySimpleType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (xsd__anySimpleType *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (xsd__anySimpleType *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_xsd__anySimpleType, 0, sizeof(xsd__anySimpleType), 0, soap_copy_xsd__anySimpleType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 xsd__anySimpleType * SOAP_FMAC6 soap_new_xsd__anySimpleType(struct soap *soap, int n)
{	return soap_instantiate_xsd__anySimpleType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__anySimpleType(struct soap *soap, xsd__anySimpleType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__anySimpleType * SOAP_FMAC6 soap_instantiate_xsd__anySimpleType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__anySimpleType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__anySimpleType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "xsd:anyURI"))
	{	cp->type = SOAP_TYPE_xsd__anyURI_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__anyURI_;
			if (size)
				*size = sizeof(xsd__anyURI_);
		}
		else
		{	cp->ptr = (void*)new xsd__anyURI_[n];
			if (size)
				*size = n * sizeof(xsd__anyURI_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__anyURI_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:boolean"))
	{	cp->type = SOAP_TYPE_xsd__boolean_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__boolean_;
			if (size)
				*size = sizeof(xsd__boolean_);
		}
		else
		{	cp->ptr = (void*)new xsd__boolean_[n];
			if (size)
				*size = n * sizeof(xsd__boolean_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__boolean_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:date"))
	{	cp->type = SOAP_TYPE_xsd__date_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__date_;
			if (size)
				*size = sizeof(xsd__date_);
		}
		else
		{	cp->ptr = (void*)new xsd__date_[n];
			if (size)
				*size = n * sizeof(xsd__date_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__date_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:dateTime"))
	{	cp->type = SOAP_TYPE_xsd__dateTime_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__dateTime_;
			if (size)
				*size = sizeof(xsd__dateTime_);
		}
		else
		{	cp->ptr = (void*)new xsd__dateTime_[n];
			if (size)
				*size = n * sizeof(xsd__dateTime_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__dateTime_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:double"))
	{	cp->type = SOAP_TYPE_xsd__double_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__double_;
			if (size)
				*size = sizeof(xsd__double_);
		}
		else
		{	cp->ptr = (void*)new xsd__double_[n];
			if (size)
				*size = n * sizeof(xsd__double_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__double_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:duration"))
	{	cp->type = SOAP_TYPE_xsd__duration_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__duration_;
			if (size)
				*size = sizeof(xsd__duration_);
		}
		else
		{	cp->ptr = (void*)new xsd__duration_[n];
			if (size)
				*size = n * sizeof(xsd__duration_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__duration_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:float"))
	{	cp->type = SOAP_TYPE_xsd__float_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__float_;
			if (size)
				*size = sizeof(xsd__float_);
		}
		else
		{	cp->ptr = (void*)new xsd__float_[n];
			if (size)
				*size = n * sizeof(xsd__float_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__float_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:time"))
	{	cp->type = SOAP_TYPE_xsd__time_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__time_;
			if (size)
				*size = sizeof(xsd__time_);
		}
		else
		{	cp->ptr = (void*)new xsd__time_[n];
			if (size)
				*size = n * sizeof(xsd__time_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__time_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:decimal"))
	{	cp->type = SOAP_TYPE_xsd__decimal_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__decimal_;
			if (size)
				*size = sizeof(xsd__decimal_);
		}
		else
		{	cp->ptr = (void*)new xsd__decimal_[n];
			if (size)
				*size = n * sizeof(xsd__decimal_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__decimal_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:integer"))
	{	cp->type = SOAP_TYPE_xsd__integer_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__integer_;
			if (size)
				*size = sizeof(xsd__integer_);
		}
		else
		{	cp->ptr = (void*)new xsd__integer_[n];
			if (size)
				*size = n * sizeof(xsd__integer_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__integer_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:long"))
	{	cp->type = SOAP_TYPE_xsd__long_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__long_;
			if (size)
				*size = sizeof(xsd__long_);
		}
		else
		{	cp->ptr = (void*)new xsd__long_[n];
			if (size)
				*size = n * sizeof(xsd__long_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__long_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:int"))
	{	cp->type = SOAP_TYPE_xsd__int_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__int_;
			if (size)
				*size = sizeof(xsd__int_);
		}
		else
		{	cp->ptr = (void*)new xsd__int_[n];
			if (size)
				*size = n * sizeof(xsd__int_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__int_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:short"))
	{	cp->type = SOAP_TYPE_xsd__short_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__short_;
			if (size)
				*size = sizeof(xsd__short_);
		}
		else
		{	cp->ptr = (void*)new xsd__short_[n];
			if (size)
				*size = n * sizeof(xsd__short_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__short_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:byte"))
	{	cp->type = SOAP_TYPE_xsd__byte_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__byte_;
			if (size)
				*size = sizeof(xsd__byte_);
		}
		else
		{	cp->ptr = (void*)new xsd__byte_[n];
			if (size)
				*size = n * sizeof(xsd__byte_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__byte_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:nonPositiveInteger"))
	{	cp->type = SOAP_TYPE_xsd__nonPositiveInteger_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__nonPositiveInteger_;
			if (size)
				*size = sizeof(xsd__nonPositiveInteger_);
		}
		else
		{	cp->ptr = (void*)new xsd__nonPositiveInteger_[n];
			if (size)
				*size = n * sizeof(xsd__nonPositiveInteger_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__nonPositiveInteger_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:negativeInteger"))
	{	cp->type = SOAP_TYPE_xsd__negativeInteger_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__negativeInteger_;
			if (size)
				*size = sizeof(xsd__negativeInteger_);
		}
		else
		{	cp->ptr = (void*)new xsd__negativeInteger_[n];
			if (size)
				*size = n * sizeof(xsd__negativeInteger_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__negativeInteger_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:nonNegativeInteger"))
	{	cp->type = SOAP_TYPE_xsd__nonNegativeInteger_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__nonNegativeInteger_;
			if (size)
				*size = sizeof(xsd__nonNegativeInteger_);
		}
		else
		{	cp->ptr = (void*)new xsd__nonNegativeInteger_[n];
			if (size)
				*size = n * sizeof(xsd__nonNegativeInteger_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__nonNegativeInteger_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:positiveInteger"))
	{	cp->type = SOAP_TYPE_xsd__positiveInteger_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__positiveInteger_;
			if (size)
				*size = sizeof(xsd__positiveInteger_);
		}
		else
		{	cp->ptr = (void*)new xsd__positiveInteger_[n];
			if (size)
				*size = n * sizeof(xsd__positiveInteger_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__positiveInteger_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedLong"))
	{	cp->type = SOAP_TYPE_xsd__unsignedLong_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedLong_;
			if (size)
				*size = sizeof(xsd__unsignedLong_);
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedLong_[n];
			if (size)
				*size = n * sizeof(xsd__unsignedLong_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedLong_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedInt"))
	{	cp->type = SOAP_TYPE_xsd__unsignedInt_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedInt_;
			if (size)
				*size = sizeof(xsd__unsignedInt_);
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedInt_[n];
			if (size)
				*size = n * sizeof(xsd__unsignedInt_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedInt_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedShort"))
	{	cp->type = SOAP_TYPE_xsd__unsignedShort_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedShort_;
			if (size)
				*size = sizeof(xsd__unsignedShort_);
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedShort_[n];
			if (size)
				*size = n * sizeof(xsd__unsignedShort_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedShort_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedByte"))
	{	cp->type = SOAP_TYPE_xsd__unsignedByte_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedByte_;
			if (size)
				*size = sizeof(xsd__unsignedByte_);
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedByte_[n];
			if (size)
				*size = n * sizeof(xsd__unsignedByte_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedByte_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:wstring"))
	{	cp->type = SOAP_TYPE_xsd__wstring_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__wstring_;
			if (size)
				*size = sizeof(xsd__wstring_);
		}
		else
		{	cp->ptr = (void*)new xsd__wstring_[n];
			if (size)
				*size = n * sizeof(xsd__wstring_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__wstring_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:string"))
	{	cp->type = SOAP_TYPE_xsd__string_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__string_;
			if (size)
				*size = sizeof(xsd__string_);
		}
		else
		{	cp->ptr = (void*)new xsd__string_[n];
			if (size)
				*size = n * sizeof(xsd__string_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__string_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:normalizedString"))
	{	cp->type = SOAP_TYPE_xsd__normalizedString_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__normalizedString_;
			if (size)
				*size = sizeof(xsd__normalizedString_);
		}
		else
		{	cp->ptr = (void*)new xsd__normalizedString_[n];
			if (size)
				*size = n * sizeof(xsd__normalizedString_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__normalizedString_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:token"))
	{	cp->type = SOAP_TYPE_xsd__token_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__token_;
			if (size)
				*size = sizeof(xsd__token_);
		}
		else
		{	cp->ptr = (void*)new xsd__token_[n];
			if (size)
				*size = n * sizeof(xsd__token_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__token_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:base64Binary"))
	{	cp->type = SOAP_TYPE_xsd__base64Binary;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__base64Binary;
			if (size)
				*size = sizeof(xsd__base64Binary);
		}
		else
		{	cp->ptr = (void*)new xsd__base64Binary[n];
			if (size)
				*size = n * sizeof(xsd__base64Binary);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__base64Binary*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:hexBinary"))
	{	cp->type = SOAP_TYPE_xsd__hexBinary;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__hexBinary;
			if (size)
				*size = sizeof(xsd__hexBinary);
		}
		else
		{	cp->ptr = (void*)new xsd__hexBinary[n];
			if (size)
				*size = n * sizeof(xsd__hexBinary);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__hexBinary*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new xsd__anySimpleType;
		if (size)
			*size = sizeof(xsd__anySimpleType);
	}
	else
	{	cp->ptr = (void*)new xsd__anySimpleType[n];
		if (size)
			*size = n * sizeof(xsd__anySimpleType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__anySimpleType*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__anySimpleType(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__anySimpleType %p -> %p\n", q, p));
	*(xsd__anySimpleType*)p = *(xsd__anySimpleType*)q;
}

void xsd__anyType::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__anyType::soap_mark(struct soap *soap) const
{
}

void xsd__anyType::soap_default(struct soap *soap)
{
}

int xsd__anyType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__anyType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__anyType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__anyType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyType(struct soap *soap, const char *tag, int id, const xsd__anyType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xsd__anyType), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *xsd__anyType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__anyType(soap, this, tag, type);
}

SOAP_FMAC3 xsd__anyType * SOAP_FMAC4 soap_get_xsd__anyType(struct soap *soap, xsd__anyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__anyType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__anyType(soap, tag, this, type);
}

SOAP_FMAC3 xsd__anyType * SOAP_FMAC4 soap_in_xsd__anyType(struct soap *soap, const char *tag, xsd__anyType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (xsd__anyType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__anyType, sizeof(xsd__anyType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__anyType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (xsd__anyType *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (xsd__anyType *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_xsd__anyType, 0, sizeof(xsd__anyType), 0, soap_copy_xsd__anyType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 xsd__anyType * SOAP_FMAC6 soap_new_xsd__anyType(struct soap *soap, int n)
{	return soap_instantiate_xsd__anyType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__anyType(struct soap *soap, xsd__anyType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__anyType * SOAP_FMAC6 soap_instantiate_xsd__anyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__anyType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__anyType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "xsd:anySimpleType"))
	{	cp->type = SOAP_TYPE_xsd__anySimpleType;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__anySimpleType;
			if (size)
				*size = sizeof(xsd__anySimpleType);
		}
		else
		{	cp->ptr = (void*)new xsd__anySimpleType[n];
			if (size)
				*size = n * sizeof(xsd__anySimpleType);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__anySimpleType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:anyURI"))
	{	cp->type = SOAP_TYPE_xsd__anyURI_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__anyURI_;
			if (size)
				*size = sizeof(xsd__anyURI_);
		}
		else
		{	cp->ptr = (void*)new xsd__anyURI_[n];
			if (size)
				*size = n * sizeof(xsd__anyURI_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__anyURI_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:boolean"))
	{	cp->type = SOAP_TYPE_xsd__boolean_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__boolean_;
			if (size)
				*size = sizeof(xsd__boolean_);
		}
		else
		{	cp->ptr = (void*)new xsd__boolean_[n];
			if (size)
				*size = n * sizeof(xsd__boolean_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__boolean_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:date"))
	{	cp->type = SOAP_TYPE_xsd__date_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__date_;
			if (size)
				*size = sizeof(xsd__date_);
		}
		else
		{	cp->ptr = (void*)new xsd__date_[n];
			if (size)
				*size = n * sizeof(xsd__date_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__date_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:dateTime"))
	{	cp->type = SOAP_TYPE_xsd__dateTime_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__dateTime_;
			if (size)
				*size = sizeof(xsd__dateTime_);
		}
		else
		{	cp->ptr = (void*)new xsd__dateTime_[n];
			if (size)
				*size = n * sizeof(xsd__dateTime_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__dateTime_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:double"))
	{	cp->type = SOAP_TYPE_xsd__double_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__double_;
			if (size)
				*size = sizeof(xsd__double_);
		}
		else
		{	cp->ptr = (void*)new xsd__double_[n];
			if (size)
				*size = n * sizeof(xsd__double_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__double_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:duration"))
	{	cp->type = SOAP_TYPE_xsd__duration_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__duration_;
			if (size)
				*size = sizeof(xsd__duration_);
		}
		else
		{	cp->ptr = (void*)new xsd__duration_[n];
			if (size)
				*size = n * sizeof(xsd__duration_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__duration_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:float"))
	{	cp->type = SOAP_TYPE_xsd__float_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__float_;
			if (size)
				*size = sizeof(xsd__float_);
		}
		else
		{	cp->ptr = (void*)new xsd__float_[n];
			if (size)
				*size = n * sizeof(xsd__float_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__float_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:time"))
	{	cp->type = SOAP_TYPE_xsd__time_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__time_;
			if (size)
				*size = sizeof(xsd__time_);
		}
		else
		{	cp->ptr = (void*)new xsd__time_[n];
			if (size)
				*size = n * sizeof(xsd__time_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__time_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:decimal"))
	{	cp->type = SOAP_TYPE_xsd__decimal_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__decimal_;
			if (size)
				*size = sizeof(xsd__decimal_);
		}
		else
		{	cp->ptr = (void*)new xsd__decimal_[n];
			if (size)
				*size = n * sizeof(xsd__decimal_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__decimal_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:integer"))
	{	cp->type = SOAP_TYPE_xsd__integer_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__integer_;
			if (size)
				*size = sizeof(xsd__integer_);
		}
		else
		{	cp->ptr = (void*)new xsd__integer_[n];
			if (size)
				*size = n * sizeof(xsd__integer_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__integer_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:long"))
	{	cp->type = SOAP_TYPE_xsd__long_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__long_;
			if (size)
				*size = sizeof(xsd__long_);
		}
		else
		{	cp->ptr = (void*)new xsd__long_[n];
			if (size)
				*size = n * sizeof(xsd__long_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__long_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:int"))
	{	cp->type = SOAP_TYPE_xsd__int_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__int_;
			if (size)
				*size = sizeof(xsd__int_);
		}
		else
		{	cp->ptr = (void*)new xsd__int_[n];
			if (size)
				*size = n * sizeof(xsd__int_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__int_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:short"))
	{	cp->type = SOAP_TYPE_xsd__short_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__short_;
			if (size)
				*size = sizeof(xsd__short_);
		}
		else
		{	cp->ptr = (void*)new xsd__short_[n];
			if (size)
				*size = n * sizeof(xsd__short_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__short_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:byte"))
	{	cp->type = SOAP_TYPE_xsd__byte_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__byte_;
			if (size)
				*size = sizeof(xsd__byte_);
		}
		else
		{	cp->ptr = (void*)new xsd__byte_[n];
			if (size)
				*size = n * sizeof(xsd__byte_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__byte_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:nonPositiveInteger"))
	{	cp->type = SOAP_TYPE_xsd__nonPositiveInteger_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__nonPositiveInteger_;
			if (size)
				*size = sizeof(xsd__nonPositiveInteger_);
		}
		else
		{	cp->ptr = (void*)new xsd__nonPositiveInteger_[n];
			if (size)
				*size = n * sizeof(xsd__nonPositiveInteger_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__nonPositiveInteger_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:negativeInteger"))
	{	cp->type = SOAP_TYPE_xsd__negativeInteger_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__negativeInteger_;
			if (size)
				*size = sizeof(xsd__negativeInteger_);
		}
		else
		{	cp->ptr = (void*)new xsd__negativeInteger_[n];
			if (size)
				*size = n * sizeof(xsd__negativeInteger_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__negativeInteger_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:nonNegativeInteger"))
	{	cp->type = SOAP_TYPE_xsd__nonNegativeInteger_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__nonNegativeInteger_;
			if (size)
				*size = sizeof(xsd__nonNegativeInteger_);
		}
		else
		{	cp->ptr = (void*)new xsd__nonNegativeInteger_[n];
			if (size)
				*size = n * sizeof(xsd__nonNegativeInteger_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__nonNegativeInteger_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:positiveInteger"))
	{	cp->type = SOAP_TYPE_xsd__positiveInteger_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__positiveInteger_;
			if (size)
				*size = sizeof(xsd__positiveInteger_);
		}
		else
		{	cp->ptr = (void*)new xsd__positiveInteger_[n];
			if (size)
				*size = n * sizeof(xsd__positiveInteger_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__positiveInteger_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedLong"))
	{	cp->type = SOAP_TYPE_xsd__unsignedLong_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedLong_;
			if (size)
				*size = sizeof(xsd__unsignedLong_);
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedLong_[n];
			if (size)
				*size = n * sizeof(xsd__unsignedLong_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedLong_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedInt"))
	{	cp->type = SOAP_TYPE_xsd__unsignedInt_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedInt_;
			if (size)
				*size = sizeof(xsd__unsignedInt_);
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedInt_[n];
			if (size)
				*size = n * sizeof(xsd__unsignedInt_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedInt_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedShort"))
	{	cp->type = SOAP_TYPE_xsd__unsignedShort_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedShort_;
			if (size)
				*size = sizeof(xsd__unsignedShort_);
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedShort_[n];
			if (size)
				*size = n * sizeof(xsd__unsignedShort_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedShort_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedByte"))
	{	cp->type = SOAP_TYPE_xsd__unsignedByte_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedByte_;
			if (size)
				*size = sizeof(xsd__unsignedByte_);
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedByte_[n];
			if (size)
				*size = n * sizeof(xsd__unsignedByte_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedByte_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:wstring"))
	{	cp->type = SOAP_TYPE_xsd__wstring_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__wstring_;
			if (size)
				*size = sizeof(xsd__wstring_);
		}
		else
		{	cp->ptr = (void*)new xsd__wstring_[n];
			if (size)
				*size = n * sizeof(xsd__wstring_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__wstring_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:string"))
	{	cp->type = SOAP_TYPE_xsd__string_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__string_;
			if (size)
				*size = sizeof(xsd__string_);
		}
		else
		{	cp->ptr = (void*)new xsd__string_[n];
			if (size)
				*size = n * sizeof(xsd__string_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__string_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:normalizedString"))
	{	cp->type = SOAP_TYPE_xsd__normalizedString_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__normalizedString_;
			if (size)
				*size = sizeof(xsd__normalizedString_);
		}
		else
		{	cp->ptr = (void*)new xsd__normalizedString_[n];
			if (size)
				*size = n * sizeof(xsd__normalizedString_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__normalizedString_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:token"))
	{	cp->type = SOAP_TYPE_xsd__token_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__token_;
			if (size)
				*size = sizeof(xsd__token_);
		}
		else
		{	cp->ptr = (void*)new xsd__token_[n];
			if (size)
				*size = n * sizeof(xsd__token_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__token_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:base64Binary"))
	{	cp->type = SOAP_TYPE_xsd__base64Binary;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__base64Binary;
			if (size)
				*size = sizeof(xsd__base64Binary);
		}
		else
		{	cp->ptr = (void*)new xsd__base64Binary[n];
			if (size)
				*size = n * sizeof(xsd__base64Binary);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__base64Binary*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:hexBinary"))
	{	cp->type = SOAP_TYPE_xsd__hexBinary;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__hexBinary;
			if (size)
				*size = sizeof(xsd__hexBinary);
		}
		else
		{	cp->ptr = (void*)new xsd__hexBinary[n];
			if (size)
				*size = n * sizeof(xsd__hexBinary);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__hexBinary*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "param:params"))
	{	cp->type = SOAP_TYPE_param__params;
		if (n < 0)
		{	cp->ptr = (void*)new param__params;
			if (size)
				*size = sizeof(param__params);
		}
		else
		{	cp->ptr = (void*)new param__params[n];
			if (size)
				*size = n * sizeof(param__params);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (param__params*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "param:arrayvalue"))
	{	cp->type = SOAP_TYPE_param__arrayvalue;
		if (n < 0)
		{	cp->ptr = (void*)new param__arrayvalue;
			if (size)
				*size = sizeof(param__arrayvalue);
		}
		else
		{	cp->ptr = (void*)new param__arrayvalue[n];
			if (size)
				*size = n * sizeof(param__arrayvalue);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (param__arrayvalue*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new xsd__anyType;
		if (size)
			*size = sizeof(xsd__anyType);
	}
	else
	{	cp->ptr = (void*)new xsd__anyType[n];
		if (size)
			*size = n * sizeof(xsd__anyType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__anyType*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__anyType(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__anyType %p -> %p\n", q, p));
	*(xsd__anyType*)p = *(xsd__anyType*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault const*a)
{
	soap_mark_SOAP_ENV__Fault(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	soap_embedded(soap, &a->faultcode, SOAP_TYPE__QName);
	soap_mark__QName(soap, &a->faultcode);
	soap_embedded(soap, &a->faultstring, SOAP_TYPE_string);
	soap_mark_string(soap, &a->faultstring);
	soap_embedded(soap, &a->faultactor, SOAP_TYPE_string);
	soap_mark_string(soap, &a->faultactor);
	soap_embedded(soap, &a->detail, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	soap_mark_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_embedded(soap, &a->SOAP_ENV__Code, SOAP_TYPE_PointerToSOAP_ENV__Code);
	soap_mark_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_embedded(soap, &a->SOAP_ENV__Reason, SOAP_TYPE_string);
	soap_mark_string(soap, &a->SOAP_ENV__Reason);
	soap_embedded(soap, &a->SOAP_ENV__Detail, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	soap_mark_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	a->faultcode = NULL;
	a->faultstring = NULL;
	a->faultactor = NULL;
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type);
	soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, "");
	soap_out_string(soap, "faultstring", -1, &a->faultstring, "");
	soap_out_string(soap, "faultactor", -1, &a->faultactor, "");
	soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, "");
	soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, "");
	soap_out_string(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, "");
	soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	short soap_flag_faultcode = 1, soap_flag_faultstring = 1, soap_flag_faultactor = 1, soap_flag_detail = 1, soap_flag_SOAP_ENV__Code = 1, soap_flag_SOAP_ENV__Reason = 1, soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode = 0;
					continue;
				}
			if (soap_flag_faultstring && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "faultstring", &a->faultstring, ""))
				{	soap_flag_faultstring = 0;
					continue;
				}
			if (soap_flag_faultactor && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "faultactor", &a->faultactor, ""))
				{	soap_flag_faultactor = 0;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail const*a)
{
	soap_mark_SOAP_ENV__Detail(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type);
	soap_putelement(soap, a->fault, "fault", -1, a->__type);
	soap_outliteral(soap, "-any", &a->__any);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	short soap_flag_fault = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code const*a)
{
	soap_mark_SOAP_ENV__Code(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	soap_embedded(soap, &a->SOAP_ENV__Value, SOAP_TYPE__QName);
	soap_mark__QName(soap, &a->SOAP_ENV__Value);
	soap_embedded(soap, &a->SOAP_ENV__Node, SOAP_TYPE_string);
	soap_mark_string(soap, &a->SOAP_ENV__Node);
	soap_embedded(soap, &a->SOAP_ENV__Role, SOAP_TYPE_string);
	soap_mark_string(soap, &a->SOAP_ENV__Role);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	a->SOAP_ENV__Value = NULL;
	a->SOAP_ENV__Node = NULL;
	a->SOAP_ENV__Role = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type);
	soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, "");
	soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, "");
	soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	short soap_flag_SOAP_ENV__Value = 1, soap_flag_SOAP_ENV__Node = 1, soap_flag_SOAP_ENV__Role = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, ""))
				{	soap_flag_SOAP_ENV__Node = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, ""))
				{	soap_flag_SOAP_ENV__Role = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header const*a)
{
	soap_mark_SOAP_ENV__Header(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	soap_embedded(soap, &a->messDesc, SOAP_TYPE_message_desc);
	soap_mark_message_desc(soap, &a->messDesc);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	soap_default_message_desc(soap, &a->messDesc);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type);
	soap_out_message_desc(soap, "messDesc", -1, &a->messDesc, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	short soap_flag_messDesc = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_messDesc && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_message_desc(soap, "messDesc", &a->messDesc, "message-desc"))
				{	soap_flag_messDesc = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_messDesc))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_message_desc(struct soap *soap, struct message_desc_t const*a)
{
	soap_mark_message_desc(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_message_desc(struct soap *soap, const struct message_desc_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_message_desc);
	if (soap_out_message_desc(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct message_desc_t * SOAP_FMAC4 soap_get_message_desc(struct soap *soap, struct message_desc_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_message_desc(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_param_error(struct soap *soap, struct param_error const*a)
{
	soap_mark_param_error(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_param_error(struct soap *soap, const struct param_error *a)
{
	soap_embedded(soap, &a->code, SOAP_TYPE_xsd__int);
	soap_embedded(soap, &a->module, SOAP_TYPE_xsd__wstring);
	soap_mark_xsd__wstring(soap, &a->module);
	soap_embedded(soap, &a->file, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->file);
	soap_embedded(soap, &a->line, SOAP_TYPE_xsd__int);
	soap_embedded(soap, &a->message, SOAP_TYPE_xsd__wstring);
	soap_mark_xsd__wstring(soap, &a->message);
	soap_embedded(soap, &a->locdata, SOAP_TYPE_PointerToparam_error_loc);
	soap_mark_PointerToparam_error_loc(soap, &a->locdata);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_param_error(struct soap *soap, struct param_error *a)
{
	soap_default_xsd__int(soap, &a->code);
	a->module = NULL;
	a->file = NULL;
	soap_default_xsd__int(soap, &a->line);
	a->message = NULL;
	a->locdata = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_param_error(struct soap *soap, const struct param_error *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_param_error);
	if (soap_out_param_error(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_param_error(struct soap *soap, const char *tag, int id, const struct param_error *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_param_error), type);
	soap_out_xsd__int(soap, "code", -1, &a->code, "");
	soap_out_xsd__wstring(soap, "module", -1, &a->module, "");
	soap_out_xsd__string(soap, "file", -1, &a->file, "");
	soap_out_xsd__int(soap, "line", -1, &a->line, "");
	soap_out_xsd__wstring(soap, "message", -1, &a->message, "");
	soap_out_PointerToparam_error_loc(soap, "locdata", -1, &a->locdata, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct param_error * SOAP_FMAC4 soap_get_param_error(struct soap *soap, struct param_error *p, const char *tag, const char *type)
{
	if ((p = soap_in_param_error(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct param_error * SOAP_FMAC4 soap_in_param_error(struct soap *soap, const char *tag, struct param_error *a, const char *type)
{
	short soap_flag_code = 1, soap_flag_module = 1, soap_flag_file = 1, soap_flag_line = 1, soap_flag_message = 1, soap_flag_locdata = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct param_error *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_param_error, sizeof(struct param_error), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_param_error(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "code", &a->code, "xsd:int"))
				{	soap_flag_code = 0;
					continue;
				}
			if (soap_flag_module && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__wstring(soap, "module", &a->module, "xsd:wstring"))
				{	soap_flag_module = 0;
					continue;
				}
			if (soap_flag_file && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "file", &a->file, "xsd:string"))
				{	soap_flag_file = 0;
					continue;
				}
			if (soap_flag_line && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "line", &a->line, "xsd:int"))
				{	soap_flag_line = 0;
					continue;
				}
			if (soap_flag_message && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__wstring(soap, "message", &a->message, "xsd:wstring"))
				{	soap_flag_message = 0;
					continue;
				}
			if (soap_flag_locdata && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToparam_error_loc(soap, "locdata", &a->locdata, ""))
				{	soap_flag_locdata = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_code || soap_flag_line))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct param_error *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_param_error, 0, sizeof(struct param_error), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAPComponentIdsList(struct soap *soap, struct SOAPComponentIdsList const*a)
{
	soap_mark_SOAPComponentIdsList(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_SOAPComponentIdsList(struct soap *soap, struct SOAPComponentIdsList const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_SOAPComponentIdsList))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_SOAPComponentId);
			a->__ptr[i].soap_mark(soap);
		}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAPComponentIdsList(struct soap *soap, struct SOAPComponentIdsList *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAPComponentIdsList(struct soap *soap, const struct SOAPComponentIdsList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_SOAPComponentIdsList);
	if (soap_out_SOAPComponentIdsList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAPComponentIdsList(struct soap *soap, const char *tag, int id, const struct SOAPComponentIdsList *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "SOAPComponentId", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_SOAPComponentIdsList);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		a->__ptr[i].soap_out(soap, "item", -1, "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAPComponentIdsList * SOAP_FMAC4 soap_get_SOAPComponentIdsList(struct soap *soap, struct SOAPComponentIdsList *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAPComponentIdsList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAPComponentIdsList * SOAP_FMAC4 soap_in_SOAPComponentIdsList(struct soap *soap, const char *tag, struct SOAPComponentIdsList *a, const char *type)
{	int i, j;
	SOAPComponentId *p;
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct SOAPComponentIdsList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAPComponentIdsList, sizeof(struct SOAPComponentIdsList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_SOAPComponentIdsList(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = soap_new_SOAPComponentId(soap, a->__size);
			for (i = 0; i < a->__size; i++)
				(a->__ptr+i)->SOAPComponentId::soap_default(soap);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_SOAPComponentId(soap, NULL, a->__ptr + i, ""))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	SOAPComponentId q;
			soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (SOAPComponentId *)soap_push_block(soap, sizeof(SOAPComponentId));
				if (!p)
					return NULL;
				memcpy(p, &q, sizeof(SOAPComponentId));
				p->soap_default(soap);
				if (!soap_in_SOAPComponentId(soap, NULL, p, ""))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			if (soap->blist->size)
				a->__ptr = soap_new_SOAPComponentId(soap, soap->blist->size/sizeof(SOAPComponentId));
			else
				a->__ptr = NULL;
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAPComponentIdsList *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_SOAPComponentIdsList, 0, sizeof(struct SOAPComponentIdsList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	soap_mark_PointerToSOAP_ENV__Code(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_mark_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	soap_mark_PointerToSOAP_ENV__Detail(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_mark_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToparam__value(struct soap *soap, param__value *const*a)
{
	soap_mark_PointerToparam__value(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerToparam__value(struct soap *soap, param__value *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_param__value))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToparam__value(struct soap *soap, param__value *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToparam__value);
	if (soap_out_PointerToparam__value(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToparam__value(struct soap *soap, const char *tag, int id, param__value *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_param__value);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 param__value ** SOAP_FMAC4 soap_get_PointerToparam__value(struct soap *soap, param__value **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToparam__value(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 param__value ** SOAP_FMAC4 soap_in_PointerToparam__value(struct soap *soap, const char *tag, param__value **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (param__value **)soap_malloc(soap, sizeof(param__value *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (param__value *)soap_instantiate_param__value(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (param__value **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_param__value, sizeof(param__value), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToparam__node(struct soap *soap, param__node *const*a)
{
	soap_mark_PointerToparam__node(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerToparam__node(struct soap *soap, param__node *const*a)
{
	if (*a && !soap_array_reference(soap, *a, (struct soap_array*)&(*a)->__ptr, 1, SOAP_TYPE_param__node))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToparam__node(struct soap *soap, param__node *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToparam__node);
	if (soap_out_PointerToparam__node(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToparam__node(struct soap *soap, const char *tag, int id, param__node *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_param__node);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 param__node ** SOAP_FMAC4 soap_get_PointerToparam__node(struct soap *soap, param__node **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToparam__node(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 param__node ** SOAP_FMAC4 soap_in_PointerToparam__node(struct soap *soap, const char *tag, param__node **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (param__node **)soap_malloc(soap, sizeof(param__node *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (param__node *)soap_instantiate_param__node(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (param__node **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_param__node, sizeof(param__node), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToparam__entry(struct soap *soap, param__entry *const*a)
{
	soap_mark_PointerToparam__entry(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerToparam__entry(struct soap *soap, param__entry *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_param__entry))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToparam__entry(struct soap *soap, param__entry *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToparam__entry);
	if (soap_out_PointerToparam__entry(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToparam__entry(struct soap *soap, const char *tag, int id, param__entry *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_param__entry);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 param__entry ** SOAP_FMAC4 soap_get_PointerToparam__entry(struct soap *soap, param__entry **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToparam__entry(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 param__entry ** SOAP_FMAC4 soap_in_PointerToparam__entry(struct soap *soap, const char *tag, param__entry **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (param__entry **)soap_malloc(soap, sizeof(param__entry *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (param__entry *)soap_instantiate_param__entry(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (param__entry **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_param__entry, sizeof(param__entry), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__anyType(struct soap *soap, xsd__anyType *const*a)
{
	soap_mark_PointerToxsd__anyType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerToxsd__anyType(struct soap *soap, xsd__anyType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__anyType))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__anyType(struct soap *soap, xsd__anyType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__anyType);
	if (soap_out_PointerToxsd__anyType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__anyType(struct soap *soap, const char *tag, int id, xsd__anyType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__anyType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 xsd__anyType ** SOAP_FMAC4 soap_get_PointerToxsd__anyType(struct soap *soap, xsd__anyType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__anyType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 xsd__anyType ** SOAP_FMAC4 soap_in_PointerToxsd__anyType(struct soap *soap, const char *tag, xsd__anyType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (xsd__anyType **)soap_malloc(soap, sizeof(xsd__anyType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xsd__anyType *)soap_instantiate_xsd__anyType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__anyType, sizeof(xsd__anyType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToparam_error_loc(struct soap *soap, param_error_loc *const*a)
{
	soap_mark_PointerToparam_error_loc(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerToparam_error_loc(struct soap *soap, param_error_loc *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_param_error_loc))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToparam_error_loc(struct soap *soap, param_error_loc *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToparam_error_loc);
	if (soap_out_PointerToparam_error_loc(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToparam_error_loc(struct soap *soap, const char *tag, int id, param_error_loc *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_param_error_loc);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 param_error_loc ** SOAP_FMAC4 soap_get_PointerToparam_error_loc(struct soap *soap, param_error_loc **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToparam_error_loc(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 param_error_loc ** SOAP_FMAC4 soap_in_PointerToparam_error_loc(struct soap *soap, const char *tag, param_error_loc **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (param_error_loc **)soap_malloc(soap, sizeof(param_error_loc *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (param_error_loc *)soap_instantiate_param_error_loc(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (param_error_loc **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_param_error_loc, sizeof(param_error_loc), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__wstring(struct soap *soap, wchar_t **const*a)
{
	soap_mark_PointerToxsd__wstring(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerToxsd__wstring(struct soap *soap, wchar_t **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__wstring))
		soap_mark_xsd__wstring(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__wstring(struct soap *soap, wchar_t **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__wstring);
	if (soap_out_PointerToxsd__wstring(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__wstring(struct soap *soap, const char *tag, int id, wchar_t **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__wstring);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__wstring(soap, tag, id, *a, type);
}

SOAP_FMAC3 wchar_t *** SOAP_FMAC4 soap_get_PointerToxsd__wstring(struct soap *soap, wchar_t ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__wstring(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 wchar_t *** SOAP_FMAC4 soap_in_PointerToxsd__wstring(struct soap *soap, const char *tag, wchar_t ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (wchar_t ***)soap_malloc(soap, sizeof(wchar_t **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__wstring(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (wchar_t ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__wstring, sizeof(wchar_t *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAPComponentId(struct soap *soap, SOAPComponentId *const*a)
{
	soap_mark_PointerToSOAPComponentId(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerToSOAPComponentId(struct soap *soap, SOAPComponentId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAPComponentId))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAPComponentId(struct soap *soap, SOAPComponentId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAPComponentId);
	if (soap_out_PointerToSOAPComponentId(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAPComponentId(struct soap *soap, const char *tag, int id, SOAPComponentId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAPComponentId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 SOAPComponentId ** SOAP_FMAC4 soap_get_PointerToSOAPComponentId(struct soap *soap, SOAPComponentId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAPComponentId(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 SOAPComponentId ** SOAP_FMAC4 soap_in_PointerToSOAPComponentId(struct soap *soap, const char *tag, SOAPComponentId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (SOAPComponentId **)soap_malloc(soap, sizeof(SOAPComponentId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (SOAPComponentId *)soap_instantiate_SOAPComponentId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (SOAPComponentId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAPComponentId, sizeof(SOAPComponentId), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
{
	soap_mark_PointerTounsignedByte(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTounsignedByte);
	if (soap_out_PointerTounsignedByte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedByte);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedByte(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedByte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTounsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedByte(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedByte, sizeof(unsigned char), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__token(struct soap *soap, char *const*a)
{
	soap_mark_xsd__token(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_xsd__token(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__token);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__token(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__token);
	if (soap_out_xsd__token(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__token(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__token);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__token(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__token(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__token(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__token, 1, 0, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__normalizedString(struct soap *soap, char *const*a)
{
	soap_mark_xsd__normalizedString(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_xsd__normalizedString(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__normalizedString);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__normalizedString(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__normalizedString);
	if (soap_out_xsd__normalizedString(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__normalizedString(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__normalizedString);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__normalizedString(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__normalizedString(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__normalizedString(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__normalizedString, 1, 0, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__string(struct soap *soap, char *const*a)
{
	soap_mark_xsd__string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_xsd__string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__string);
	if (soap_out_xsd__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__string, 1, 0, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__wstring(struct soap *soap, wchar_t *const*a)
{
	soap_mark_xsd__wstring(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_xsd__wstring(struct soap *soap, wchar_t *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__wstring);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__wstring(struct soap *soap, wchar_t *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__wstring);
	if (soap_out_xsd__wstring(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__wstring(struct soap *soap, const char *tag, int id, wchar_t *const*a, const char *type)
{
	return soap_outwstring(soap, tag, id, a, type, SOAP_TYPE_xsd__wstring);
}

SOAP_FMAC3 wchar_t ** SOAP_FMAC4 soap_get_xsd__wstring(struct soap *soap, wchar_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__wstring(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 wchar_t * * SOAP_FMAC4 soap_in_xsd__wstring(struct soap *soap, const char *tag, wchar_t **a, const char *type)
{
	return soap_inwstring(soap, tag, a, type, SOAP_TYPE_xsd__wstring, 0, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wstring(struct soap *soap, wchar_t *const*a)
{
	soap_mark_wstring(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_wstring(struct soap *soap, wchar_t *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_wstring);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wstring(struct soap *soap, wchar_t *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wstring);
	if (soap_out_wstring(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstring(struct soap *soap, const char *tag, int id, wchar_t *const*a, const char *type)
{
	return soap_outwstring(soap, tag, id, a, type, SOAP_TYPE_wstring);
}

SOAP_FMAC3 wchar_t ** SOAP_FMAC4 soap_get_wstring(struct soap *soap, wchar_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_wstring(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 wchar_t * * SOAP_FMAC4 soap_in_wstring(struct soap *soap, const char *tag, wchar_t **a, const char *type)
{
	return soap_inwstring(soap, tag, a, type, SOAP_TYPE_wstring, 0, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__positiveInteger(struct soap *soap, char *const*a)
{
	soap_mark_xsd__positiveInteger(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_xsd__positiveInteger(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__positiveInteger);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__positiveInteger(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__positiveInteger);
	if (soap_out_xsd__positiveInteger(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__positiveInteger(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__positiveInteger);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__positiveInteger(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__positiveInteger(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__positiveInteger(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__positiveInteger, 1, 0, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__nonNegativeInteger(struct soap *soap, char *const*a)
{
	soap_mark_xsd__nonNegativeInteger(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_xsd__nonNegativeInteger(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__nonNegativeInteger);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__nonNegativeInteger(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__nonNegativeInteger);
	if (soap_out_xsd__nonNegativeInteger(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__nonNegativeInteger(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__nonNegativeInteger);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__nonNegativeInteger(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__nonNegativeInteger(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__nonNegativeInteger(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__nonNegativeInteger, 1, 0, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__negativeInteger(struct soap *soap, char *const*a)
{
	soap_mark_xsd__negativeInteger(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_xsd__negativeInteger(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__negativeInteger);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__negativeInteger(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__negativeInteger);
	if (soap_out_xsd__negativeInteger(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__negativeInteger(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__negativeInteger);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__negativeInteger(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__negativeInteger(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__negativeInteger(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__negativeInteger, 1, 0, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__nonPositiveInteger(struct soap *soap, char *const*a)
{
	soap_mark_xsd__nonPositiveInteger(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_xsd__nonPositiveInteger(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__nonPositiveInteger);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__nonPositiveInteger(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__nonPositiveInteger);
	if (soap_out_xsd__nonPositiveInteger(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__nonPositiveInteger(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__nonPositiveInteger);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__nonPositiveInteger(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__nonPositiveInteger(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__nonPositiveInteger(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__nonPositiveInteger, 1, 0, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__integer(struct soap *soap, char *const*a)
{
	soap_mark_xsd__integer(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_xsd__integer(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__integer);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__integer(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__integer);
	if (soap_out_xsd__integer(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__integer(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__integer);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__integer(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__integer(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__integer(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__integer, 1, 0, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__decimal(struct soap *soap, char *const*a)
{
	soap_mark_xsd__decimal(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_xsd__decimal(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__decimal);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__decimal(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__decimal);
	if (soap_out_xsd__decimal(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__decimal(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__decimal);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__decimal(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__decimal(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__decimal(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__decimal, 1, 0, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__time(struct soap *soap, char *const*a)
{
	soap_mark_xsd__time(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_xsd__time(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__time);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__time(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__time);
	if (soap_out_xsd__time(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__time(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__time);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__time(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__time(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__time(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__time, 1, 0, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__duration(struct soap *soap, char *const*a)
{
	soap_mark_xsd__duration(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_xsd__duration(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__duration);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__duration(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__duration);
	if (soap_out_xsd__duration(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__duration(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__duration);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__duration(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__duration(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__duration(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__duration, 1, 0, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__dateTime(struct soap *soap, char *const*a)
{
	soap_mark_xsd__dateTime(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_xsd__dateTime(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__dateTime);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__dateTime(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__dateTime);
	if (soap_out_xsd__dateTime(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__dateTime(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__dateTime);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__dateTime(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__dateTime(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__dateTime(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__dateTime, 1, 0, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__date(struct soap *soap, char *const*a)
{
	soap_mark_xsd__date(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_xsd__date(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__date);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__date(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__date);
	if (soap_out_xsd__date(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__date(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__date);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__date(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__date(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__date(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__date, 1, 0, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__anyURI(struct soap *soap, char *const*a)
{
	soap_mark_xsd__anyURI(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_xsd__anyURI(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__anyURI);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyURI(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__anyURI);
	if (soap_out_xsd__anyURI(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__anyURI);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__anyURI(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__anyURI(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__anyURI, 1, 0, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	soap_mark__QName(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark__QName(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE__QName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_mark_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1);
}

SOAP_END_NAMESPACE(soap)

/* end of soapC.cpp */
