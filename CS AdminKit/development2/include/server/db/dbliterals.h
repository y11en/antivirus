#ifndef __KL_DBLITERALS_H__
#define __KL_DBLITERALS_H__

namespace KLDBPST
{
    class DbSqlPst;
};

namespace KLDB
{
    typedef KLSTD::CAutoPtr<KLDBPST::DbSqlPst>   DbSqlPstPtr;

    enum kldb_idbtype_t
    {
        kldbidt_column,
        kldbidt_function,
        kldbidt_type,
        kldbidt_type_for_temp_table
    };

    enum kldb_func_t
    {
        kldbf_getutcdate,        
        kldbf_len,
        kldbf_isnull
    };

    enum kldbtype_t
    {
        kldbt_unknown = 0,
        kldbt_sqlserver,
        kldbt_mysql
    };

    class KLSTD_NOVTABLE DbLiterals
        :   public KLSTD::KLBaseQI
    {
    public:
        //! forms time for SQL query
        virtual std::wstring MakeTime(time_t x) = 0;

        //! forms string for SQL query
        virtual std::wstring MakeString(const wchar_t* x, bool bWide = true) = 0;
        
        //! forms string for SQL query
        virtual std::wstring MakeString(const std::wstring& x, bool bWide = true) = 0;

        //! forms long for SQL query
        virtual std::wstring MakeLong(long x) = 0;

        //! forms long long for SQL query
        virtual std::wstring MakeLonglong(AVP_longlong x) = 0;
        
        /*!
            forms part of CREATE TABLE statement: 'CREATE TABLE <szwTable> '
            For example on SQL Server call 
                MakeCreateTable(L"xxx", true)
            creates (without ')
                'CREATE TABLE #xxx '
            On MySQL it results in
                'CREATE TEMPORARY TABLE xxx '
        */
        virtual std::wstring MakeCreateTable(const wchar_t* szwTable, bool bTemp) = 0;

        /*!
            forms part of CREATE TABLE with existence check
            Attention !!! Resulting statement may contain condition.
            For example on SQL Server call 
                MakeCreateTableNotExisting(L"xxx", true)
            creates (without ')
                'IF OBJECT_ID(tempdb..#xxx) IS NULL CREATE TABLE #xxx '
            But on MySQL it results in
                'CREATE TEMPORARY TABLE IF NOT EXISTS xxx '
        */
        virtual std::wstring MakeCreateTableNotExisting(const wchar_t* szwTable, bool bTemp) = 0;

        /*!
            forms table name
            For example on SQL Server call MakeTableName(L"xxx", true)
            creates (without ') '#xxx'.
            On MySQL it results in 'xxx'.
        */
        virtual std::wstring MakeTableName(const wchar_t* szwTable, bool bTemp) = 0;

        /*!
            forms DROP TABLE with existence check
            Attention !!! Resulting statement may contain condition.
            For example on SQL Server call 
                MakeDropTableExisting(L"xxx", true)
            creates (without ')
                'IF OBJECT_ID(tempdb..#xxx) IS NOT NULL DROP TABLE #xxx '
            But on MySQL it results in
                'DROP TEMPORARY TABLE IF EXISTS xxx '
        */
        virtual std::wstring MakeDropTableExisting(const wchar_t* szwTable, bool bTemp) = 0;

        /*!
          \brief	Returns type of db server

          \return	KLDB::kldbtype_t 
        */
        virtual KLDB::kldbtype_t GetDbType() = 0;

        /*!
          \brief	 Returns autogenerated prepared statements

          \return	KLDB::DbSqlPstPtr  
        */
        virtual KLDB::DbSqlPstPtr   GetSqlPst() = 0;        

        /*!
          \brief	Wrappes id usage (column name or function call)

          \param	wstrName id name
          \return	
        */
        virtual std::wstring MakeIdName(
                                    const std::wstring& wstrName, 
                                    KLDB::kldb_idbtype_t type) = 0;

        /*!
          \brief	Returns names of standart functions. 

          \param	KLDB::kldb_func_t type
          \return	virtual std::wstring 
        */
        virtual std::wstring GetStdFunc(KLDB::kldb_func_t type) = 0;

        /*!
          \brief	Casts specified expression wstrInitialExpression 
                    into type type.

          \param	wstrInitialExpression
          \param	type    data type
          \param	nLength data length (for strings and binaries)
          \return	casted expression
        */
        virtual std::wstring CastExpression(
                        const std::wstring& wstrInitialExpression,
                        KLDB::dbvalue_type_t    type,
                        size_t                  nLength) = 0;
    };

    typedef KLSTD::CAutoPtr<DbLiterals> DbLiteralsPtr;
};

#endif //__KL_DBLITERALS_H__
