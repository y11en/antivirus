#include "CrC_User.h"
#include <stdio.h>
/*▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄DEFINES*/
/*▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀MASKSECC*/
int     CrypC_Mask_SecretKey_( struct RND_State *State, void  *Sec )
/*───────────────────────────────────────────────────────────────────────────*/
/*             Формирование поля маскированного секретного ключа             */
/*                            ДЛЯ ШИФРОВАНИЯ.                                */
/* Входные параметры:                                                        */
/* - Секретный ключ - первые NK*4 байта NK*4*2-байтового поля ключа *Sec.    */
/* Выход:                                                                    */
/* - Замаскированный секретный ключ замещает секретный ключ в первых NK*4    */
/*   байтах поля Sec.                                                        */
/* - Маска секретного ключа размещается в последних NK*4 байтах поля Sec.    */
/* - Секретный ключ есть результат пословного (слово длины 32 бита) сложения */
/*   по модулю 2**32 вектора замаскированного секретного ключа и вектора     */
/*   маски. Замаскированный секретный ключ используется процедурами _GOSTE   */
/*   и _GOSTA.                                                               */
/*───────────────────────────────────────────────────────────────────────────*/
{
  DWORD *M1, TMPKey[LNK];
  int i;
extern   struct COM_State PERMDefault;
/* Вызов процедуры формирования  модифицированного массива перестановок       */
/* для криптосхемы ГОСТ 28147-89:                                             */
CrypC__InitGost( (BYTE *)PERMDefault.Perms, PERMDefault.K_ );

/* Начальное заполнение маски ключа.                   */
CrypC_FillByRandom_(State,(BYTE *)Sec+LNK*4,LNK*4);

/* Случайный ключ.                                     */
CrypC_FillByRandom_(State,TMPKey,LNK*4);

/* Перешифрование на случайном ключе.                  */
for(i=0;i<LNK/2;i++)
   {
   M1=(DWORD *)((char *)Sec+(i*8)+LNK*4);
   CrypC__GOSTE_(PERMDefault.K_,TMPKey,M1,M1);
   }

/* Пословное наложение маски ключа на секретный ключ.  */
for(i=0;i<LNK;i++)
   ((DWORD *)Sec)[i] -= ((DWORD *)Sec)[i+LNK];

return(0);
}
/*▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄MASKSECC*/
/*▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀REMASKSECC*/
int     CrypC_ReMask_SecretKey_( struct RND_State *State, void  *Sec )
/*───────────────────────────────────────────────────────────────────────────*/
/*              Изменение маски маскированного секретного ключа              */
/*                            ДЛЯ ШИФРОВАНИЯ.                                */
/* Входные параметры:                                                        */
/* - Маскированный секретный ключ - NK*4*2-байтовое поле ключа *Sec.         */
/* Выход:                                                                    */
/* - Замаскированный секретный ключ замещает секретный ключ в первых NK*4    */
/*   байтах поля Sec.                                                        */
/* - Маска секретного ключа размещается в последних NK*4 байтах поля Sec.    */
/* - Секретный ключ есть результат пословного (слово длины 32 бита) сложения */
/*   по модулю 2**32 вектора замаскированного секретного ключа и вектора     */
/*   маски. Замаскированный секретный ключ используется процедурами _GOSTE   */
/*   и _GOSTA.                                                               */
/*───────────────────────────────────────────────────────────────────────────*/
{
  DWORD *M1;
  int i;
  DWORD  TMPMask[LNK],TMPKey[LNK];
extern   struct COM_State PERMDefault;
/* Вызов процедуры формирования  модифицированного массива перестановок       */
/* для криптосхемы ГОСТ 28147-89:                                             */
CrypC__InitGost( (BYTE *)PERMDefault.Perms, PERMDefault.K_ );

/* Начальное заполнение маски ключа.                      */
CrypC_FillByRandom_(State,(BYTE *)TMPMask,LNK*4);

/* Случайный ключ.                                        */
CrypC_FillByRandom_(State,TMPKey,LNK*4);

/* Перешифрование на случайном ключе.                     */
for(i=0;i<LNK/2;i++)
   {
   M1=(DWORD *)((char *)TMPMask+(i*8));
   CrypC__GOSTE_(PERMDefault.K_,TMPKey,M1,M1);
   }

/* Пословное переналожение маски ключа на секретный ключ. */
for(i=0;i<LNK;i++)
   ((DWORD *)Sec)[i] += ((DWORD *)Sec)[i+LNK]-((DWORD *)TMPMask)[i];

/* Копирование новой маски.                               */
memcpy((BYTE *)Sec+LNK*4,TMPMask,LNK*4);

return(0);
}
/*▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄REMASKSECC*/
/*▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀EOF*/
