#ifndef __UTILS_H
#define __UTILS_H

#include <Windows.h>
#include "../stuff/sarray.h"

// Проверить является ли окно диалогом
bool  IsDlgClassName( HWND win );

// Выдать размер числа в десятичных цифрах
int SizeValueInDecChars( DWORD nValue );

// Создать и разрушить уникальное число
UINT	CreateUniqueId();
void	DestroyUniqueId( UINT id );

// Найти минимальное неиспользованное число в массиве
UINT GetMinUnusedValue( CSArray<UINT> &rcIdArray );

// Получить высоту стандартного окна для заданного фонта
int	 GetStandartComboHeight( HFONT hFont, HINSTANCE hInstance );

// Сформировать уникальное имя файла для заданного каталога по заданному шаблону
// Выдается копия имени
// path          - путь к каталогу
// nameTemplate  - шаблон имени файла (формат шаблона - []XXXXXX.ext или []XXXXXX
TCHAR *GetUniqueFileName( const TCHAR *pszPath, const TCHAR *pszTemplate );


// "Откачать" очередь сообщений
void PumpWaitingMessages( HWND hWndOwner, UINT wMsgFilterMin = 0, UINT wMsgFilterMax = 0 );

// Сжать путь до заданной длины в байтах
// Если exclusive = true и путь не удается сжать, то он укорачивается принудительно
// и дописывается "..."
// Возвращается указатель на статическую переменную предельной длины 4096 символов
// Если pStr==NULL, то возвращается указатель на пустую строку (первый символ=0)
// Для многопоточной работы рекомендуется применять вариант с выходным буфером
// (в этом случае возвращается указатель на первый байт буфера)
TCHAR *CompressPath( const TCHAR *pStr, int nLenLimit, bool bExclusive = true, TCHAR *pDst = NULL, DWORD dwDstLen = 0 );

// Сжать путь до заданной длины в пикселях для заданного фонта
// Если bExclusive = true и путь не удается сжать, то он укорачивается принудительно
// и дописывается "..."
// Возвращается указатель на статическую переменную предельной длины 4096 символов
// Если pStr==NULL, то возвращается указатель на пустую строку (первый символ=0)
// Для многопоточной работы рекомендуется применять вариант с выходным буфером
// (в этом случае возвращается указатель на первый байт буфера)
TCHAR *CompressPath( const TCHAR *pStr, HFONT hFont, int nXSize, bool bExclusive = true, TCHAR *pDst = NULL, DWORD dwDstLen = 0 );

// Сжать путь до заданной длины в пикселях для заданного DC на его фонте
// Если bExclusive = true и путь не удается сжать, то он укорачивается принудительно
// и дописывается "..."
// Возвращается указатель на статическую переменную предельной длины 4096 символов
// Если pStr==NULL, то возвращается указатель на пустую строку (первый символ=0)
// Для многопоточной работы рекомендуется применять вариант с выходным буфером
// (в этом случае возвращается указатель на первый байт буфера)
TCHAR *CompressPath( const TCHAR *pStr, HDC hDC, int nXSize, bool bExclusive = true, TCHAR *pDst = NULL, DWORD dwDstLen = 0 );

// Сжать путь до размера заданного окна на его фонте
// Если bExclusive = true и путь не удается сжать, то он укорачивается принудительно
// и дописывается "..."
// Возвращается указатель на статическую переменную предельной длины 4096 символов
// Если pStr==NULL, то возвращается указатель на пустую строку (первый символ=0)
// Для многопоточной работы рекомендуется применять вариант с выходным буфером
// (в этом случае возвращается указатель на первый байт буфера)
TCHAR *CompressPath( const TCHAR *pStr, HWND hWnd, bool bExclusive = true, TCHAR *pDst = NULL, DWORD dwDstLen = 0 );

#endif
