/*______________________________________________________________________________
	Copyright (C) 2002-2003 PGP Corporation
	All rights reserved.


	$Id: nPGPNts.c 24452 2004-06-09 22:46:15Z pryan $
______________________________________________________________________________*/

/*::: MODULE OVERVIEW :::::::::::::
Provides central management services for the back-end infrastructure of the 
Lotus Notes PGP Plug-In.

--- revision history --------
10/13/03 Version 1.3.5 Paul Ryan
+ fixed bug in es_SpecialDecryptAttachment()
+ tentatively fixed bugs in xus_decodePgpMime()

8/21/03 Version 1.3.4 Paul Ryan
+ fixed SMTP name-resolution bug via enhancement to us_CreateRecipientsArray()
+ logic adjustment to fix seeming flaws in xus_decodePgpMime()
+ documentation adjustment
+ updated plug-in version string

7/21/03 Version 1.3.2 Paul Ryan
+ updated plug-in version string
+ logic enhancement of i_PgpDecodeUsingRichTextObj() to avoid failure in 
  Notes 6 fixups of action-attach hotspots written by an R5 client
+ safety improvement to es_SpecialDecryptAttachment() to prevent crash if 
  expected attachment is not found (as may occur if multiple attachments of the 
  same name are attached to a message)

6/26/03 Version 1.3.1 Paul Ryan
+ Enhancement toward enabling the tracking pull-down of missing ADKs, causing 
  extension of encode-context structure and i_PgpMatchSmtpAddresses() 
  signature, and enhancement of i_MatchPgpKeys() & i_PgpMatchNotesNames()
+ minor logic improvement to xs_VetPluginReadiness()
+ token renaming, documentation improvement

3/14/03 Version 1.3 Paul Ryan
+ logic enhancement and extension to support Notes 6, handling of received 
  PGP/MIME content, and handling of PGP-encoded content inserted by non-plug-in 
  means
+ logic enhancement to support enablement of Tempest viewer in plug-in
+ logic enhancement to provide better handling of input buffers 64K or greater 
  in size
+ logic enhancement to support Notes 6
+ much documentation and listing format adjustment

10/30/02 Version 1.2.2 Paul Ryan
+ logic enhancement to support gracefully user-cancelation during key-server 
  searches [creation of i_MatchPgpKeys(), i_PgpMatchSmtpAddresses(), 
  associated adjustment of i_PgpMatchNotesNames(), xs_PgpSecureMessage()]
+ listing format adjustment, token renaming, documentation improvement

9/6/02 Version 1.2.1 Paul Ryan
+ logic enhancemnt during message decoding to wrap PGP-encoded attachments in 
  messages not generated by the Notes plug-in so that special PGP handling can 
  be provided
+ logic enhancement to support high-ASCII (international) characters in the 
  message body and in attachment handling
+ removed unnecessary critical-section variable
+ explicitly set WINVER preprocessor token to 0x0400 (Win95/NT4 baseline)
+ much listing format adjustment, documentation adjustment, token renaming

7/2/01 Version 1.2 Paul Ryan
+ logic enhancement in support of robust plug-in version handling
+ listing format adjustment, documentation adjustment

11/16/00 Version 1.1.8 Paul Ryan
+ added work-around method for marking a document as read

11/14/00 Version 1.1.7 Paul Ryan
+ added support for resetting the view/folder context associated with a 
  document currenty being shown to the user in the Notes R5 user interface, see 
  xs_vetFolderCtx()
+ documentation adjustment

10/7/00 Version 1.1.6 Paul Ryan
+ Revamped the plug-in setup procedure. See xs_VetPluginReadiness().
+ bug fixes to es_SpecialDecryptAttachment()
+ documentation adjustment

9/16/00 Version 1.1.5 Paul Ryan
+ enhancements surrounding special handling of PGP-encoded attachments in a 
  Notes message
+ design improvement to internals controlling the checkmark toggling of the PGP 
  drop-down action-bar menu
+ documentation adjustment, token renaming

8/9/00 Version 1.1.2 Paul Ryan
+ manufacture of checkmark toggling for the PGP drop-down action-bar menu
+ work towards improved file-attachment handling (not enabled)
+ got rid of hack in i_PgpEncodeAttachments() for attaching encoded files 
  without Notes trying to sign them when sending the message in MIME format
+ documentation improvement

3/20/00 Version 1.1.1 Paul Ryan
+ adjustment to support Notes R5, Notes Mail R5 template and PGP 7.0
+ documentation adjustments, logic enhancements
+ Bug fix of behavior where a pre-existing encoded rich-text attachment was not 
  being removed during a new encoding. Fix relates primarily to message forward 
  and "reply with history" operations.

9/12/99 Version 1.1 Paul Ryan
+ PGP 6.5.1 compatibility
+ logic enhancements
   - support for reading into memory rich-text content resident in a compressed 
     attachment
   - default handling of Notes addresses in the user-friendlier abbreviated 
     format
   - improved Domino Directory name-lookup functionality to emulate better 
     Notes' normal algorithm, and thereby enhanced the plug-in's group-
	 resolution capability
+ documentation enhancements

1/29/99 Version 1.0 Paul Ryan
::::::::::::::::::::::::::::::::::::*/

#include "nPGPNts.h"


//global-scope declarations
HINSTANCE  eh_Instance;

//module-scope declarations
static const char  mpc_PGP_ARMOR_EXT_ASC[] = ".asc", 
					mpc_PGP_ARMOR_EXT_PGP[] = ".pgp", 

					mpc_PGPFLG_HOTSPOT_6[] = "A6", 
					mpc_PGPFLG_HOTSPOT_5[] = "A5", 
					mpc_PGPFLG_HAS_RTF_ATTCH[] = "RA", 
					mpc_PGPFLG_HAS_ARMOR[] = "AR", 

					mpc_ROOTFILENM_PGP_RTF[] = "pgp.rtf", 
					mpc_PROPNM_ORIG_WNDPROC[] = "OrigWndProc", 
					mpc_PROPNM_EXTR_DLG_CHOICE[] = "ActionChoice", 
					mpc_FILENM_PGP_SRC[] = "pgp.src.ref", 
					mpc_FLDNM_PGPMIM_HLDR[] = "men_Pgp", 
					
					mpc_VALID_NON_ALPHANUM_SMTP_ADDR_CHARS[] = "-_";
static const size_t  mui_LEN_ARMOR_EXT_ASC = sizeof( mpc_PGP_ARMOR_EXT_ASC) - 
																			1, 
						mui_LEN_ARMOR_EXT_PGP = sizeof( 
													mpc_PGP_ARMOR_EXT_PGP) - 1, 

						mui_LEN_PGPFLG_HAS_RTF_ATTCH = sizeof( 
												mpc_PGPFLG_HAS_RTF_ATTCH) - 1, 
						mui_LEN_PGPFLG_HOTSPOT_6 = sizeof( 
													mpc_PGPFLG_HOTSPOT_6) - 1, 
						mui_LEN_PGPFLG_HOTSPOT_5 = sizeof( 
													mpc_PGPFLG_HOTSPOT_5) - 1, 

						mui_LEN_FLDNM_PGPMIM_HLDR = sizeof( 
													mpc_FLDNM_PGPMIM_HLDR) - 1;
static const int  mi_CANCEL = 2, mi_SUCCESS = 3, 
					mi_MASK_DCRYPTD = 0x8000;
static const WORD  mus_BLD_1ST_6 = 173;

static char  mpc_fileNmPgpRtf[ sizeof( mpc_ROOTFILENM_PGP_RTF) + 
										sizeof( mpc_PGP_ARMOR_EXT_ASC) - 1], 
				mpc_validSmtpAddrChars[ 62 + sizeof( 
										mpc_VALID_NON_ALPHANUM_SMTP_ADDR_CHARS)];

static ResettableRtfInfo  mt_RtfResettable;
static HFONT  mh_fntFileCaption;
static OSVERSIONINFO  mt_Os = {sizeof( OSVERSIONINFO)};
static WORD  mus_build;
static BOOL  mf_Notes6;


/** xs_markRead( ***
Mark the specified note as read. Works around strange unread-marks behaviors 
seen with the Notes R5 client.

--- parameter & return ----
h_NOTE: handle to the note to be marked as read
RETURN:
	eus_SUCCESS if no errors occurred
	eus_ERR_INVLD_ARG if any passed-in parameter is obviously invalid
	the Notes API error code otherwise

--- revision history ------
9/6/02 PR: listing format adjustment, minor exception-handling adjustment
11/16/00 PR: created		*/
short xs_markRead( const NOTEHANDLE  h_NOTE)	{
	static char  pc_userNm[ MAXUSERNAME + 1];
	static WORD  us_lenUserNm;

	NOTEID  nid;
	DBHANDLE  h_db;
	HANDLE  h_unrd, h_unrdOrig = NULL;
	BOOL  f_chngd;
	STATUS  us_err, us_error;

	if (!h_NOTE)
		return (short) eus_ERR_INVLD_ARG;

	//if necessary, get the username associated with the ID associated with the 
	//	execution going on here
	if (!us_lenUserNm)	{
		if (us_err = SECKFMGetUserName( pc_userNm))
			return us_err;
		us_lenUserNm = strlen( pc_userNm);
	}

	//derive the NoteID and the handle to the database containing the note
	NSFNoteGetInfo( (NOTEHANDLE) h_NOTE, _NOTE_ID, &nid);
	NSFNoteGetInfo( (NOTEHANDLE) h_NOTE, _NOTE_DB, &h_db);

	//get the current unread table
	if (us_err = NSFDbGetUnreadNoteTable( h_db, pc_userNm, us_lenUserNm, TRUE, 
																	&h_unrd))
		return us_err;
	if (us_err = NSFDbUpdateUnread( h_db, h_unrd))
		goto errJump;
	if (us_err = IDTableCopy( h_unrd, &h_unrdOrig))
		goto errJump;

	//if the NoteID of the specified note is present in the unread table, 
	//	delete that entry 
	if (us_err = IDDelete( h_unrd, nid, &f_chngd))
		goto errJump;

	//if a deletion did occur, update the operative unread table
	if (f_chngd)
		us_err = NSFDbSetUnreadNoteTable( h_db, pc_userNm, us_lenUserNm, FALSE, 
															h_unrdOrig, h_unrd);

errJump:
	//free allocated resources, as necessary
	if (h_unrdOrig)
		if (( us_error = IDDestroyTable( h_unrdOrig)) && !us_err)
			us_err = us_error;
	if (( us_error = IDDestroyTable( h_unrd)) && !us_err)
		us_err = us_error;

	return us_err;
} //xs_markRead(


/** xs_vetFolderCtx( ***
Handles the determining and resetting of the view/folder context associated 
with a document currently being shown to the user in the Notes R5 user 
interface. The view/folder context allows the @Commands "@Command( [Folder])" 
and "@Command( [EditClear])" to function with the parent view/folder from which 
the document was opened as well as with the document itself. In terms of 
immediately obvious effects, with @Command( [Folder]) this means that if the 
parent view/folder is a folder, the "Move" button will be enabled. And with 
@Command( [EditClear], it means that the view line associated with the document 
will be marked with the trash icon.

The ability to reset the view/folder context is useful when the document 
currently being shown to the user was opened programmatically, not directly by 
the user herself through the view/folder. Opening documents programmatically 
does not populate a view/folder context, so the @Commands noted above operate 
differently in that their functioning does not interact with a parent 
view/folder as described: the Move button in the folder dialog is never 
enabled, and no trash icon mark will be placed as the user might expect.

NOTE: The memory mapping and manipulation conducted by this procedure was 
arrived at purely by means of reverse-engineering the Notes user-interface DLL 
nnotesws.dll. Naturally, this approach is a "hack" that would have been avoided 
if it were possible to accomplish the aims of the procedure in another way. As 
with most any hack, the approach is prone to maintenance problems as product 
changes or upgrades occur. The procedure has been verified to work with Notes 
R5.0.2 and R5.0.4, and cannot be guaranteed to succeed with other (or future) 
versions of Notes.

--- parameters & return -----
pnid: Input & Output. Address of variable containing the NoteID of the parent 
	view/folder of the document currently being shown to the user. If variable 
	is null, it signifies that procedure should populate the variable with the 
	NoteID found within the workspace context maintained by the Notes system. 
	If variable is non-null, it's value is written to the workspace context 
	provided that the context currently has that value as null. That is, the 
	procedure will not allow a non-blank value to be overwritten.
pus: Input & Output: Address of variable containing the type-value of the 
	parent view/folder. If the view/folder NoteID is being written to the 
	workspace context, the type-value held by this variable will be written as 
	as well. If the view/folder NoteID is being output to the variable pointed 
	to by the pnid argument, the type-value will also be output.
RETURN: ms_VB_TRUE if procedure encountered no errors; ms_VB_FALSE otherwise

--- revision history --------
9/6/02 PR: listing format adjustment
11/14/00 PR: created			*/
short xs_vetFolderCtx( NOTEID *const pnid, 
						short *const  pus)	{
	//static for speed
	static const char  pc_CLASSNM_SBPRG_FRMST[] = "FramesetSubprog", 
						pc_CLASSNM_SBPRG_NOTES[] = "NotesSubprog";
	static const UINT  ui_OFST_T16_NID_VW = 0x98, ui_OFST_T16_VW_TYP = 0xDA;

	HWND  h;
	char  pc[ 21];
	BYTE * puc_tsbprg, * puc_t16;
	NOTEID  nid;

	//if parameters are obviously invalid, short-circuit with failure
	if (!( pnid && pus))
		goto errJump;

	//Get address of subprogram structure associated with the main message 
	//	window. Do so in a consistent way of navigating to the first parent 
	//	frameset subprogram, and then down to the first child Notes subprogram.
	if (!( h = GetFocus()))
		goto errJump;
	if (!( h = GetParent( h)))
		goto errJump;
	if (!( h = GetParent( h)))
		goto errJump;
	if (!GetClassName( h, pc, sizeof( pc)))
		goto errJump;
	if (strcmp( pc, pc_CLASSNM_SBPRG_FRMST) != ei_SAME)	{
		if (!( h = GetParent( h)))
			goto errJump;
		if (strcmp( pc, pc_CLASSNM_SBPRG_FRMST) != ei_SAME)
			goto errJump;
	}
	if (!( h = FindWindowEx( h, NULL, pc_CLASSNM_SBPRG_NOTES, NULL)))
		goto errJump;
	if (!( puc_tsbprg = (BYTE *) GetWindowLong( h, 0)))
		goto errJump;

	//if we've been asked to output the current view/folder context...
	puc_t16 = (BYTE *) *(long *) *(long *) (puc_tsbprg + 0x8E);
	nid = *(long *) (puc_t16 + ui_OFST_T16_NID_VW);
	if (!*pnid)	{
		//do so
		*pnid = nid;
		*pus = *(puc_t16 + ui_OFST_T16_VW_TYP);
	//else, provided that we're not overwriting a current context, populate the 
	//	current document context with the folder context we acquired in a prior 
	//	call
	}else if (!nid)	{
		*(NOTEID *) (puc_t16 + ui_OFST_T16_NID_VW) = *pnid;
		*(puc_t16 + ui_OFST_T16_VW_TYP) = (BYTE) *pus;
	} //if (!*pnid)

	return ms_VB_TRUE;

errJump:
	return ms_VB_FALSE;
} //xs_vetFolderCtx(


/** xs_DecryptVerifyNote( ***
Purpose is to PGP decrypt/verify the PGP encrypted/signed content present in 
the specified note.

--- parameters & return ------
h_NOTE: handle to the note to undergo PGP decoding
pc_FLDNM: address of string telling the name of the rich-text field to be used 
	in the decryption/verification
pc_ITMNM_FLGS: Optional. Address of string giving the name of the item holding 
	the PGP-state flags for the message. If null, procedure may be less 
	efficient in preparing the decoded content for the Notes client currently 
	being used.
ps_msgChngd: address of the variable of VisualBasic integer type in which to 
	return whether message content was changed (ms_VB_TRUE) or not (ms_VB_FALSE)
RETURN: eus_SUCCESS if no error occured. If the user canceled a PGP dialog, 
	ei_USER_ABORT. Otherwise !eus_SUCCESS or, if available, the Notes API error 
	code.

--- suggested enhancement ----
3/14/03 PR: if the Tempest viewer is to be used, figure out how to handle 
	properly the case of mulitple or recursive PGP-ASCII blocks being present 
	in the content

--- revision history ---------
3/14/03 PR
+ logic enhancement in support of Notes 6 compatibility, including concomitant 
  signature change
+ logic enhancement in support of enabling the Tempest viewer in the plug-in

9/6/02 PR: listing format adjustment, minor documentation change, token renaming
11/14/00 PR: minor token renaming
9/12/99 PR: documentation adjustment
2/2/99 PR: created			*/
short xs_DecryptVerifyNote( const NOTEHANDLE  h_NOTE, 
							const char  pc_FLDNM[], 
							const char  pc_ITMNM_FLGS[], 
							short *const  ps_msgChngd)	{
	const BYTE * puc_flgs = NULL;
	WORD  us_typ;
	BLOCKID  bid_flgs, bid = ebid_NULLBLOCKID;
	DWORD  ul_objId, ul_lenFlgs, ul_len;
	RtfCursor  t_crsr;
	RtfContext  t_ctx;
	BOOL  f_tmpst, f_goForRtfObj, f_noMoreState = FALSE;
	STATUS  us_err;
	int  i_err, i_errNonFatal = NULL;

	if (!( h_NOTE && pc_FLDNM && ps_msgChngd))
		return !eus_SUCCESS;

	//default the message-changed flag to say that no change has occurred
	*ps_msgChngd = ms_VB_FALSE;

	//if caller has provided PGP-state context, make it accessible
	if (pc_ITMNM_FLGS && *pc_ITMNM_FLGS)
		if (us_err = eus_OpenTextItem( h_NOTE, pc_ITMNM_FLGS, &puc_flgs, 
											&bid_flgs, &ul_lenFlgs, &us_typ))
			if (!( us_err == ERR_ITEM_NOT_FOUND || us_err == ERR_ITEM_DATATYPE))
				return us_err;

	//initialize resources associated with the rich-text handling we're going 
	//	to do
	if (us_err = eus_InitializeRtfContext( h_NOTE, pc_FLDNM, &t_crsr, &t_ctx))
		goto errJump;

	//determine whether user wants Tempest viewer used when showing decoded 
	//	content, and therefore whether any Notes rich-text version of the 
	//	content should be ignored (Tempest only does ASCII)
	f_goForRtfObj = !(f_tmpst = ef_alwaysUseTempest());

	//if the special PGP-Armored file attachment containing Notes rich-text is 
	//	present on the note...
	if (!f_tmpst && puc_flgs)
		if (us_typ == TYPE_TEXT_LIST)
			f_goForRtfObj = ef_TextListContainsEntry( puc_flgs, TRUE, 
										mpc_PGPFLG_HAS_RTF_ATTCH, NULL, NULL);
		else
			if (f_goForRtfObj = (ul_lenFlgs == mui_LEN_PGPFLG_HAS_RTF_ATTCH ? 
									memcmp( puc_flgs, mpc_PGPFLG_HAS_RTF_ATTCH, 
									mui_LEN_PGPFLG_HAS_RTF_ATTCH) == 
									ei_SAME : FALSE))
				f_noMoreState = TRUE;
	if (f_goForRtfObj && (us_err = us_LocatePgpRtfAttachment( t_crsr, &t_ctx, 
											h_NOTE, &ul_objId, &ul_len, &bid)))
		i_errNonFatal = us_err;
	if (bid.pool && !i_errNonFatal)	{
		BYTE * puc = NULL;

		//PGP decode the message using the special rich-text attachment's 
		//	content
		if (us_typ == TYPE_TEXT)	{
			puc = malloc( ul_lenFlgs + 1);
			memcpy( puc, puc_flgs, ul_lenFlgs);
			puc[ ul_lenFlgs] = NULL;
		}
		i_err = i_PgpDecodeUsingRichTextObj( ul_objId, ul_len, bid, h_NOTE, 
										pc_FLDNM, f_noMoreState || !puc_flgs ? 
										NULL : us_typ == TYPE_TEXT_LIST ? 
										puc_flgs : puc, &t_ctx, &i_errNonFatal);
		if (puc)
			free( puc);
		if (i_err && !i_errNonFatal)
			goto errJump;

		//if no error occurred, inform the caller that the message content 
		//	changed
		if (!i_errNonFatal)
			*ps_msgChngd = ms_VB_TRUE;
	} //if (bid.pool && !i_errNonFatal)

	//if the user wants the Tempest viewer used when showing decoded content or 
	//	if the special rich-text version does not exist or if a non-fatal error 
	//	occurred in decoding that version, decode the message's first 
	//	PGP-ASCII block
	if (f_tmpst || !bid.pool || i_errNonFatal)	{
		BOOL  f_MsgChanged;
		if (i_err = i_PgpDecodeUsingAsciiText( h_NOTE, pc_FLDNM, f_tmpst, 
												t_crsr, &t_ctx, &f_MsgChanged))
			goto errJump;

		//if it's true, inform the caller that the message content did change
		if (f_MsgChanged)
			*ps_msgChngd = ms_VB_TRUE;
	} //if (!bid_itm.pool || i_errNonFatal)

	if (i_errNonFatal)	{
		const char *const  ppc_MSG_PART[] = {"An error occurred (", ") "
									"during the attempt to\nPGP decode a "
									"rich-text version of this message.\nThe "
									"plain-text version will be used instead."};
		char  pc_msg[ 255];

		sprintf( pc_msg, "%s%i%s", ppc_MSG_PART[0], i_errNonFatal, 
															ppc_MSG_PART[1]);
		MessageBox( eh_mainWnd, pc_msg, epc_APPNM, MB_OK | MB_ICONINFORMATION);
		i_err = us_err = eus_SUCCESS;
	} //if (i_errNonFatal)

errJump:
	ef_FreeRtfContext( &t_ctx);
	if (puc_flgs)
		OSUnlockBlock( bid_flgs);

	//if no errors occurred, return that procedure was successful; otherwise 
	//	return an appropriate error code
	return (short) (us_err + i_err);
} //xs_DecryptVerifyNote(


/** i_PgpDecodeUsingAsciiText( ***

--- parameters & return ------

RETURN: eus_SUCCESS if no error occured; ... otherwise

--- suggested enhancement ----
10/11/03 PR: see inlined to-do

--- revision history ---------
10/11/03 PR: Logic adjustment to allow special wrapping only of attachments 
	_following_ the ASCII block replacement, a kludge workaround to bug in 
	trying to do such wrapping of attachments that precede such a replacement

3/14/03 PR
+ signature adjustment and logic enhancement in support of enabling the Tempest 
  viewer in the plug-in
+ logic enhancement to provide better handling of input buffers 64K or greater 
  in size
+ token renaming

9/6/02 PR
+ added special attachment-handling for PGP-encoded attachments, causing slight 
  signature change
+ logic enhancement to support high-ASCII (international) characters in message 
  body
+ minor documentation adjustment, listing format adjustment, token renaming

9/12/99 PR: code adjustment associated with an improvement to handling of 
	public-key decoding
1/24/99 PR: created			*/
//DOC!!
static int i_PgpDecodeUsingAsciiText( const NOTEHANDLE  h_NOTE, 
										const char  pc_FLDNM[], 
										const BOOL  f_TMPST_ALWYS, 
										RtfCursor  t_crsr, 
										RtfContext *const  pt_ctx, 
										BOOL *const  pf_MsgChanged)	{
	DWORD  ul_len, ul, ul_, ul_lenBlk;
	char * pc_blk, * pc_inp = NULL, * pc_inpOs = NULL, 
			* pc_outpOs = NULL, * pc_outp = NULL;
	BOOL  f_tmpst = f_TMPST_ALWYS, f_fail;
	size_t  ui_lenOutp;
	WORD  us, us_;
	STATUS  us_err = eus_SUCCESS;
	int  i_err = NULL;

	//Get the textual content of the rich-text field along with its length. If 
	//	no content exists, short-circuit with success. (Remember, 
	//	eul_GetRtfText() returns the size of the buffer allocated, not the 
	//	length of the null-terminated string.) The content needs to be 
	//	translated to the native character set because clear-signed text may 
	//	include extended characters.
	if (eul_ERR_FAILURE == (ul_len = eul_GetRtfText( pt_ctx, NULL, TRUE, 
																	&pc_inp)))
		return !eus_SUCCESS;
	if (ul_len <= 1)
		goto errJump;
	if (!(pc_inpOs = malloc( ul = ul_ = ul_len)))	{
		i_err = -11999;		//kPGPError_OutOfMemory
		goto errJump;
	}
	pc_inpOs[ ul_len - 1] = NULL;
	do	{
		us = ul > MAXWORD ? MAXWORD : (WORD) ul;
		if (f_fail = !(us_ = OSTranslate( OS_TRANSLATE_LMBCS_TO_NATIVE, 
											pc_inp + ul_len - ul, (WORD) (us - 
											1), pc_inpOs + ul_len - ul_, us)))
			goto errJump;
	} while (ul_ -= us_, (ul -= us - 1) > 1);

	//PGP decode the content. If the Tempest viewer is not requested, only the 
	//	portion of the content containing the first PGP-encoded block will be 
	//	decoded.
	if (i_err = ei_FindAndDecodePgpBlock( &pc_inpOs, ul_len, &f_tmpst, &pc_blk, 
										&ul_lenBlk, &pc_outpOs, &ui_lenOutp))
		goto errJump;

	//if output was generated by the decoding...
	if (pc_outpOs)
		//if the Tempest viewer is not slated for use...
		if (!f_tmpst)	{
			size_t  ui = ++ui_lenOutp, ui_;
			WORD  us, us_;

			//replace the PGP-encoded block in the rich-text field with the 
			//	decoded output
			if (!( pc_outp = malloc( ui_ = ui_lenOutp + 0x100)))
				goto errJump;
			do	{
				us = ui > MAXWORD - 0x100 ? MAXWORD - 0x100 : (WORD) ui;
				if (f_fail = !(us_ = OSTranslate( OS_TRANSLATE_NATIVE_TO_LMBCS, 
											pc_outpOs + ui_lenOutp - ui, (WORD) 
											(us - 1), pc_outp + ui_lenOutp + 
											0x100 - ui_, (WORD) (us + 0x100))))
					goto errJump;
				if (f_fail = us_ == us + 0x100)
					goto errJump;
			} while (ui_ -= us_, (ui -= us - 1) > 1);
			if (us_err = us_ReplaceRichAsciiLines( pc_inpOs, pc_blk, ul_lenBlk, 
													pc_outp, &t_crsr, pt_ctx))
				goto errJump;

			//if the note contains any attachments, wrap PGP-encoded 
			//	attachments within special-handling hotspots
//TODO: Support all attachments on the message, not just those following the 
//	span replacement above. Requires ability to do the wrapping on attachments 
//	found w/i "virtual" items.
if (t_crsr.puc_location)
			if (NSFNoteHasObjects( (NOTEHANDLE) h_NOTE, NULL))
				if (us_err = us_ActionWrapPgpAttachments( h_NOTE, t_crsr, 
																		pt_ctx))
					goto errJump;

			//commit to note the changes made to the rich-text field
			if (us_err = eus_CommitChangedRtf( h_NOTE, pc_FLDNM, pt_ctx))
				goto errJump;

			//inform the caller that the message content did change
			*pf_MsgChanged = TRUE;
		//else show the decoded content in the Tempest viewer
		}else
			eui_ShowInTempestWnd( pc_outpOs, !f_TMPST_ALWYS);

errJump:
	//free any memory allocation made by eul_GetRtfText() and free all 
	//	resources devoted to this instance of rich-text handling
	if (pc_outp)
		free( pc_outp);
	if (pc_outpOs)
		e_FreePgpMem( pc_outpOs);
	if (pc_inpOs)
		free( pc_inpOs);
	if (pc_inp)
		free( pc_inp);

	return us_err + f_fail + i_err;
} //i_PgpDecodeUsingAsciiText(


/** us_ActionWrapPgpAttachments( ***
Wrap attachments that already seem to be PGP-encoded with a rich-text action 
hotspot that enables special PGP handling.

--- parameters & return ------
h_NOTE: handle to the note being operated on
t_crsr: rich-text cursor set to where the search should start for attachemnt 
	hotspots whose parent attachments should be encoded
pt_ctx: Input & Output. Address of the rich-text context structure 
	describing the rich-text field to be searched and updated with PGP-encoded 
	attachment-action hotspots. Structure may undergo change even if an error 
	occurs.
RETURN: eus_SUCCESS if no error occured; the Notes API error code otherwise

--- suggested enhancement ----
9/6/02 PR
+ Add to subform QueryOpen code that notes in lt_pgp item whether and which 
  PGP-encoded attachments appear below-the-line in a message that does not 
  include the special PGP-encoded rich-text attachment. This state would be 
  ascertained in xus_SetupPgpAttachments() and noted with something like 
  'BL-file1.ext.pgp/file2.ext.asc...' and, for not-applicable or none 'BL-/' 
  (or instead of BL is there already another PGP flag that can be extended, 
  e.g. AR?). Then this procedure could be more efficient and not have to search 
  through the entire rich-text field to determine if it needs to wrap certain 
  below-the-line attachments.
+ get rid of PGP-development shortcuts

--- revision history ---------
10/11/03 PR
+ minor logic adjustment to allow success short-circuit if no attachments are 
  available to process
+ logic safety improvement to note that a valid input rich-text cursor is 
  required
+ minor documentation improvement

3/14/03 PR
+ logic adjustment to take advantage of f_PgpExtension()
+ support of change to ef_AddStringNodeFifo() function, renamed to 
  ef_AddStringNode()
+ minor documentation adjustment, listing format adjustment, token renaming, 
  minor signature adjustment to provide appropriate constness

9/6/02 PR: created			*/
static STATUS us_ActionWrapPgpAttachments( const NOTEHANDLE  h_NOTE, 
											RtfCursor  t_crsr, 
											RtfContext *const  pt_ctx)	{
	char * pc_objNm, * pc_fileNm;
	RtfSpan  t_spn;
	StringNode * pt_notBelow = NULL, * pt_nd = NULL;
	BLOCKID  bid = ebid_NULLBLOCKID;
	char  pc[ mi_MAXLEN_ATTCH_OBJNM];
	WORD  us_typ;
	STATUS  us_err;
	BOOL  f_fail = FALSE;

	_ASSERTE( t_crsr.puc_location && t_crsr.us_recLength && pt_ctx);

	//note whether the note's PGP-state item contains information on the note's 
	//	below-the-line PGP-encoded attachments state

	//if a file-attachment hotspot isn't found at or beyond our starting point, 
	//	short-circuit with success
	if (!ef_CursorToAttachmentHotspot( &t_crsr, pt_ctx, FALSE, &t_spn, 
														&pc_fileNm, &pc_objNm))
		return eus_SUCCESS;
	_ASSERTE( t_crsr.puc_location ? pc_objNm && *pc_objNm && pc_fileNm && 
															*pc_fileNm : TRUE);

	//loop until no further file-attachment hotspots exist in the rich-text 
	//	field
	if (!*mpc_fileNmPgpRtf)
		strcat( strcpy( mpc_fileNmPgpRtf, mpc_ROOTFILENM_PGP_RTF), 
														mpc_PGP_ARMOR_EXT_ASC);
	while (t_crsr.puc_location)	{
		//if we don't know the note's full below-the-line PGP-encoded 
		//	attachments state, note this attachment's object name
if (TRUE)	{
			if (!ef_AddStringNode( pc_objNm, TRUE, TRUE, &pt_nd))	{
				us_err = ERR_MEMORY;
				goto errJump;
			}
			if (!pt_notBelow)
				pt_notBelow = pt_nd;
		} //if (

		//if the attachment seems to be PGP encoded and is not the special 
		//	encapsulated rich-text attachment, wrap a PGP action hotspot around 
		//	the file-attachment hotspot, if necessary
		if (stricmp( pc_fileNm, mpc_fileNmPgpRtf) != ei_SAME && f_PgpExtension( 
												pc_fileNm, strlen( pc_fileNm)))
			if (us_err = us_ActionWrapAttachment( &t_spn, pc_fileNm, pc_objNm, 
												h_NOTE, FALSE, NULL, pt_ctx))
				goto errJump;

		//advance the rich-text cursor to the next file-attachment hotspot
		if (f_fail = !ef_CursorToAttachmentHotspot( &t_crsr, pt_ctx, TRUE, 
												&t_spn, &pc_fileNm, &pc_objNm))
			goto errJump;
	} //while (t_crsr.puc_location)

	//if we know the note's full below-the-line PGP-encoded attachments state...
if (FALSE)
		//if attachments are to be wrapped, wrap them
		;
	//else process any attachments beyond those wrapped above...
	else	{
		UINT  ui = NULL;

		//if beginning cursor did not start at the beginning of the rich-text 
		//	field...
			//for each attachment found from the beginning of the field up to 
			//	where the beginning cursor points, add it's object name to the 
			//	do-not-process list

//PGP development shortcut: assumption here that any attachments beyond those 
//	wrapped above are below-the-line attachments
		//for each seeming attachment associated with the note...
		if (us_err = eus_getAttachInfoNext( h_NOTE, NULL, &bid, pc, NULL, 
													NULL, NULL, &us_typ, NULL))
			goto errJump;
		while (bid.pool)	{
			//if the object is a normal attachment, and its name is not in the 
			//	do-not-process list, and it's not the special encapsulated 
			//	rich-text attachment...
			if (!(us_typ == HOST_STREAM || us_typ == HOST_OLELIB || 
											us_typ == HOST_BYTEARRAY_EXT || 
											us_typ == HOST_BYTEARRAY_PAGE) && 
											!(ef_ListContainsString( pc, 
											pt_notBelow, FALSE) || stricmp( pc, 
											mpc_fileNmPgpRtf) == ei_SAME))
				//Wrap a PGP action hotspot around a file-attachment hotspot 
				//	created for the attachment. If this is the first time 
				//	through for this display event, add a new paragraph first 
				//	in which to display the hotspot.
				if (us_err = us_ActionWrapAttachment( NULL, pc, pc, h_NOTE, 
											!ui++ ? TRUE : FALSE, NULL, pt_ctx))
					goto errJump;

			//move on to the next object
			if (us_err = eus_getAttachInfoNext( h_NOTE, NULL, &bid, pc, 
											NULL, NULL, NULL, &us_typ, NULL))
				goto errJump;
		} //while (bid.pool)
	} //if (

errJump:
	if (pt_notBelow)
		e_FreeList( &pt_notBelow, TRUE);

	return us_err + f_fail;
} //us_ActionWrapPgpAttachments(


/** f_PgpExtension( ***
Tell whether a given string ends with one of the PGP file extensions.

--- parameter & return ----
PC: address of string to be tested
RETURN: TRUE if the string ends with one of the PGP file extensions; FALSE 
	otherwise

--- revision history ------
3/14/03 PR: created		*/
static __inline BOOL f_PgpExtension( const char  PC[], 
										const size_t  UI)	{
	_ASSERTE( PC && *PC && UI);

	return strnicmp( PC + UI - mui_LEN_ARMOR_EXT_ASC, mpc_PGP_ARMOR_EXT_ASC, 
									mui_LEN_ARMOR_EXT_ASC) == ei_SAME || 
									strnicmp( PC + UI - mui_LEN_ARMOR_EXT_PGP, 
									mpc_PGP_ARMOR_EXT_PGP, 
									mui_LEN_ARMOR_EXT_PGP) == ei_SAME;
} //f_PgpExtension(


/** i_PgpDecodeUsingRichTextObj( ***
Produces the rich-text version of the message by decoding the special 
PGP-encoded rich-text attachment.

--- parameters & return ----
ul_OBJID: Provisionally Optional. The identifer associated with the 
	uncompressed special attachment being sought. Required if bid_OBJ_ITM input 
	not provided.
ul_LEN_OBJ: the size of the attachment
bid_OBJ_ITM: Provisionally Optional. The information structure used by Notes in 
	working with the file-attachment item that associates the note with the 
	attachment. Required if ul_OBJID input not provided.
h_NOTE: handle to the note associated with the attachment and the rich-text 
	field to be superseded by the attachment's decoded content
pc_FLDNM: address of string giving the name of the rich-text field to be 
	replaced by the attachment's decoded content
puc_FLGS: Optional. Address of string giving the name of the item holding the 
	PGP-state flags for the message. If null, procedure may be less efficient 
	in preparing the decoded content for the Notes client currently being used.
pt_ctx: Input & Output. Address of opaque information structure describing the 
	rich-text environment we're operating in. Structure will be updated as a 
	result of this call.
pi_errNonFatal: Optional Output. Address of variable to receive a copy of the 
	error code if the error occurred before the state of the rich-text field 
	was altered in a way that can't or won't be rolled back. If this output is 
	set, caller may choose to try to communicate the message contents in 
	another way, like by using a plain-text version instead of this rich-text 
	version. If null, this functionality will be suppressed.
RETURN: eus_SUCCESS if no errors occur; otherwise the Notes API or PGP error 
	code

--- revision history -------
7/21/03 PR: logic enhancement to support Notes client rewrites, in Notes R5 
	style, of the PGP action-attachment hotspots the plug-in constructs in 
	Notes R4 style

3/14/03 PR
+ logic enhancement to support Notes 6 compatibility, associated signature 
  adjustment
+ token renaming

10/7/00 PR: minor documentation adjustment

3/20/00 PR
+ accommodated change in signature to ei_PgpDecodeBuffer()
+ improved safety code

9/12/99 PR: logic adjustment to accommodate compressed objects (forced into 
	this because the Domino SMTP MTA may decide to compress)
12/15/98 PR: created		*/
static int i_PgpDecodeUsingRichTextObj( const DWORD  ul_OBJID, 
										const DWORD  ul_LEN_OBJ, 
										const BLOCKID  bid_OBJ_ITM, 
										const NOTEHANDLE  h_NOTE, 
										const char  pc_FLDNM[], 
										const BYTE *const  puc_FLGS, 
										RtfContext *const  pt_ctx, 
										int *const  pi_errNonFatal)	{
	HANDLE  h;
	BYTE * puc;
	DWORD  ul;
	const char * pc_output = NULL, * pc;
	BOOL  f_hasPgpAttchs, f_noMoreState = FALSE;
	STATUS  us_err;
	int  i_err;

	_ASSERTE( h_NOTE && ul_LEN_OBJ && bid_OBJ_ITM.pool && pc_FLDNM && pt_ctx);

	if (pi_errNonFatal)
		*pi_errNonFatal = FALSE;

	//read the special attachment into a memory buffer
	if (us_err = eus_getObjectContentsInBuffer( ul_OBJID, ul_OBJID ? 
											ebid_NULLBLOCKID : bid_OBJ_ITM, 
											ul_LEN_OBJ, h_NOTE, NULL, &h))	{
		if (pi_errNonFatal)
			*pi_errNonFatal = us_err;
		return us_err;
	}

	//PGP decode the buffer, then, our work with it done, free the input buffer
	puc = OSLockObject( h);
	i_err = ei_PgpDecodeBuffer( puc, ul_LEN_OBJ, TRUE, &pc_output, &ul);
	OSUnlockObject( h);
	OSMemFree( h);
	if (i_err)	{
		if (pi_errNonFatal && i_err != ei_USER_ABORT)
			*pi_errNonFatal = i_err;
		goto errJump;
	}

	//Replace the current rich-text field with the CD records in the decrypted 
	//	buffer. From here on all errors are fatal because the state of the 
	//	rich-text tracking context may well have changed.
	if (us_err = eus_ReplaceRtfWithCdStream( pc_output, ul, pt_ctx))
		goto errJump;

	//commit to note the replacement rich-text field (even though work on any 
	//	attachment hotspots may occur just downstream)
	if (us_err = eus_CommitChangedRtf( h_NOTE, pc_FLDNM, pt_ctx))
		goto errJump;

	//if not yet done, determine whether we're running Notes 6
	if (!mus_build)	{
		DBHANDLE  h;
		NSFNoteGetInfo( (NOTEHANDLE) h_NOTE, _NOTE_DB, &h);
		NSFDbGetBuildVersion( h, &mus_build);
		mf_Notes6 = mus_build >= mus_BLD_1ST_6;
	}

	//if we're running Notes 6 and PGP-state info has been provided, determine 
	//	if the replacement rich-text includes PGP-encoded attachment hotspots
	if (mf_Notes6 && puc_FLGS)
		if (*(WORD *) puc_FLGS == TYPE_TEXT_LIST)
			f_hasPgpAttchs = ef_TextListContainsEntry( puc_FLGS, TRUE, 
											mpc_PGPFLG_HAS_ARMOR, NULL, NULL);
		else	{
			f_hasPgpAttchs = strcmp( puc_FLGS, mpc_PGPFLG_HAS_ARMOR) == ei_SAME;
			f_noMoreState = TRUE;
		}

	//If we care and know or aren't sure whether the replacement rich-text 
	//	includes PGP-encoded attachment hotspots. (If we're running a 
	//	pre-Notes 6 client we don't care because the only ill effect of PGP 
	//	Notes 6 attachment hotspot encoding within a pre-Notes 6 environment is 
	//	that the fallback to regular attachment handling [Detach/Launch/View] 
	//	is not provided if the special wrapper PGP action hotspot fails.)
	if (mf_Notes6 && (f_hasPgpAttchs || !puc_FLGS))	{
		//if there's further PGP state info to investigate, determine whether 
		//	that state includes indication of the type of PGP-encoding done on 
		//	the attachments in the decoded rich-text content
		if (!f_noMoreState)
			if (ef_TextListContainsEntry( puc_FLGS, TRUE, mpc_PGPFLG_HOTSPOT_6, 
																	NULL, NULL))
				pc = mpc_PGPFLG_HOTSPOT_6;
			else if (ef_TextListContainsEntry( puc_FLGS, TRUE, 
											mpc_PGPFLG_HOTSPOT_5, NULL, NULL))
				pc = mpc_PGPFLG_HOTSPOT_5;

		//if we're dealing with hotspots that are or may be encoded for 
		//												pre-Notes 6 clients...
		if (pc != mpc_PGPFLG_HOTSPOT_6)	{
			RtfCursor  t_crsr;
			RtfSpan  t_spnFrmla, t_spnAtch;
			BOOL  f_fail;

			//if we seem to have found a pre-Notes 6 style 
			//	PGP-action-attachment hotspot... (we tolerate any faults that 
			//	may occur during our fix-ups)
			if (!( (us_err = eus_ConstructRtCursor( pt_ctx, &t_crsr)) || 
									(us_err = eus_CursorToFormulaActionAttach( 
									&t_crsr, pt_ctx, FALSE, &t_spnFrmla, 
									&t_spnAtch, NULL, &pc)) || (f_fail = 
									!t_crsr.puc_location)))
				//for each such find...
				do	{
					//if the attachment doesn't have a PGP extension, move on 
					//	to the next find
					if (!f_PgpExtension( pc, strlen( pc)))
						continue;

					//collapse the attachment hotspot so the PGP action will 
					//	behave properly in Notes 6
					if (us_err = eus_CollapseToEndAttachWrap( &t_spnAtch, 
																		pt_ctx))
						break;					
				} while (!(us_err = eus_CursorToFormulaActionAttach( &t_crsr, 
										pt_ctx, TRUE, &t_spnFrmla, &t_spnAtch, 
										NULL, &pc)) && t_crsr.puc_location);

			//if no errors occurred, commit to note the fix-up changes made
			if (!( us_err || f_fail))
				if (us_err = eus_CommitChangedRtf( h_NOTE, pc_FLDNM, pt_ctx))
					goto errJump;
		} //if (pc != mpc_PGPFLG_HOTSPOT_6)
	} //if (mf_Notes6 && (f_hasPgpAttchs || !puc_FLGS))

	//remove the item used by the note to point to the special attachment
	us_err = NSFNoteDetachFile( (NOTEHANDLE) h_NOTE, bid_OBJ_ITM);

errJump:
	if (pc_output)
		e_FreePgpMem( (char *) pc_output);

	return us_err + i_err;
} //i_PgpDecodeUsingRichTextObj(


/** us_ReplaceRichAsciiLines( ***
Replaces the first matching text block in the given rich-text field with the 
given null-terminated replacement text block.

--- parameters & return ----
pc_CTNT: Address of a null-terminated ASCII-text version of the specified 
	rich-text field. This input allows procedure to find the correct occurrence 
	of pc_BLK within the rich-text field.
pc_BLK: Address of the beginning of the block of CRLF-delimited text lines in 
	the rich-text field that is to be replaced. (Address must therefore fall 
	within the pc_CTNT string.) The first line of the block is used to search 
	for a matching position within the rich-text field.
ul_LEN_BLK: Length of text to be replaced. Value must therefore not offset 
	beyond the end of the pc_CTNT string.
pc_REPL: Address of null-terminated text block to replace the block within the 
	rich-text field identified by pc_BLK. If necessary, a CRLF will be appended 
	to maintain the concept of replacing _lines_.
pt_crsr: Input & Output. Address of rich-text cursor from which to start 
	searching for the specified text block (pc_BLK) within the rich-text field. 
	On successful return from call, cursor is reset to point to the CD record 
	following the replacement.
pt_rtCtx: Input & Output. Address of opaque structure describing the current 
	state of the rich-text field involved in the operation.
RETURN: eus_SUCCESS if no error occured; the Notes API error code otherwise

--- revision history -------
9/6/02 PR
+ logic enhancement to allow output of rich-text position following the 
  replacement block
+ improved procedure name, much token renaming, improved call-safety checking
+ completed standard documentation
+ listing format adjustment

7/16/99 PR: changed default nullification of end-cursor member of the RtfSpan 
	structure passed to eus_ReplaceRtfSpanText() to use the standard 
	null-cursor flag
11/23/98 PR: created		*/
static STATUS us_ReplaceRichAsciiLines( const char *const  pc_CTNT, 
										const char *const  pc_BLK, 
										const DWORD  ul_LEN_BLK, 
										const char *const  pc_REPL, 
										RtfCursor *const  pt_crsr, 
										RtfContext *const  pt_rtCtx)	{
	long  l;
	const char * pc;
	char * pc_cmp = NULL, * pc_ = NULL;
	WORD  us_offst, us = NULL;
	UINT  ui;
	RtfSpan  t_rtfSpn;
	STATUS  us_err;
	BOOL  f_fail;
	int  i_err = NULL;

	_ASSERTE( pc_CTNT && pc_BLK && ul_LEN_BLK && pc_BLK >= pc_CTNT && pc_BLK + 
								ul_LEN_BLK <= pc_CTNT + strlen( pc_CTNT) && 
								pc_REPL && pt_crsr->puc_location && pt_rtCtx);

	//Note the first line of the text block to be replaced. This will be used 
	//	to find the start of this block within the actual rich-text field.
	if (f_fail = !(BOOL) (pc_cmp = malloc( l = strstr( pc_BLK, epc_CRLF) - 
																pc_BLK + 1)))
		goto errJump;
	memcpy( pc_cmp, pc_BLK, l - 1);
	pc_cmp[ l - 1] = NULL;

	//starting from the caller-specified position in the rich-text field, loop 
	//	to the start of the text block to be replaced...
	pc = pc_CTNT - 1;
	do	{
		//locate the next instance of the sought-for line in the rich-text field
		if (f_fail = !ef_CursorToStringStart( pc_cmp, TRUE, *pt_crsr, us, 
												pt_rtCtx, pt_crsr, &us_offst))
			goto errJump;
		if (f_fail = !(BOOL) pt_crsr->puc_location)
			goto errJump;

		//move to the corresponding line in the regular-text version of the 
		//	content
		if (f_fail = !(BOOL) (pc = strstr( pc + 1, pc_cmp)))
			goto errJump;

		//if the line we found isn't the actual beginning of the sought-for 
		//	text block, loop for a further pass
		us = us_offst + 1;
	} while (pc < pc_BLK);

	//if necessary, tack a CRLF onto the replacement text to maintain the 
	//	concept of replacing lines with lines
	if (strcmp( pc_REPL + (ui = strlen( pc_REPL)) - eui_LEN_CRLF, epc_CRLF) != 
																ei_SAME)	{
		pc_ = malloc( ui + eui_LEN_CRLF + 1);
		strcat( strcpy( pc_, pc_REPL), epc_CRLF);
	}

	//replace the ASCII text block identified within the rich-text field with 
	//	the replacement content
	t_rtfSpn.t_crsrBgin = *pt_crsr;
	t_rtfSpn.us_offstBgin = us_offst;
	t_rtfSpn.t_crsrEnd.puc_location = NULL;
	us_err = eus_ReplaceRtfSpanText( &t_rtfSpn, ul_LEN_BLK, TRUE, pc_ ? pc_ : 
															pc_REPL, pt_rtCtx);
	if (pc_)
		free( pc_);
	if (us_err)
		goto errJump;

	//note for caller the position of the CD record following the replacement 
	//	text
	*pt_crsr = t_rtfSpn.t_crsrEnd;
	us_err = eus_CursorAdvance( pt_crsr, pt_rtCtx);

errJump:
	if (pc_cmp)
		free( pc_cmp);

	return us_err ? us_err : i_err || f_fail ? !eus_SUCCESS : eus_SUCCESS;
} //us_ReplaceRichAsciiLines(


/** eus_TestNoteForPgpCtnt( ***
Within the context of having been called by a Notes @Fromula, inspects the 
specified rich-text field for the existence of PGP-encoded content.

--- parameters & return ----
ppv_ARGV: address of the series of arguments provided by the PGP @DbCommand 
	used to call this DLL
ph: Output. Address of variable to receive handle to what will be the 
	@Formula's output content, a Notes text-list of PGP plug-in state flags.
pul: Output. Address of variable to receive length of the @Formula's output 
	content.
RETURN:
	eus_SUCCESS if successful
	eus_ERR_ARG_INVLD if any input is obviously invalid
	the Notes API error code otherwise

--- revision history -------
3/14/03 PR: created			*/
STATUS eus_TestNoteForPgpCtnt( void *const  ppv_ARGV[], 
								HANDLE *const  ph, 
								DWORD *const  pul)	{
	const int  i_ARG_HNDL = 0, i_ARG_FLDNM = 1;
	const char  pc_PGPFLG_HAS_ASCII[] = "AS";
	const size_t  ui_LEN_PGPFLG_HAS_ASCII = sizeof( pc_PGPFLG_HAS_ASCII) - 1, 
					ui_LEN_PGPFLG_HAS_ARMOR = sizeof( mpc_PGPFLG_HAS_ARMOR) - 1;

	double  d;
	NOTEHANDLE  h_note;
	char * pc_fldNm = NULL;
	short  s_hasAscii, s_hasArmor = FALSE;
	HANDLE  h;
	BYTE * puc;
	STATUS  us_err;

	if (!( ppv_ARGV && *ppv_ARGV && ph && pul))
		return eus_ERR_INVLD_ARG;

	//recover the handle to the calling note's session
	if (!ef_GetNumberListEntry( ppv_ARGV[ i_ARG_HNDL], TRUE, 0, &d))
		return eus_ERR_INVLD_ARG;
	h_note = (NOTEHANDLE) (DWORD) d;

	//get the name of the rich-text field to process
	if ((us_err = eus_CreateTextListEntryCopy( 0, ppv_ARGV[ i_ARG_FLDNM], TRUE, 
													&pc_fldNm)) || !pc_fldNm)
		return eus_ERR_INVLD_ARG;

	//if there's PGP-encoded content in the message, tell caller
	if (us_err = xus_TestNoteForPgpAscii( h_note, pc_fldNm, &s_hasAscii))
		goto errJump;
	if (s_hasAscii)	{
		DWORD  ul;

		if (us_err = xus_TestNoteForPgpArmor( h_note, pc_fldNm, &s_hasArmor, 
																		NULL))
			goto errJump;
		if (us_err = OSMemAlloc( NULL, ul = sizeof( WORD) + sizeof( LIST) + 
									sizeof( USHORT) + ui_LEN_PGPFLG_HAS_ASCII + 
									(s_hasArmor ? sizeof( USHORT) + 
									ui_LEN_PGPFLG_HAS_ARMOR : NULL), &h))
			return us_err;
		puc = (BYTE *) OSLockObject( h);
		*((WORD *) puc)++ = TYPE_TEXT_LIST;
		(((LIST *) puc)++)->ListEntries = 1 + !!s_hasArmor;
		*((USHORT *) puc)++ = ui_LEN_PGPFLG_HAS_ASCII;
		if (s_hasArmor)
			*((USHORT *) puc)++ = ui_LEN_PGPFLG_HAS_ARMOR;
		memcpy( puc, pc_PGPFLG_HAS_ASCII, ui_LEN_PGPFLG_HAS_ASCII);
		if (s_hasArmor)
			memcpy( puc + ui_LEN_PGPFLG_HAS_ASCII, mpc_PGPFLG_HAS_ARMOR, 
													ui_LEN_PGPFLG_HAS_ARMOR);
		OSUnlockObject( h);
		*ph = h;
		*pul = ul;
	} //if (s_hasAscii)
	free( pc_fldNm);

	return eus_SUCCESS;

errJump:
	free (pc_fldNm);
	return us_err;
} //eus_TestNoteForPgpCtnt(


/** xus_TestNoteForPgpAscii( ***
Inspects the specified rich-text field for the existence of PGP ASCII-Armor 
blocks.

--- parameters & return ------
h_NOTE: the handle to the note to be inspected
pc_FLDNM: the name of the message-body rich-text field
pus_hasPgpAscii: flag telling whether encoded ASCII was found (TRUE) or not 
	(FALSE)
RETURN:
	eus_SUCCESS if no errors occurred
	eus_ERR_INVLD_ARG if any passed-in parameter is obviously invalid
	the Notes API error code otherwise

--- suggested enhancement ----
10/13/03 PR: since procedure simply tests for PGP-block _presence_, probably 
	don't need the costly high-ASCII conversion that's currently being undergone

--- revision history ---------
10/13/03 PR: documentation correction

3/14/03 PR
+ signature change to reflect appropriate constness
+ logic enhancement to provide better handling of input buffers 64K or greater 
  in size
+ token renaming, minor documentation adjustment, minor exception-handling 
  enhancement

9/6/02 PR
+ logic enhancement to support high-ASCII (international) characters in message 
  body
+ minor documentation adjustment, listing format adjustment, token renaming, 
  exception-handling adjustment

11/18/98 PR: created		*/
STATUS xus_TestNoteForPgpAscii( const NOTEHANDLE  h_NOTE, 
								char  pc_FLDNM[], 
								short *const  ps_hasPgpAscii)	{
	RtfCursor  t_crsr;
	RtfContext  t_ctx;
	char * pc_ctnt = NULL, * pc_ctntOs = NULL;
	ULONG  ul_len, ul, ul_;
	BOOL  f_hasPgpAscii, f_fail;
	WORD  us, us_;
	STATUS  us_err;
	int  i_err = NULL;

	if (!( h_NOTE && pc_FLDNM && *pc_FLDNM && ps_hasPgpAscii))
		return eus_ERR_INVLD_ARG;

	//set default that PGP-encoded ASCII content was not found
	*ps_hasPgpAscii = ms_VB_FALSE;

	//initialize resources associated with the rich-text handling we're going 
	//	to do
	if (us_err = eus_InitializeRtfContext( h_NOTE, pc_FLDNM, &t_crsr, &t_ctx))
		return us_err;
	if (!t_crsr.puc_location)
		return eus_SUCCESS;

	//if we can't get the textual content of the rich-text field or if that 
	//	content is too short to contain a PGP block, short-circuit
	if ( (f_fail = eul_ERR_FAILURE == (ul_len = eul_GetRtfText( &t_ctx, 
										NULL, TRUE, &pc_ctnt))) || ul_len <= 1)
		goto errJump;

	//if PGP-encoded ASCII is included in the content, indicate this to caller
	if (!(pc_ctntOs = malloc( ul = ul_ = ul_len)))	{
		i_err = ERR_MEMORY;
		goto errJump;
	}
	pc_ctntOs[ ul_len - 1] = NULL;
	do	{
		us = ul > MAXWORD ? MAXWORD : (WORD) ul;
		if (f_fail = !(us_ = OSTranslate( OS_TRANSLATE_LMBCS_TO_NATIVE, 
											pc_ctnt + ul_len - ul, (WORD) (us - 
											1), pc_ctntOs + ul_len - ul_, us)))
			goto errJump;
	} while( ul_ -= us_, (ul -= us - 1) > 1);
	if (!( i_err = ei_TestForPgpAscii( pc_ctntOs, &f_hasPgpAscii)) && 
																f_hasPgpAscii)
		*ps_hasPgpAscii = ms_VB_TRUE;

errJump:
	//as necessary, free resources allocated during this procedure
	if (pc_ctntOs)
		free( pc_ctntOs);
	if (pc_ctnt)
		free( pc_ctnt);
	ef_FreeRtfContext( &t_ctx);

	return f_fail || i_err ? !eus_SUCCESS : eus_SUCCESS;
} //xus_TestNoteForPgpAscii(


/** xus_prepPgpMime( ***
Prepare the given note to be accessed and behave as a PGP/MIME encoded message 
where a user's one-click on an appropriate icon launches an entire decoding 
process, attachments included.

--- parameters & return ----
h_NOTE: handle to the note containing the specified rich-text field
pc_FLDNM: address of the name of the field holding the PGP/MIME content and 
	that should be replaced to hold the access
RETURN:
	eus_ERR_INVLD_ARG if any input is obviously invalid
	eus_SUCCESS if no error occured
	the Notes API error code otherwise

--- revision history -------
3/14/03 PR: created		*/
WORD xus_prepPgpMime( const NOTEHANDLE  h_NOTE, 
						const char  pc_FLDNM[])	{
	static const char  pc_LINK[] = "javascript:invokePgpMimeDecode()", 
						pc_TAG_PGPMIME[] = "<PGP/MIME>";

	static const BYTE * puc_PgpMimeBmp;
	static WORD  us_lenPgpMimeBmp;

	const size_t  ui_LEN_FLDNM = pc_FLDNM ? strlen( pc_FLDNM) : NULL;

	WORD  us_typ;
	BLOCKID  bid_itm, bid_ctnt;
	DWORD  ul;
	RtfContext  t_ctx;
	STATUS  us_err;
	BOOL  f_fail = FALSE;

	if (!( h_NOTE && pc_FLDNM && *pc_FLDNM))
		return eus_ERR_INVLD_ARG;

	//if it hasn't been done already, load static resources for use within the 
	//	link hotspot to be constructed
	if (!puc_PgpMimeBmp)	{
		const HRSRC h_RSRC = FindResource( eh_Instance, MAKEINTRESOURCE( 
											mi_IDR_PGP_MIME_CDS), RT_RCDATA);

		HGLOBAL  h;

		if (f_fail = !h_RSRC)
			goto errJump;
		if (f_fail = !( us_lenPgpMimeBmp = (WORD) SizeofResource( eh_Instance, 
																	h_RSRC)))
			goto errJump;
		if (f_fail = !( h = LoadResource( eh_Instance, h_RSRC)))
			goto errJump;
		if (f_fail = !(puc_PgpMimeBmp = LockResource( h)))
			goto errJump;
	} //if (!puc_PgpMimeBmp)

	//make a copy of the PGP/MIME items comprising the content field under the 
	//	PGP/MIME holding field's name
	if (us_err = NSFItemInfo( (NOTEHANDLE) h_NOTE, (char *) pc_FLDNM, (WORD) 
													ui_LEN_FLDNM, &bid_itm, 
													&us_typ, &bid_ctnt, &ul))
		return us_err;
	if (us_typ != TYPE_MIME_PART)
		return eus_ERR_INVLD_ARG;
	do	{
		us_err = NSFItemAppend( (NOTEHANDLE) h_NOTE, ITEM_SIGN + ITEM_SEAL, 
									(char *) mpc_FLDNM_PGPMIM_HLDR, (WORD) 
									mui_LEN_FLDNM_PGPMIM_HLDR, TYPE_MIME_PART, 
									OSLockBlock( BYTE, bid_ctnt) + 
									sizeof( WORD), ul - sizeof( WORD));
		OSUnlockBlock( bid_ctnt);
		if (us_err)
			return us_err;
		if (us_err = NSFItemInfoNext( (NOTEHANDLE) h_NOTE, bid_itm, (char *) 
											pc_FLDNM, (WORD) ui_LEN_FLDNM, 
											&bid_itm, &us_typ, &bid_ctnt, &ul))
			if (ERR( us_err) == ERR_ITEM_NOT_FOUND)
				break;
			else
				return us_err;
	} while (TRUE);

	//start a link hotspot that when clicked will call signed code in the 
	//	subform to launch the decoding process
	if (us_err = eus_StartLinkHotspot( pc_LINK, NULL, 
											ept_InitUtilityRtfContext( &t_ctx)))
		goto errJump;
	if (us_err = eus_AppendCdsToRtf( puc_PgpMimeBmp, us_lenPgpMimeBmp, &t_ctx))
		goto errJump;

	//fill the innards of the hotspot including PGP/MIME graphic and text and 
	//	an "invisible" attachment hotspot by which the plug-in may determine 
	//	the source message if and when the message is forwarded or replied to 
	//	"with history"
	if (us_err = eus_InsertAttachHotspot( NULL, mpc_FILENM_PGP_SRC, (char *) 
										mpc_FILENM_PGP_SRC, h_NOTE, NULL, NULL, 
										pc_TAG_PGPMIME, NULL, FontSetColor( 
										DEFAULT_SMALL_FONT_ID, 
										NOTES_COLOR_DKRED), NULL, &t_ctx))
		goto errJump;

	//finish up the hotspot
	if (us_err = eus_CloseLinkHotspot( NULL, &t_ctx))
		goto errJump;

	//attach the special attachment by which the plug-in may determine the 
	//	source message if and when the message is forwarded or replied to "with 
	//	history"

	//replace the existing MIME content field with what we've constructed
	if (us_err = eus_RemoveItem( h_NOTE, pc_FLDNM, ebid_NULLBLOCKID))
		goto errJump;
	us_err = eus_CommitChangedRtf( h_NOTE, pc_FLDNM, &t_ctx);

errJump:
	ef_FreeRtfContext( &t_ctx);

	return us_err + f_fail;
} //xus_prepPgpMime(


/** xus_decodePgpMime( ***
Decode the given note containing PGP/MIME already prepared for this purpose 
(cf. xus_prepPgpMime).

--- parameters & return ------
h_NOTE: handle to the note containing the prepared PGP/MIME content
pc_FLDNM: address of the name of the field to receive the decoded PGP/MIME 
	content (which will be regular MIME content)
RETURN:
	eus_ERR_INVLD_ARG if any input is obviously invalid
	ERR_MEMORY if system ran out of heap memory
	eus_SUCCESS if no error occured
	the Notes API error code otherwise

--- revision history ---------
10/11/03 PR: logic adjustment to fix bug in boundary handling and bug in 
	walking an input memory buffer

8/21/03 PR
+ logic adjustment to fix seeming flaws in (a) the building of the list of 
  boundary strings and (b) pointer use in recasting the MIME result file into 
  replacement Notes MIME parts
+ minor documentation adjustment & logic shortening

3/14/03 PR: created		*/
WORD xus_decodePgpMime( const NOTEHANDLE  h_NOTE, 
						const char  pc_FLDNM[])	{
	const WORD  us_LEN_FLDNM = pc_FLDNM ? strlen( pc_FLDNM) : FALSE;

	char * pc_fileNmIn, * pc_fileNmOut = NULL, * pc_bufIn, * pc_bufOut = NULL;
	BLOCKID  bid_ctnt;
	size_t  ui_lenIn, ui = NULL;
	MimePrtNode * pt_parts, * pt_nd;
	DWORD  ul_lenOut;
	MIME_PART * pt;
	BufFile  t_bufFl = {NULL};
	BYTE * puc, * puc_buf = NULL;
	StringNode * pt_boundrys = NULL;
	STATUS  us_err;
	int  i_err;
	BOOL  f_fail = FALSE;

	if (!( h_NOTE && pc_FLDNM && *pc_FLDNM))
		return eus_ERR_INVLD_ARG;

	//get the PGP/MIME content from the note in a PGP-decodable form
	if (us_err = us_ExtractPgpMimeDecodable( h_NOTE, &pc_fileNmIn, &pc_bufIn, 
											&bid_ctnt, &ui_lenIn, &pt_parts))
		return us_err;

	//if we're to work with files...
	if (pc_fileNmIn)	{
		//decode the file containing PGP-encoded content to an output file
		i_err = ei_PgpDecodeFile( pc_fileNmIn, &pc_fileNmOut);

		//if it was signed-only content...
		if (pt_parts->pt->puc_ctnt)	{
			//remove the output file since it's a clone of the clear-signed 
			//	content we already have information on in the input file
			ei_PgpWipeFile( pc_fileNmOut);
			e_FreePgpMem( pc_fileNmOut);
			pc_fileNmOut = NULL;
		//else remove the now-unneeded input file
		}else	{
			remove( pc_fileNmIn);
			free( pc_fileNmIn);
			pc_fileNmIn = NULL;
		} //if (pt_parts->pt->puc_ctnt)
	//else we're to work with memory buffers...
	}else	{
		//decode the buffer containing PGP-encoded content to an output buffer
		i_err = ei_PgpDecodeBuffer( pc_bufIn, ui_lenIn, TRUE, &pc_bufOut, 
																	&ul_lenOut);

		//if it was encrypted content...
		if (pc_bufIn && !pt_parts->pt->puc_ctnt)	{
			//the input buffer is owned by Notes, so release it back
			OSUnlockBlock( bid_ctnt);
			pc_bufIn = NULL;
		//else removed the output buffer since it's a clone of the clear-signed 
		//	content we already have information on in the input buffer
		}else	{
			e_FreePgpMem( pc_bufOut);
			pc_bufOut = NULL;
		} //if (pc_bufIn && !pt_parts->pt->puc_ctnt)
	} //if (pc_fileNmIn)
	if (i_err)	{
		if (ei_USER_ABORT == i_err)
			i_err = NULL;
		goto errJump;
	}

	//delete the message's current Body field
	if (us_err = eus_RemoveItem( h_NOTE, pc_FLDNM, ebid_NULLBLOCKID))
		goto errJump;

	//Compose a new Body field consisting of the resulting decoded MIME as 
	//	Notes MIME-part items. If signed-only content was decoded, use our list 
	//	of expected parts to speed the manufacture of Notes MIME-parts...
	if (pt_parts->pt->puc_ctnt)	{
		const size_t  ui_LEN_FILE_BUF = 0x400;

		MimePrtItmCtnt * pt_ctnt;
		size_t  ui_;

		//if we're working with files, open the clear-signed input file and 
		//	fill a "file buffer" with a reasonable chunk of the file
		if (pc_fileNmIn)
			if (f_fail = !ef_bufferFileForRead( NULL, pc_fileNmIn, 
													ui_LEN_FILE_BUF, sizeof( 
													MIME_PART), &t_bufFl))
				goto errJump;

		//prepare a Notes MIME-part for the first part
		pt = (pt_ctnt = pt_parts->pt)->pt;
		ui = pt->wBoundaryLen;
		pt->wByteCount -= ui;
		pt->wBoundaryLen = NULL;
		pt->dwFlags &= ~MIME_PART_HAS_BOUNDARY;
		pt_ctnt->puc_ctnt += ui;

		//for each member of the parts list (first to last)...
		pt_nd = pt_parts;
		do	{
			//Construct the Notes MIME-part item using the part descriptor. Use 
			//	an existing buffer for the work if possible. If body content is 
			//	in an attachment, rect accordingly.
			ui_ = NULL;
			if (pt_ctnt->pc_objNm)
				pt->wByteCount = pt_ctnt->puc_bdy - pt_ctnt->puc_ctnt + (ui_ = 
													strlen( pt_ctnt->pc_objNm));
			ui = pt->wByteCount;
			if (pc_fileNmIn)	{
				if (ui > ui_LEN_FILE_BUF)	{
					if (!( puc_buf = puc = malloc( sizeof( MIME_PART) + 
																	ui)))	{
						us_err = eus_ERR_MEM;
						goto errJump;
					}
					if (f_fail = el_bufFileCpyCtnt( (long) pt_ctnt->puc_ctnt, 
											ui - ui_, puc + sizeof( MIME_PART), 
											&t_bufFl) < (int) (ui - ui_))
						goto errJump;
				}else	{
					if (f_fail = !ef_bufFileSpliceToPrfx( (long) 
															pt_ctnt->puc_ctnt, 
															ui - ui_, &t_bufFl))
						goto errJump;
					puc = t_bufFl.puc;
				} //if (ui > ui_LEN_FILE_BUF)
				if (ui_)
					memcpy( puc + sizeof( MIME_PART) + ui - ui_, 
														pt_ctnt->pc_objNm, ui_);
			}else
				puc = (BYTE *) pt_parts->pt->puc_ctnt - sizeof( MIME_PART);
			*(MIME_PART *) puc = *pt;

			//append the part
			if (us_err = NSFItemAppend( h_NOTE, ITEM_SIGN + ITEM_SEAL, (char *) 
										pc_FLDNM, us_LEN_FLDNM, TYPE_MIME_PART, 
										puc, sizeof( MIME_PART) + ui))
				goto errJump;
			if (puc_buf)	{
				free( puc_buf);
				puc_buf = NULL;
			}

			//if no more parts to do, break out of loop
			if (!( pt_nd = pt_nd->pt_nxt))
				break;
			pt = (pt_ctnt = pt_nd->pt)->pt;
		} while (TRUE);

		//free resources allocated to parts list
		pt_nd = pt_parts;
		do
			if (pt_nd->pt->pc_objNm)
				free( (char *) pt_nd->pt->pc_objNm);
		while (pt_nd = pt_nd->pt_nxt);
		e_FreeList( &pt_parts, TRUE);
	//else encrypted content must have been decoded...
	}else	{
		const size_t  ui_LEN_FILE_BUF = 24 * 0x400;

		MimePrtCtnt  t_ctnt;
		MIME_PART * pt;					//shadow
		char * pc_prt;

		//free the now unnecessary "parts list"
		MimePrtNode * pt_nd_ = pt_parts;
		do
			if (pt_nd_->pt->pc_objNm)
				free( (char *) pt_nd_->pt->pc_objNm);
		while (pt_nd_ = pt_nd_->pt_nxt);
		e_FreeList( &pt_parts, TRUE);

		//if we're working with a file, open it
		if (pc_fileNmOut)
			if (f_fail = !ef_bufferFileForRead( NULL, pc_fileNmOut, 
													ui_LEN_FILE_BUF, sizeof( 
													MIME_PART), &t_bufFl))
				goto errJump;

		//get detail on the first part
		if (us_err = eus_MimePartInfo( pc_bufOut, 0, pc_fileNmOut ? 
										&t_bufFl : NULL, &pt_boundrys, &t_ctnt))
			goto errJump;

		//For the first part (sole-body or prolog), construct the Notes 
		//	MIME-part item using the part descriptor. Use an existing buffer 
		//	for the work if possible.
		ui = t_ctnt.ui_len;
		if (!pc_fileNmOut || ui > ui_LEN_FILE_BUF)	{
			if (!( puc_buf = puc = malloc( sizeof( MIME_PART) + ui)))	{
				us_err = eus_ERR_MEM;
				goto errJump;
			}
			if (pc_fileNmOut)	{
				if (f_fail = el_bufFileCpyCtnt( (long) t_ctnt.puc_ctnt, ui, 
													puc + sizeof( MIME_PART), 
													&t_bufFl) < (int) ui)
					goto errJump;
			}else
				memcpy( puc + sizeof( MIME_PART), t_ctnt.puc_ctnt, ui);
		}else	{
			if (f_fail = !ef_bufFileSpliceToPrfx( (long) t_ctnt.puc_ctnt, ui, 
																	&t_bufFl))
				goto errJump;
			puc = t_bufFl.puc;
		} //if (!pc_fileNmOut || ui > ui_LEN_FILE_BUF)
		memset( pt = (MIME_PART *) puc, NULL, sizeof( MIME_PART));
		pt->wVersion = 2;
		pt->dwFlags = MIME_PART_HAS_HEADERS;
		pt->wByteCount = ui;
		if (t_ctnt.puc_bdy)	{
			pt->cPartType =  MIME_PART_BODY;
			pt->wHeadersLen = t_ctnt.puc_bdy - t_ctnt.puc_ctnt;
		}else	{
			pt->cPartType = MIME_PART_PROLOG;
			pt->wHeadersLen = ui;
		}

		//append the first part
		if (us_err = NSFItemAppend( h_NOTE, ITEM_SIGN + ITEM_SEAL, (char *) 
										pc_FLDNM, us_LEN_FLDNM, TYPE_MIME_PART, 
										puc, sizeof( MIME_PART) + ui))
			goto errJump;
		if (puc_buf)	{
			free( puc_buf);
			puc_buf = NULL;
		}

		//for each of the remaining parts...
		pc_prt = !pc_fileNmOut ? t_ctnt.puc_ctnt : NULL;
		while (pt_boundrys)	{
			//get detail on the next part
			if (us_err = eus_MimePartInfo( pc_prt ? pc_prt += t_ctnt.ui_len : 
												NULL, (long) t_ctnt.puc_ctnt + 
												t_ctnt.ui_len, &t_bufFl, 
												&pt_boundrys, &t_ctnt))
				goto errJump;

			//Set buffer for construction of the Notes MIME-part item. Use an 
			//	existing buffer for the work if possible.
			ui = t_ctnt.puc_atchNm ? t_ctnt.puc_bdy - t_ctnt.puc_ctnt + 
											t_ctnt.us_lenAtchNm : t_ctnt.ui_len;
			if (pc_fileNmOut)
				if (ui > ui_LEN_FILE_BUF)	{
					if (!( puc_buf = puc = malloc( sizeof( MIME_PART) + 
																	ui)))	{
						us_err = eus_ERR_MEM;
						goto errJump;
					}
					if (f_fail = el_bufFileCpyCtnt( (long) t_ctnt.puc_ctnt, ui, 
													puc + sizeof( MIME_PART), 
													&t_bufFl) < (int) ui)
						goto errJump;
				}else	{
					if (f_fail = !ef_bufFileSpliceToPrfx( (long) 
												t_ctnt.puc_ctnt, ui, &t_bufFl))
						goto errJump;
					puc = t_bufFl.puc;
				} //if (ui > ui_LEN_FILE_BUF)
			else
				puc = pc_prt - sizeof( MIME_PART);

			//prepare common fields in Notes' MIME-part descriptor
			memset( pt = (MIME_PART *) puc, NULL, sizeof( MIME_PART));
			pt->wVersion = 2;
			pt->wByteCount = ui;
			pt->wBoundaryLen = t_ctnt.us_lenBndry;

			//if we have an epilog part...
			if (!t_ctnt.puc_typ)	{
				//set it's type
				pt->cPartType = MIME_PART_EPILOG;
				pt->dwFlags = MIME_PART_HAS_BOUNDARY;
				pt->wBoundaryLen += eus_LEN_MIM_BNDRY_TACK_ON;
			//else it's a prolog or body part...
			}else 	{
				//set descriptive info that's common between the parts
				pt->dwFlags = MIME_PART_HAS_BOUNDARY + MIME_PART_HAS_HEADERS;
				pt->wBoundaryLen += t_ctnt.puc_bndry - t_ctnt.puc_ctnt;

				// if we have a prolog part...
				if (!t_ctnt.puc_bdy)	{
					//set its particular descriptive info
					pt->cPartType = MIME_PART_PROLOG;
					pt->wHeadersLen = ui - pt->wBoundaryLen;
				//else process the body part
				}else	{
					pt->cPartType = MIME_PART_BODY;
					pt->wHeadersLen = t_ctnt.puc_bdy - t_ctnt.puc_ctnt - 
															pt->wBoundaryLen;

					//if the body part holds a file attachment...
					if (t_ctnt.puc_atchNm)	{
						char * pc;

						//save the content as an attachment to the note, base64 
						//	decoding along the way if necessary
						if (us_err = eus_MimeAtchFileCtnt( &t_ctnt, &t_bufFl, 
														h_NOTE, pc_fileNmOut ? 
														&pc : NULL))
							goto errJump;

						//adjust the body content to reflect the attachment in 
						//	the manner Notes does for MIME-parts, and adjust 
						//	the length component of the Notes-item content 
						//	accordingly
//PGP dev shortcuts: Assuming that filename is shorter than attachment body 
//	content (dangerous). Also if writing directly to buffered file's buffer, 
//	that buffer should be invalidated or fixed up after the item append. 
//	Easiest solution all around is probably to put back what was overwritten 
//	after the item append.
						memcpy( puc + sizeof( MIME_PART) + (t_ctnt.puc_bdy - 
											t_ctnt.puc_ctnt), pc_fileNmOut ? 
											pc : t_ctnt.puc_atchNm, 
											t_ctnt.us_lenAtchNm);
						pt->dwFlags |= MIME_PART_BODY_IN_DBOBJECT + 
													MIME_PART_SHARED_DBOBJECT;
						if (pc_fileNmOut)
							free( pc);
					} //if (t_ctnt.puc_atchNm)
				} //if (!t_ctnt.puc_bdy)
			} //if (!t_ctnt.puc_typ)

			//append the MIME-part item to the note
			if (us_err = NSFItemAppend( h_NOTE, ITEM_SIGN + ITEM_SEAL, (char *) 
										pc_FLDNM, us_LEN_FLDNM, TYPE_MIME_PART, 
										puc, sizeof( MIME_PART) + ui))
				goto errJump;
			if (puc_buf)	{
				free( puc_buf);
				puc_buf = NULL;
			}
		} //while (pt_boundrys)
	} //if (pt_parts->pt->puc_ctnt)

	//delete the message's MIME holding field
	if (us_err = eus_RemoveItem( h_NOTE, mpc_FLDNM_PGPMIM_HLDR, 
															ebid_NULLBLOCKID))
		goto errJump;

	//clean up
	if (pc_fileNmIn || pc_fileNmOut)	{
		f_fail = !ef_bufFileClose( &t_bufFl);
		if (pc_fileNmOut)	{
			i_err = ei_PgpWipeFile( pc_fileNmOut);
			e_FreePgpMem( pc_fileNmOut);
		}else if (pc_fileNmIn)	{
			remove( pc_fileNmIn);
			free( pc_fileNmIn);
		}
	}else if (pc_bufOut)
		e_FreePgpMem( pc_bufOut);
	else if (pc_bufIn)
		free (pc_bufIn);

	return i_err ? i_err : f_fail;

errJump:
	if (pt_boundrys)
		e_FreeList( &pt_boundrys, TRUE);
	if (puc_buf)
		free( puc_buf);
	if (t_bufFl.puc)
		ef_bufFileClose( &t_bufFl);
	if (pc_bufOut)
		e_FreePgpMem( pc_bufOut);
	else if (pc_fileNmOut)	{
		remove( pc_fileNmOut);
		e_FreePgpMem( pc_fileNmOut);
	}
	if (pt_nd = pt_parts)	{
		do
			if (pt_nd->pt->pc_objNm)
				free( (void *) pt_nd->pt->pc_objNm);
		while (pt_nd = pt_nd->pt_nxt);
		e_FreeList( &pt_parts, TRUE);
	} //if (pt_nd = pt_parts)
	if (pc_bufIn)
		free( pc_bufIn);
	else if (pc_fileNmIn)	{
		remove( pc_fileNmIn);
		free( pc_fileNmIn);
	}

	return us_err + i_err + f_fail;
} //xus_decodePgpMime(


/** us_ExtractPgpMimeDecodable( ***
Extract from the specified PGP/MIME items the content formatted to allow a 
proper PGP-decoding of the PGP/MIME message's payload. The result can be a 
memory buffer unless attachments are involved with the content (even if merely 
as in-line hidden attachments; see ppc_fileNm parameter description for further 
detail).

--- parameters & return -------
h_NOTE: handle to the note containing the prepared PGP/MIME content
ppc_fileNm: Optional Output, Required if ppuc Output not Requested. Address of 
	buffer in which to place the extended filename of the temporary file that 
	may be created to hold the compiled decodable content. If null and 
	procedure determines that a file must be used to perorm its function, 
	procedure will fail with an invalid-argument error.
ppuc: Optional Output. Address of pointer to receive address of memory buffer 
	holding the extracted decodable content. Caller is responsible for freeing 
	the buffer or unlocking it via given BlockID. If null-addess, procedure 
	will write all decodable content to the output file.
pbid: Optional Output. Address of BlockID structure to receive the BlockID of 
	the Notes block that owns the pointer provided via the ppuc output. Only 
	set for encrypted messages where all decodable content resides in a 
	particular MIME-part item and caller wishes the content in a buffer. If 
	null and caller has not allowed the ppc_fileNm output, procedure will fail 
	with an invalid-argument error.
pui_len: Optional Output. Address of variable to receive the length of the 
	decodable content. If null, output will be suppressed.
ppt: Optional Output. Address of pointer to receive the list of descriptor 
	structures describing either the MIME-parts of a clear-signed message that 
	are preserved when the PGP/MIME content is verified, or the MIME-part 
	holding the PGP-encoded content in an encrypted message. Since in the one 
	case signed content is encapsulated within a multipart MIME message that 
	must be decoded in its entirety, whereas in the other case only one MIME 
	part is needed for decoding, this output may serve also as a flag telling 
	whether content is PGP-signed or -encrypted. Since all content-pointer 
	members in the descriptor structures are recast as offsets from the 
	beginning of the output buffer or file, if the first node's content 
	(MimePrtItmCtnt.puc_ctnt member) starts at byte zero, the content must be 
	encrypted, else it is signed-only. If null, this output is suppressed.
RETURN:
	eus_ERR_INVLD_ARG if any input is obviously invalid
	ERR_MEMORY if system ran out of heap memory
	eus_SUCCESS if no error occured
	the Notes API error code otherwise

--- suggested enhancements ----
3/14/03 PR
+ As noted in-line below, probable efficiency could be gained by reading 
  attachment content directly out of attachment objects if circumstances 
  warrant it.
+ As noted in-line below, procedure would benefit from a recursable mulitpart 
  MIME processing function. This would get rid of the current two-deep 
  limitation on multiparted messages (where one multipart is the PGP/MIME 
  shell).

--- revision history ----------
10/13/03 PR: listing format adjustment
8/21/03 PR: documentation improvement
3/14/03 PR: created			*/
static STATUS us_ExtractPgpMimeDecodable( 
										const NOTEHANDLE  h_NOTE, 
										char * *const  ppc_fileNm, 
										const BYTE * *const  ppuc, 
										BLOCKID *const  pbid, 
										size_t *const  pui_len, 
										const MimePrtNode * *const  ppt)	{
	const char  pc_PGPMIM_KEY[] = " protocol=\"application/pgp-", 
				pc_PGPMIM_KEY_ENCRYPT[] = "encrypted\"", 
				pc_PGPMIM_KEY_SIGN[] = "signature\"", 
				pc_PGPMIM_PRT_KEY_ENCRYPT[] = "application/pgp-encrypted\r\n", 
				pc_MIM_OCT_STRM[] = "application/octet-stream\r\n", 
				pc_MIM_MULTI_SIGN[] = "multipart/signed;";
	const size_t  ui_LEN_PGPMIM_KEY = sizeof( pc_PGPMIM_KEY) - 1, 
					ui_LEN_PGPMIM_KEY_ENCRYPT = sizeof( 
													pc_PGPMIM_KEY_ENCRYPT) - 1, 
					ui_LEN_PGPMIM_KEY_SIGN = sizeof( pc_PGPMIM_KEY_SIGN) - 1, 
					ui_LEN_MIM_MULTI_SIGN = sizeof( pc_MIM_MULTI_SIGN) - 1, 
					ul_LEM_MIM_OCT_STRM = sizeof( pc_MIM_OCT_STRM) - 1;

	BLOCKID  bid_itm, bid_ctnt, bid_ctntStrt = ebid_NULLBLOCKID, 
				bid_ctntStrtIn = ebid_NULLBLOCKID, bid_itmStrtIn, bid_itmFile, 
				bid_ctntSig = ebid_NULLBLOCKID, bid_ctntEnd = ebid_NULLBLOCKID;
	MimePrtItmCtnt  t_ctnt, t_ctntStrt, t_ctntStrtIn, t_ctntSig, t_ctntEnd, 
					* pt_ctnt;
	const MIME_PART * pt;
	const BYTE * puc;
	BOOL  f_encryptd = FALSE, f_fail;
	char * pc_fileNm = NULL;
	size_t  ui_len;
	void * pv_file = NULL;
	MimePrtNode * pt_parts = NULL, * pt_nd;
	BYTE * puc_buf = NULL;
	STATUS  us_err;

	_ASSERTE( h_NOTE && (ppc_fileNm || ppuc));

	if (ppuc)
		*ppuc = NULL;
	if (ppc_fileNm)
		*ppc_fileNm = NULL;
	if (pbid)
		*pbid = ebid_NULLBLOCKID;
	if (pui_len)
		*pui_len = NULL;
	if (ppt)
		*ppt = NULL;

	//if the content is encrypted...
	if (us_err = eus_MimePartItmInfo( h_NOTE, mpc_FLDNM_PGPMIM_HLDR, (WORD) 
								mui_LEN_FLDNM_PGPMIM_HLDR, ebid_NULLBLOCKID, 
								&bid_itm, &bid_ctnt, &t_ctnt, NULL, NULL))
		return us_err;
	if (!( f_fail = t_ctnt.pt->cPartType != MIME_PART_PROLOG))	{
		if (puc = epc_strInBuf( pc_PGPMIM_KEY, t_ctnt.puc_typ, 
										t_ctnt.pt->wByteCount - 
										sizeof( MIME_PART) - (t_ctnt.puc_typ - 
										t_ctnt.puc_ctnt), ui_LEN_PGPMIM_KEY))
			if (strnicmp( puc += ui_LEN_PGPMIM_KEY, pc_PGPMIM_KEY_ENCRYPT, 
										ui_LEN_PGPMIM_KEY_ENCRYPT) == ei_SAME)
				f_encryptd = TRUE;
			else
				f_fail = strnicmp( puc, pc_PGPMIM_KEY_SIGN, 
											ui_LEN_PGPMIM_KEY_SIGN) != ei_SAME;
	} //if (!( f_fail = pt->cPartType !=
	if (f_fail || !puc)	{
		OSUnlockBlock( bid_ctnt);
		return eus_ERR_INVLD_ARG;
	}
	if (f_encryptd)	{
		//get to the single MIME part that contains the PGP-encrypted content, 
		//	validating along the way
		OSUnlockBlock( bid_ctnt);
		pt = NULL;
		if (us_err = eus_MimePartItmInfo( h_NOTE, mpc_FLDNM_PGPMIM_HLDR, (WORD) 
									mui_LEN_FLDNM_PGPMIM_HLDR, bid_itm, 
									&bid_itm, &bid_ctnt, &t_ctnt, NULL, NULL))
			return us_err;
		f_fail = !(t_ctnt.pt->cPartType == MIME_PART_BODY && strnicmp( 
									pc_PGPMIM_PRT_KEY_ENCRYPT, t_ctnt.puc_typ, 
									sizeof( pc_PGPMIM_PRT_KEY_ENCRYPT) - 1) == 
									ei_SAME);
		OSUnlockBlock( bid_ctnt);
		if (f_fail)
			return eus_ERR_INVLD_ARG;
		if (us_err = eus_MimePartItmInfo( h_NOTE, mpc_FLDNM_PGPMIM_HLDR, 
											(WORD) mui_LEN_FLDNM_PGPMIM_HLDR, 
											bid_itm, &bid_itm, &bid_ctnt, 
											&t_ctnt, &bid_itmFile, NULL))
			return us_err;
		pt = t_ctnt.pt;
		if (!( pt->cPartType == MIME_PART_BODY && strnicmp( pc_MIM_OCT_STRM, 
										t_ctnt.puc_typ, 
										ul_LEM_MIM_OCT_STRM) == ei_SAME))	{
			us_err = eus_ERR_INVLD_ARG;
			goto errJump;
		}

		//if requested, populate the one part descriptor of interest to the 
		//	caller when encrypted content is involved
		if (ppt)	{
			if (!( pt_ctnt = malloc( sizeof( MimePrtItmCtnt) + sizeof( 
															MIME_PART))))	{
				us_err = eus_ERR_MEM;
				goto errJump;
			}
			if (!ef_AddListNode( pt_ctnt, TRUE, &pt_parts))	{
				free( pt_ctnt);
				us_err = eus_ERR_MEM;
				goto errJump;
			}
			pt_ctnt->pt = (MIME_PART *) (pt_ctnt + 1);
			*pt_ctnt->pt = *pt;
			pt_ctnt->puc_typ = (BYTE *) (t_ctnt.puc_typ - t_ctnt.puc_ctnt);
			pt_ctnt->puc_bdy = (BYTE *) (t_ctnt.puc_bdy - t_ctnt.puc_ctnt);
			pt_ctnt->puc_ctnt = NULL;
			pt_ctnt->pc_objNm = t_ctnt.pc_objNm;
		}else if (t_ctnt.pc_objNm)
			free( (void *) t_ctnt.pc_objNm);
		pt = NULL;

		//if the encrypted content was moved to a file attachment or if the 
		//	caller wants only a file...
		if (bid_itmFile.pool || !(ppuc && pbid))	{
			//As currently written, any work with attachments forces 
			//	compliation of the decodable content in its own file. Therefore 
			//	if caller requested no file output, short-circuit with failure.
			if (!ppc_fileNm)	{
				us_err = eus_ERR_INVLD_ARG;
				goto errJump;
			}

			//Extract the file as a temporary file on the file system. Thus we 
			//	have completed all processing needed to derive the needed 
			//	PGP-decodable content.
			if (f_fail = !( pc_fileNm = _tempnam( NULL, epc_TILDE)))
				goto errJump;
			if (bid_itmFile.pool)
				us_err = NSFNoteExtractFile( (NOTEHANDLE) h_NOTE, bid_itmFile, 
															pc_fileNm, NULL);
			else
				f_fail = !ef_writeToNewFile( t_ctnt.puc_bdy, pt->wByteCount - 
											(t_ctnt.puc_bdy - t_ctnt.puc_ctnt), 
											pc_fileNm, NULL);
			OSUnlockBlock( bid_ctnt);
			if (us_err + f_fail)	{
				free( pc_fileNm);
				goto errJump;
			}
		//else note the point at which the content to be PGP-decoded begins
		}else	{
			puc = t_ctnt.puc_bdy;
			*pbid = bid_ctnt;
		} //if (bid_itmFile.pool || !(ppuc && pbid)
	//else the content is just signed, so stream the MIME parts involved into 
	//	a PGP-decodable entity...
	}else	{
		const char  pc_PGPMIM_PART_KEY_SIGN[] = "application/pgp-signature\r\n";

		const BYTE * puc_;
		char  pc_bndry[ 81];
		size_t  ui, ui_lenBndry;

		//note the boundary string told in this prolog part of the outer shell, 
		//	validating the part along the way
		puc = t_ctnt.puc_typ;
		if (!( strnicmp( pc_MIM_MULTI_SIGN, puc, ui_LEN_MIM_MULTI_SIGN) == 
							ei_SAME && (puc = epc_strInBuf( epc_MIM_BOUNDRY, 
							puc + ui_LEN_MIM_MULTI_SIGN, ui = 
							t_ctnt.pt->wByteCount - (puc - t_ctnt.puc_ctnt) - 
							ui_LEN_MIM_MULTI_SIGN, eus_LEN_MIM_BOUNDRY)) && 
							(puc_ = memchr( (puc += eus_LEN_MIM_BOUNDRY) + 1, 
							ec_QUOTES, ui - eus_LEN_MIM_BOUNDRY - 1))))	{
			us_err = eus_ERR_INVLD_ARG;
			goto errJump;
		}
		ui = puc_ - puc;
		ui_lenBndry = eus_LEN_MIM_BNDRY_TACK_ON + ui;
		strncat( strcpy( pc_bndry, epc_MIM_BNDRY_TACK_ON), puc, ui);

		//in preparation for clean decoding, figure the offset into the outer 
		//	shell's prolog content where decoding should start (with the 
		//	content-type header), and the resulting length of the part content 
		//	to be involved in decoding
		puc = t_ctnt.puc_typ - eus_LEN_MIMHDR_CTNT_TYP;
		ui = puc - t_ctnt.puc_ctnt;
		ui_len = t_ctnt.pt->wByteCount - ui;

		//if the note includes attachments or caller wants the output in a 
		//	file...
		if (NSFNoteHasObjects( h_NOTE, NULL) || !ppuc)	{
			//As currently written, any work with attachments forces 
			//	compliation of the decodable content in its own file. Therefore 
			//	if caller requested no file output, short-circuit with failure.
			if (!ppc_fileNm)	{
				us_err = eus_ERR_INVLD_ARG;
				goto errJump;
			}

			//open a temporary file and stream in this outer-shell prolog part
			if (f_fail = !( pc_fileNm = _tempnam( NULL, epc_TILDE)))
				goto errJump;
			if (f_fail = !ef_writeToNewFile( puc, ui_len, pc_fileNm, 
																&pv_file))	{
				free( pc_fileNm);
				goto errJump;
			}
			OSUnlockBlock( bid_ctnt);
		//else note details on the outer-shell prolog part for use once memory 
		//	buffer is ready for population
		}else	{
			t_ctntStrt = t_ctnt;
			t_ctntStrt.puc_ctnt = puc;
			t_ctntStrt.pt->wByteCount = ui_len;
			bid_ctntStrt = bid_ctnt;
		} //if (NSFNoteHasObjects( h_NOTE,
		pt = NULL;

		//get and validate the next part as either the encapsulated end-
		//	message's sole body part or as its top-level multipart prolog part
		if (us_err = eus_MimePartItmInfo( h_NOTE, mpc_FLDNM_PGPMIM_HLDR, (WORD) 
												mui_LEN_FLDNM_PGPMIM_HLDR, 
												bid_itm, &bid_itm, &bid_ctnt, 
												&t_ctnt, &bid_itmFile, NULL))
			goto errJump;
		pt = t_ctnt.pt;
		if (!( (pt->cPartType == MIME_PART_BODY || pt->cPartType == 
									MIME_PART_PROLOG) && pt->wBoundaryLen == 
									ui_lenBndry + eui_LEN_CRLF))	{
			us_err = eus_ERR_INVLD_ARG;
			goto errJump;
		}

		//if necessary, with this part, start a list of part descriptors which 
		//	may be used downstream or which	the caller can utilize when working 
		//	with the MIME content stream being constructed here
		if (ppt || !pv_file)	{
			if (!( pt_ctnt = malloc( sizeof( MimePrtItmCtnt) + sizeof( 
															MIME_PART))))	{
				us_err = eus_ERR_MEM;
				goto errJump;
			}
			if (!ef_AddListNode( pt_ctnt, TRUE, &pt_parts))	{
				free( pt_ctnt);
				us_err = eus_ERR_MEM;
				goto errJump;
			}
			pt_ctnt->pt = (MIME_PART *) (pt_ctnt + 1);
			*pt_ctnt->pt = *pt;
			pt_ctnt->puc_typ = (BYTE *) (ui_len + t_ctnt.puc_typ - 
															t_ctnt.puc_ctnt);
			pt_ctnt->puc_bdy = (BYTE *) (ui_len + t_ctnt.puc_bdy - 
															t_ctnt.puc_ctnt);
			pt_ctnt->puc_ctnt = (BYTE *) ui_len;
			pt_ctnt->pc_objNm = t_ctnt.pc_objNm;
		}else if (t_ctnt.pc_objNm)
			free( (void *) t_ctnt.pc_objNm);
		t_ctnt.pc_objNm = NULL;

		//if this is the sole body part of the signed message...
		if (pt->cPartType == MIME_PART_BODY)	{
			//if the part does not use a Notes in-line include attachment...
			if (!bid_itmFile.pool)	{
				//continue to track the aggregate size of the content being 
				//	prepared for decoding
				_ASSERTE( !pv_file);
				ui_len += pt->wByteCount;

				//note details on this first encapsulated end-message part for 
				//	use once the memory buffer is ready for population
				t_ctntStrtIn = t_ctnt;
				bid_ctntStrtIn = bid_ctnt;
				bid_itmStrtIn = bid_itm;
			//else special handling is needed to accommodate the in-line 
			//	attachment part body...
			}else	{
				//expand out the in-line attachment and stream out accordingly 
				//	the part to the file being prepared for PGP-decoding
				if (us_err = eus_appendAtchPartToFile( pv_file, &t_ctnt, 
													bid_itmFile, h_NOTE, &ui))
					goto errJump;
				OSUnlockBlock( bid_ctnt);

				//if circumstances warrant, update the part's recorded length 
				//	to include the attachment content
				if (ppt || !pv_file)
					pt_ctnt->pt->wByteCount = ui;

				//continue to track the aggregate size of the content being 
				//	prepared for decoding
				ui_len += ui;
			} //if (!bid_itmFile.pool)
			pt = NULL;
		//else this must be the prolog part of a multipart end-message...
//Suggested Enhancment: Make what follows, up to the "End of Suggested 
//	Enhancement" note, a recursable function so that multiple-layer MIME can be 
//	handled (e.g. a multipart/alternative within a multipart/mixed). Currently, 
//	only one extra layer is supported, and that could be a problem if, say, a 
//	clear-signed PGP/MIME message encapsulating an HTML/plain-text message with 
//	attachments arrived. Recursable function would begin processing with a 
//	prolog part and end when its epilog part was encountered and processed.
		}else	{
			//continue to track the aggregate size of the content being 
			//	prepared for decoding by adding on the size of this prolog part
			ui_len += pt->wByteCount;

			//if we're using a file in preparation for decoding...
			if (pv_file)	{
				//append this inner-shell prolog part to the input file
				if (f_fail = el_addToOpenFile( pv_file, t_ctnt.puc_ctnt, 
											pt->wByteCount, FALSE) == ei_FAIL)
					goto errJump;
				OSUnlockBlock( bid_ctnt);
			//else note details on this prolog part of the encapsulated 
			//	end-message for use once the memory buffer is ready for 
			//	population
			}else	{
				t_ctntStrtIn = t_ctnt;
				bid_ctntStrtIn = bid_ctnt;
				bid_itmStrtIn = bid_itm;
			} //if (pv_file)
			pt = NULL;

			//if the next part is not a body part, short-circuit with failure
			if (us_err = eus_MimePartItmInfo( h_NOTE, mpc_FLDNM_PGPMIM_HLDR, 
											(WORD) mui_LEN_FLDNM_PGPMIM_HLDR, 
											bid_itm, &bid_itm, &bid_ctnt, 
											&t_ctnt, &bid_itmFile, NULL))
				goto errJump;
			pt = t_ctnt.pt;
			if (pt->cPartType != MIME_PART_BODY)	{
				us_err = eus_ERR_INVLD_ARG;
				goto errJump;
			}

			//for each of the inner-shell body parts...
			pt_nd = pt_parts;
			do	{
				//if we're keeping one, add on the body part descriptor to the 
				//	list which is used downstream or which the caller may use 
				//	when working with the MIME content being constructed here
				if (ppt || !pv_file)	{
					if (!( pt_ctnt = malloc( sizeof( MimePrtItmCtnt) + sizeof( 
															MIME_PART))))	{
						us_err = eus_ERR_MEM;
						goto errJump;
					}
					if (!ef_AddListNode( pt_ctnt, TRUE, &pt_nd))	{
						free( pt_ctnt);
						us_err = eus_ERR_MEM;
						goto errJump;
					}
					pt_ctnt->pt = (MIME_PART *) (pt_ctnt + 1);
					*pt_ctnt->pt = *pt;
					pt_ctnt->puc_typ = (BYTE *) (ui_len + t_ctnt.puc_typ - 
															t_ctnt.puc_ctnt);
					pt_ctnt->puc_bdy = (BYTE *) (ui_len + t_ctnt.puc_bdy - 
															t_ctnt.puc_ctnt);
					pt_ctnt->puc_ctnt = (BYTE *) ui_len;
					pt_ctnt->pc_objNm = t_ctnt.pc_objNm;
				}else if (t_ctnt.pc_objNm)
					free( (void *) t_ctnt.pc_objNm);
				t_ctnt.pc_objNm = NULL;

				//if the part does not use a Notes in-line include attachment...
				if (!bid_itmFile.pool)	{
					//if we're using a file in preparation for decoding, append 
					//	the entire part to the file
					if (pv_file)
						if (f_fail = el_addToOpenFile( pv_file, 
											t_ctnt.puc_ctnt, pt->wByteCount, 
											FALSE) == ei_FAIL)
							goto errJump;

					//continue to track the aggregate size of the content being 
					//	prepared for decoding
					ui_len += pt->wByteCount;
				//else special handling is needed to accommodate the in-line 
				//	attachment part body...
				}else	{
					//expand out the in-line attachment (base64 encoding along 
					//	the way if necessary) and stream out the resultant part 
					//	to the file being prepared for 	PGP-decoding
					if (us_err = eus_appendAtchPartToFile( pv_file, &t_ctnt, 
													bid_itmFile, h_NOTE, &ui))
						goto errJump;

					//if circumstances warrant, update the part's length to 
					//	include the attachment content
					if (ppt || !pv_file)
						pt_ctnt->pt->wByteCount = ui;

					//continue to track the aggregate size of the content being 
					//	prepared for decoding
					ui_len += ui;
				} //if (!bid_itmFile.pool)
				OSUnlockBlock( bid_ctnt);
				pt = NULL;

				//get the next part
				if (us_err = eus_MimePartItmInfo( h_NOTE, 
												mpc_FLDNM_PGPMIM_HLDR, (WORD) 
												mui_LEN_FLDNM_PGPMIM_HLDR, 
												bid_itm, &bid_itm, &bid_ctnt, 
												&t_ctnt, &bid_itmFile, NULL))
					goto errJump;
				pt = t_ctnt.pt;
			} while (pt->cPartType == MIME_PART_BODY);

			//if we don't have an epilog part, then we must have a MIME-message 
			//	with nested inner-shells (and this is the prolog part to a new 
			//	multipart), a case we don't yet support, so short-circuit with 
			//	failure (enhancement would be to break this logic out into a 
			//	recursable function)
			if (pt->cPartType != MIME_PART_EPILOG)	{
				us_err = eus_ERR_INVLD_ARG;
				goto errJump;
			}

			//if we're keeping one, add on the epilog part descriptor to the 
			//	list which is used downstream or which the caller may use when 
			//	working with the MIME content being constructed here
			if (ppt || !pv_file)	{
				if (!( pt_ctnt = malloc( sizeof( MimePrtItmCtnt) + sizeof( 
															MIME_PART))))	{
					us_err = eus_ERR_MEM;
					goto errJump;
				}
				pt_ctnt->pt = (MIME_PART *) (pt_ctnt + 1);
				*pt_ctnt->pt = *pt;
				if (!ef_AddListNode( pt_ctnt, TRUE, &pt_nd))	{
					free( pt_ctnt);
					us_err = eus_ERR_MEM;
					goto errJump;
				}
				pt_ctnt->puc_typ = (BYTE *) (ui_len + t_ctnt.puc_typ - 
															t_ctnt.puc_ctnt);
				pt_ctnt->puc_bdy = (BYTE *) (ui_len + t_ctnt.puc_bdy - 
															t_ctnt.puc_ctnt);
				pt_ctnt->puc_ctnt = (BYTE *) ui_len;
				pt_ctnt->pc_objNm = t_ctnt.pc_objNm;
			}else if (t_ctnt.pc_objNm)
				free( (void *) t_ctnt.pc_objNm);
			t_ctnt.pc_objNm = NULL;

			//if we're using a file in preparation for decoding, append the 
			//	epilog part to the file
			_ASSERTE( !bid_itmFile.pool);
			if (pv_file)
				if (f_fail = el_addToOpenFile( pv_file, t_ctnt.puc_ctnt, 										
											pt->wByteCount, FALSE) == ei_FAIL)
					goto errJump;

			//continue to track the aggregate size of the content being 
			//	prepared for decoding
			ui_len += pt->wByteCount;
			OSUnlockBlock( bid_ctnt);
			pt = NULL;
//End of Suggested Enhancement
		} //if (pt->cPartType == MIME_PART_BODY)

		//get the next part and validate that it's the PGP-signature part
		if (us_err = eus_MimePartItmInfo( h_NOTE, mpc_FLDNM_PGPMIM_HLDR, (WORD) 
												mui_LEN_FLDNM_PGPMIM_HLDR, 
												bid_itm, &bid_itm, &bid_ctnt, 
												&t_ctnt, &bid_itmFile, NULL))
			goto errJump;
		pt = t_ctnt.pt;
		if (!( pt->cPartType == MIME_PART_BODY && pt->wBoundaryLen == 
								ui_lenBndry + eui_LEN_CRLF * 2 && 
								memcmp( t_ctnt.puc_ctnt + eui_LEN_CRLF, 
								pc_bndry, ui_lenBndry) == ei_SAME && 
								strnicmp( pc_PGPMIM_PART_KEY_SIGN, 
								t_ctnt.puc_typ, sizeof( 
								pc_PGPMIM_PART_KEY_SIGN) - 1) == ei_SAME))	{
			us_err = eus_ERR_INVLD_ARG;
			goto errJump;
		} //if (!( pt->cPartType == MIME_PART_BODY &&

		//if the PGP-signature part does not use a Notes in-line include 
		//	attachment...
		if (!bid_itmFile.pool)	{
			//continue to track the aggregate size of the content being 
			//	prepared for decoding
			ui_len += pt->wByteCount;

			//if we're using a file in preparation for decoding...
			if (pv_file)	{
				//append the entire part to the file
				if (f_fail = el_addToOpenFile( pv_file, t_ctnt.puc_ctnt, 										
											pt->wByteCount, FALSE) == ei_FAIL)
					goto errJump;
				OSUnlockBlock( bid_ctnt);
			//else note details on this signature body part for use once the 
			//	memory buffer is ready for population
			}else	{
				t_ctntSig = t_ctnt;
				bid_ctntSig = bid_ctnt;
			} //if (pv_file)
		//else special handling is needed to accommodate the in-line attachment 
		//	part body...
		}else	{
			//expand out the in-line attachment and stream out accordingly the 
			//	part to the file being prepared for PGP-decoding
			if (us_err = eus_appendAtchPartToFile( pv_file, &t_ctnt, 
													bid_itmFile, h_NOTE, &ui))
				goto errJump;
			OSUnlockBlock( bid_ctnt);

			//continue to track the aggregate size of the content being 
			//	prepared for decoding
			ui_len += ui;
		} //if (!bid_itmFile.pool)
		pt = NULL;
		if (t_ctnt.pc_objNm)
			free( (void *) t_ctnt.pc_objNm);

		//get the next part and validate that it's the (final) epilog part
		if (us_err = eus_MimePartItmInfo( h_NOTE, mpc_FLDNM_PGPMIM_HLDR, (WORD) 
									mui_LEN_FLDNM_PGPMIM_HLDR, bid_itm, 
									&bid_itm, &bid_ctnt, &t_ctnt, NULL, NULL))
			goto errJump;
		pt = t_ctnt.pt;
		if (pt->cPartType != MIME_PART_EPILOG)	{
			us_err = eus_ERR_INVLD_ARG;
			goto errJump;
		}

		//finalize the aggregate size of the content being prepared for decoding
		ui_len += pt->wByteCount;

		//if we're using a file in preparation for decoding...
		if (pv_file)	{
			//append the epilog part to the file
			if (f_fail = el_addToOpenFile( pv_file, t_ctnt.puc_ctnt, 										
														t_ctnt.pt->wByteCount, 
														FALSE) == ei_FAIL)
				goto errJump;
			OSUnlockBlock( bid_ctnt);
		//else note details on this final epilog part for use once the memory 
		//	buffer is ready for population
		}else	{
			t_ctntEnd = t_ctnt;
			bid_ctntEnd = bid_ctnt;
		} //if (pv_file)
		pt = NULL;

		//if we're streaming to a memory buffer instead of a file...
		if (!pv_file)	{
			size_t  ui_;

			//create the buffer
			if (!( puc_buf = malloc( ui_len + 1)))	{
				us_err = ERR_MEMORY;
				goto errJump;
			}
			puc_buf[ ui_len] = NULL;

			//Begin splicing together into the buffer the MIME message in its 
			//	entirety (almost anyway, the starting prolog content may have 
			//	been adjusted above). First the outer-prolog part and the first 
			//	part of the encapsulated end-message (either a sole body part 
			//	or the end-message's starting prolog part).
			memcpy( puc_buf, t_ctntStrt.puc_ctnt, ui = 
													t_ctntStrt.pt->wByteCount);
			OSUnlockBlock( bid_ctntStrt);
			bid_ctntStrt = ebid_NULLBLOCKID;
			memcpy( puc_buf + ui, t_ctntStrtIn.puc_ctnt, ui_ = 
												t_ctntStrtIn.pt->wByteCount);
			ui += ui_;
			OSUnlockBlock( bid_ctntStrtIn);
			bid_ctntStrtIn = ebid_NULLBLOCKID;

			//if the end-message is itself a multipart MIME message, tack on 
			//	the content of its body and epilog parts...
			if (pt_parts->pt->pt->cPartType == MIME_PART_PROLOG)	{
				bid_itm = bid_itmStrtIn;
				pt_nd = pt_parts;
				do	{
					//get the next part
					if (us_err = eus_MimePartItmInfo( h_NOTE, 
												mpc_FLDNM_PGPMIM_HLDR, (WORD) 
												mui_LEN_FLDNM_PGPMIM_HLDR, 
												bid_itm, &bid_itm, &bid_ctnt, 
												&t_ctnt, NULL, NULL))
						goto errJump;
					pt = t_ctnt.pt;

					//append its content to the buffer
					memcpy( puc_buf + ui, t_ctnt.puc_ctnt, ui_ = 
																pt->wByteCount);
					OSUnlockBlock( bid_ctnt);
					pt = NULL;
					ui += ui_;
				} while (pt_nd = pt_nd->pt_nxt);
			} //if (pt_parts->pt->pt->cPartType == MIME_PART_PROLOG)

			//tack on the outer-shell's closing PGP-signature and epilog parts
			memcpy( puc_buf + ui, t_ctntSig.puc_ctnt, ui_ = 
													t_ctntSig.pt->wByteCount);
			OSUnlockBlock( bid_ctntSig);
			bid_ctntSig = ebid_NULLBLOCKID;
			ui += ui_;
			memcpy( puc_buf + ui, t_ctntEnd.puc_ctnt, t_ctntEnd.pt->wByteCount);
			OSUnlockBlock( bid_ctntEnd);
			bid_ctntEnd = ebid_NULLBLOCKID;
			_ASSERTE( ui + t_ctntEnd.pt->wByteCount == ui_len);
		} //if (!pv_file)
	} //if (f_encryptd)

	//give caller outputs as requested and as circumstances warrant
	if (pv_file)	{
		if (f_fail = !ef_closeFile( &pv_file))
			goto errJump;
		*ppc_fileNm = pc_fileNm;
	}else if (f_encryptd)
		if (pc_fileNm)
			*ppc_fileNm = pc_fileNm;
		else
			*ppuc = puc;
	else
		*ppuc = puc_buf;
	if (pui_len)
		*pui_len = ui_len;
	if (ppt)
		*ppt = pt_parts;
	else if (pt_nd = pt_parts)	{
		do
			if (pt_nd->pt->pc_objNm)
				free( (void *) pt_nd->pt->pc_objNm);
		while (pt_nd = pt_nd->pt_nxt);
		e_FreeList( &pt_parts, TRUE);
	} //if (ppt)

	return eus_SUCCESS;

errJump:
	if (puc_buf)
		free (puc_buf);
	if (bid_ctntEnd.pool)
		OSUnlockBlock( bid_ctntEnd);
	if (bid_ctntSig.pool)
		OSUnlockBlock( bid_ctntSig);
	if (bid_ctntStrtIn.pool)
		OSUnlockBlock( bid_ctntStrtIn);
	if (pt_nd = pt_parts)	{
		do
			if (pt_nd->pt->pc_objNm)
				free( (void *) pt_nd->pt->pc_objNm);
		while (pt_nd = pt_nd->pt_nxt);
		e_FreeList( &pt_parts, TRUE);
	} //if (pt_nd = pt_parts)
	if (bid_ctntStrt.pool)
		OSUnlockBlock( bid_ctntStrt);
	if (pv_file)	{
		ef_closeAndDeleteFile( pv_file, pc_fileNm);
		free( pc_fileNm);
	}
	if (pt)	{
		OSUnlockBlock( bid_ctnt);
		if (t_ctnt.pc_objNm)
			free( (void *) t_ctnt.pc_objNm);
	}

	return f_fail + us_err;
} //us_ExtractPgpMimeDecodable(


/** xus_TestNoteForPgpArmor( ***
Determine whether PGP-encoded file attachments occur in the specified rich-text 
field, providing differentiation between the special PGP-encoded rich-text 
object and regular encoded attachments.

--- parameters & return ----
h_NOTE: the handle to the note containing the specified rich-text field
pc_FLDNM: address of a string telling the name of the rich-text field to be 
	processed
ps_hasPgpAtchmt: Provisionally Optional Output. Address of the Visual-Basic 
	type flag in which to return whether any PGP-encoded file attachemnts were 
	found apart from the special rich-text attachment. If null, output will be 
	suppressed. At least one output must be requested within call.
ps_hasRtfObj: Provisionally Optional Output. Address of the Visual-Basic type 
	flag in which to return wehter the special PGP-encoded rich-text attachment 
	is present on the given note. If null, output will be suppressed. At least 
	one output must be requested within call.
RETURN:
	eus_ERR_INVLD_ARG if any input is obviously invalid
	!eus_SUCCESS if a rich-text cursoring error occurred
	eus_SUCCESS if no error occured
	the Notes API error code otherwise

--- revision history -------
3/14/03 PR
+ logic adjustment to take advantage of f_PgpExtension()
+ minor documentation adjustment, token renaming

9/6/02 PR
+ fixed variable-initialization bug
+ fixed bug that could give a false-positive when deciding if an attachment was 
  the special PGP-encoded rich-text attachment
+ listing format adjustment, token renaming

9/16/00 PR
+ added functionality to differentiate between the special rich-text object and 
  other PGP-encoded attachments; required a signature change
+ updated so that attachments with either PGP extension are supported
+ logic streamlining

11/12/98 PR: created		*/
STATUS xus_TestNoteForPgpArmor( const NOTEHANDLE  h_NOTE, 
								char  pc_FLDNM[], 
								short *const  ps_hasPgpAtchmt, 
								short *const  ps_hasRtfObj)	{
	static UINT  ui_lenFileNmPgpRtf;

	const WORD  us_LEN_ITEMNM = strlen( epc_ITMNM_STD_ATTCH);

	BLOCKID  bid_itm, bid_ctnt, bid_prvItm;
	const BYTE * puc;
	const FILEOBJECT * pflo;
	BOOL  f_hasRtfObj = FALSE, f_hasPgpAtchmt = FALSE, f_fail = FALSE;
	STATUS  us_err;

	if (!( h_NOTE && pc_FLDNM && (ps_hasPgpAtchmt || ps_hasRtfObj)))
		return eus_ERR_INVLD_ARG;

	if (ps_hasPgpAtchmt)
		*ps_hasPgpAtchmt = ms_VB_FALSE;
	if (ps_hasRtfObj)
		*ps_hasRtfObj = ms_VB_FALSE;

	//if it hasn't been done already, construct the filename of the special PGP 
	//	rich-text object
	if (!*mpc_fileNmPgpRtf)	{
		strcat( strcpy( mpc_fileNmPgpRtf, mpc_ROOTFILENM_PGP_RTF), 
														mpc_PGP_ARMOR_EXT_ASC);	
		ui_lenFileNmPgpRtf = strlen( mpc_fileNmPgpRtf);
	}

	//Get a handle on the first attachment item present in the note. If no such 
	//	item is present, we've determined that the answer to all the caller's 
	//	questions is negative, so short-circuit with success.
	if (us_err = NSFItemInfo( h_NOTE, epc_ITMNM_STD_ATTCH, us_LEN_ITEMNM, 
											&bid_itm, NULL, &bid_ctnt, NULL))
		if (ERR( us_err) == ERR_ITEM_NOT_FOUND)
			return eus_SUCCESS;
		else
			return us_err;

	//cycle through the attachment items (and thus object names) until we've 
	//	gleaned as much information useful to our purpose as we can...
	do	{
		//if the object name given by the item matches the name of the special 
		//	PGP rich-text object...
		pflo = (FILEOBJECT *) (OSLockBlock( WORD, bid_ctnt) + 1);
		puc = (BYTE *) (pflo + 1);
		if (ui_lenFileNmPgpRtf == pflo->FileNameLength && strnicmp( puc, 
											mpc_fileNmPgpRtf, 
											ui_lenFileNmPgpRtf) == ei_SAME)	{
			//if the caller wants to be told this information...
			if (ps_hasRtfObj)	{
				//make a note of it
				f_hasRtfObj = TRUE;

				//if the caller doesn't need to be told whether a regular 
				//	PGP-encoded attachment is present or if it's already known 
				//	that one is present, we need go no further, so break out of 
				//	the loop
				if (!ps_hasPgpAtchmt || f_hasPgpAtchmt)	{
					OSUnlockBlock( bid_ctnt);
					break;
				}
			} //if (ps_hasRtfObj)
		//else if the caller wants to know whether a regular PGP-encoded 
		//	attachment is present and this is still not known and the 
		//	associated object name sports one of the PGP extensions...
		}else if (ps_hasPgpAtchmt && !f_hasPgpAtchmt)	{
			if (f_PgpExtension( puc, pflo->FileNameLength))	{
				//make a note that such an attachment is present
				f_hasPgpAtchmt = TRUE;

				//if the caller doesn't need to be told whether the special 
				//	rich-text object is present or if it's already known that 
				//	it is present, we need go no further, so break out of the 
				//	loop
				if (!ps_hasRtfObj || f_hasRtfObj)	{
					OSUnlockBlock( bid_ctnt);
					break;
				}
			} //if (f_PgpExtension( puc, pflo->FileNameLength))
		} //if (ui_lenFileNmPgpRtf == pflo->FileNameLength && strnicmp(

		//get a handle on the next attachment item in the note
		OSUnlockBlock( bid_ctnt);
		bid_prvItm = bid_itm;
		if ((us_err = NSFItemInfoNext( h_NOTE, bid_prvItm, epc_ITMNM_STD_ATTCH, 
											us_LEN_ITEMNM, &bid_itm, NULL, 
											&bid_ctnt, NULL)) && 
											ERR( us_err) != ERR_ITEM_NOT_FOUND)
			return us_err;
	} while (!us_err);

	//if we didn't finish finding everything out by querying _object_ names, 
	//	traverse the rich-text field itself to check whether the _file_ names 
	//	(the ultimate word) in any attachment hotspots can add something...
	if (ps_hasPgpAtchmt && !f_hasPgpAtchmt || ps_hasRtfObj && !f_hasRtfObj)	{
		RtfContext  t_ctx;
		RtfCursor  t_crsr;
		const char * pc_fileNm;

		//initialize contextual information about the specified rich-text field
		if (us_err = eus_InitializeRtfContext( h_NOTE, pc_FLDNM, &t_crsr, 
																		&t_ctx))
			return us_err;

		//advance the rich-text cursor to the next file-attachment hotspot, 
		//	which (though unlikely) may be the first CD record 
		if (!ef_CursorToAttachmentHotspot( &t_crsr, &t_ctx, FALSE, NULL, 
														&pc_fileNm, NULL))	{
			ef_FreeRtfContext( &t_ctx);
			return !eus_SUCCESS;
		}

		//loop until either no further file-attachment hotspots exist in the 
		//	rich-text field (or until we've determined the information 
		//	requested by caller)
		while (t_crsr.puc_location)	{
			//if we didn't know of it before and just now hit on the special 
			//	rich-text object...
			if (ps_hasRtfObj && !f_hasRtfObj && stricmp( pc_fileNm, 
											mpc_fileNmPgpRtf) == ei_SAME)	{
				//if caller wants to know whether the object is present, note 
				//	that it is and break out of the loop if there's nothing 
				//	left to find out
				if (ps_hasRtfObj)	{
					f_hasRtfObj = TRUE;
					if (!ps_hasPgpAtchmt || f_hasPgpAtchmt)
						break;
				}
			//Else if caller wants to know whether regular PGP-encoded 
			//	attachments are present and none have been located yet...
			}else if (ps_hasPgpAtchmt && !f_hasPgpAtchmt)	{
				//if we've hit on one, note that it is and break out of the 
				//	loop if there's nothing left to find out
				if (f_PgpExtension( pc_fileNm, strlen( pc_fileNm)))	{
					f_hasPgpAtchmt = TRUE;
					if (!ps_hasRtfObj || f_hasRtfObj)
						break;
				}
			} //if (stricmp( pc_fileNm, mpc_fileNmPgpRtf)

			//advance the rich-text cursor to the next file-attachment hotspot
			if (f_fail = !ef_CursorToAttachmentHotspot( &t_crsr, &t_ctx, TRUE, 
														NULL, &pc_fileNm, NULL))
				break;
		} //while (t_crsr.puc_location)

		//free the contextual information about the rich-text field
		ef_FreeRtfContext( &t_ctx);

		if (f_fail)
			return !eus_SUCCESS;
	} //if (ps_hasPgpAtchmt || ps_hasRtfObj &&

	//inform caller of any positive findings
	if (f_hasPgpAtchmt)
		*ps_hasPgpAtchmt = ms_VB_TRUE;
	if (f_hasRtfObj)
		*ps_hasRtfObj = ms_VB_TRUE;

	return eus_SUCCESS;
} //xus_TestNoteForPgpArmor(


/** us_LocatePgpRtfAttachment( ***
Locates the special PGP-encoded rich-text attachment to the message, if any.

--- parameters & return ----
t_crsr: Notes rich-text cursor marking the point from which to search the 
	message for the special PGP-encoded rich-text attachment
pt_CTX: address of opaque environment information about the rich-text field 
	we're working with
h_NOTE: handle to the note containing the rich-text field we're working with
pul_objId: Address of variable to receive the identifer associated with the 
	special attachment being sought. Variable is set only if the attachment is 
	uncompressed, and thus also signifies to caller the attachment's 
	compression status.
pul_size: address of variable to receive the size of the attachment
pbid_itm: address of variable to receive an information structure used by Notes 
	to describe the file-attachment item associated with the attachment
RETURN:
	eus_SUCCESS if procedure encounters no problems
	!eus_SUCCESS if an error was encountered while navigating the rich-text 
		field
	the Notes API error code otherwise

--- revision history -------
3/14/03 PR
+ minor signature change to provide appropriate constness
+ completed standard documentation, token renaming

9/6/02 PR: logic performance enhancement, token renaming, listing format 
	adjustment
9/16/00 PR: token renaming
9/12/99 PR: added smart differentiation between compressed & non-compressed 
	files
1/30/99 PR: created			*/
static STATUS us_LocatePgpRtfAttachment( RtfCursor  t_crsr, 
											const RtfContext *const  pt_CTX, 
											const NOTEHANDLE  h_NOTE, 
											DWORD *const  pul_objId, 
											DWORD *const  pul_size, 
											BLOCKID *const  pbid_itm)	{
	const char * pc_objNm, * pc_fileNm;
	BOOL  f_Match = FALSE, f_compressed;
	DWORD  ul_objId;
	STATUS  us_err;

	_ASSERTE( t_crsr.puc_location && t_crsr.us_recLength && pul_objId && 
														pul_size && pbid_itm);

	*pul_objId = *pul_size = NULL;
	*pbid_itm = ebid_NULLBLOCKID;

	if (!NSFNoteHasObjects( (NOTEHANDLE) h_NOTE, NULL))
		return eus_SUCCESS;

	//advance the rich-text cursor to the next file-attachment hotspot, which 
	//	(though unlikely) may be the first CD record 
	if (!ef_CursorToAttachmentHotspot( &t_crsr, pt_CTX, FALSE, NULL, 
														&pc_fileNm, &pc_objNm))
		return !eus_SUCCESS;

	//Loop either until no further file-attachment hotspots exist in the 
	//	rich-text field or until the PGP rich-text attachment is found. We 
	//	search for the special attachment using this technique first in case 
	//	more than one version of the PGP rich-text attachment exists on the 
	//	document. If there is more than one, we should default to the one 
	//	actually present in the RTF because that one must be the most recent 
	//	version.
	if (!*mpc_fileNmPgpRtf)
		strcat( strcpy( mpc_fileNmPgpRtf, mpc_ROOTFILENM_PGP_RTF), 
														mpc_PGP_ARMOR_EXT_ASC);
	while (t_crsr.puc_location)	{
		//A file-attachment hotspot must have been found, so determine whether 
		//	the "original" name of the attachment as stored in the hotspot 
		//	matches the filename we're after. If we have found a match, break 
		//	out of this loop to move on to the next stage
		if (f_Match = stricmp( pc_fileNm, mpc_fileNmPgpRtf) == ei_SAME)
			break;

		//advance the rich-text cursor to the next file-attachment hotspot
		if (!ef_CursorToAttachmentHotspot( &t_crsr, pt_CTX, TRUE, NULL, 
														&pc_fileNm, &pc_objNm))
			return !eus_SUCCESS;
	} //while (t_crsr.puc_location)

	//Get the necessary location info for the caller to use in accessing the 
	//	attachment. If we didn't find a corresponding attachment hotspot in the 
	//	rich-text field, we will accept a properly named attachment not 
	//	incorporated.
	if (!f_Match)
		pc_objNm = mpc_fileNmPgpRtf;
	if (us_err = eus_getAttachmentInfo( h_NOTE, NULL, pc_objNm, &ul_objId, 
													pul_size, &f_compressed, 
													NULL, pbid_itm, NULL))
		return us_err;

	//if the file is not compressed, set the object ID return variable, thus 
	//	signifying that the file is uncompressed [important later to 
	//	eus_getObjectContentsInBuffer()]
	if (!f_compressed)
		*pul_objId = ul_objId;

	return us_err;
} //us_LocatePgpRtfAttachment(


/** xus_SetupPgpRtfObj( ***
Purpose is to work the special PGP rich-text attachment and its associated 
rich-text hotspot associated into a user- and system-friendly state. 
User-friendly by making it hidden and system-friendly by having it behave as 
needed (even if that means getting rid of it).

--- parameter & return ----
h_NOTE: the handle to the note containing the hotspots to be converted
pc_FLDNM: the name of the message-body rich-text field
RETURN:
	eus_SUCCESS if no errors occurred
	eus_ERR_INVLD_ARG if any input parameter is obviously invalid
	the Notes API error code otherwise

--- revision history ------
3/14/03 PR: listing format adjustment, token renaming
9/6/02 PR: minor logic adjustments for performance and in support of signature 
	change to eus_getAttachmentInfo, listing format adjustment, token renaming, 
	minor documentation adjustment

9/16/00 PR
+ updated so that attachments with either PGP extension are supported
+ changed name of function to better reflect its work
+ token renaming

1/29/99 PR: created			*/
STATUS xus_SetupPgpRtfObj( const NOTEHANDLE  h_NOTE, 
							char  pc_FLDNM[])	{
	static const char  pc_NOTES_MAIL_MATCH[] = "Lotus Notes Release";
	static char  pc_ITMNM_MAILER[] = "$Mailer";		//MAIL_MAILER_ITEM not 
													//	defined in 4.5.1 API

	RtfContext  t_ctx, t_ctxAttachPgrph;
	RtfCursor  t_crsr;
	RtfSpan  t_span;
	const char * pc_fileNm;
	char * pc_objNm, * pc;
	BOOL  f_utilRtfStarted = FALSE, f_mailedByNotes = TRUE, f_fail;
	BLOCKID  bid_ctnts, bid_itm;
	STATUS  us_err;

	if (!( h_NOTE && pc_FLDNM))
		return eus_ERR_INVLD_ARG;

	//if there aren't any attachments, short-circuit with success
	if (!NSFNoteHasObjects( h_NOTE, NULL))
		return eus_SUCCESS;

	//initialize resources associated with the rich-text handling we're going 
	//	to do
	if (us_err = eus_InitializeRtfContext( h_NOTE, pc_FLDNM, &t_crsr, &t_ctx))
		return us_err;

	//advance the rich-text cursor to the next file-attachment hotspot, which 
	//	(though unlikely) may be the first CD record
	if (f_fail = !ef_CursorToAttachmentHotspot( &t_crsr, &t_ctx, FALSE, 
												&t_span, &pc_fileNm, &pc_objNm))
		goto errJump;

	//search for a special PGP-encoded rich-text attachment hotspot in the 
	//	rich-text field
	if (!*mpc_fileNmPgpRtf)
		strcat( strcpy( mpc_fileNmPgpRtf, mpc_ROOTFILENM_PGP_RTF), 
														mpc_PGP_ARMOR_EXT_ASC);
	while (t_crsr.puc_location && stricmp( pc_fileNm, mpc_fileNmPgpRtf) != 
																		ei_SAME)
		if (f_fail = !ef_CursorToAttachmentHotspot( &t_crsr, &t_ctx, TRUE, 
												&t_span, &pc_fileNm, &pc_objNm))
			goto errJump;

	//determine whether the message was mailed by Notes
	if (us_err = eus_AttemptCopyTextItemContent( h_NOTE, pc_ITMNM_MAILER, 
															NULL, &pc, NULL))
		goto errJump;
	if (pc)	{
		f_mailedByNotes = strnicmp( pc, pc_NOTES_MAIL_MATCH, sizeof( 
										pc_NOTES_MAIL_MATCH) - 1) == ei_SAME;
		free( pc);
	}

	//if a rich-text hotspot was found associated with the special rich-text 
	//	attachment...
	if (t_crsr.puc_location)	{
		//remove current hotspot because one way or another it's got to go
		if (us_err = eus_RemoveRtSpan( &t_span, &t_ctx))
			goto errJump;

		//if the message wasn't mailed by Notes...
		if (!f_mailedByNotes)	{
			//delete the attachment associated with the removed 
			//	special-attachment hotspot since it's very unlikely that its 
			//	contents are valid (e.g. the attachment originated in a Notes 
			//	plug-in client-sent e-mail to a non-Notes e-mail client, then 
			//	the attachment was forwarded on to a plug-in-enabled Notes 
			//	client, so the attachment contains the contents of the original 
			//	message, not the forwarded message, not a good thing)
			if (us_err = eus_DeleteAttachment( h_NOTE, pc_objNm, NULL))
				if (ERR( us_err) != ERR_ITEM_NOT_FOUND)
					goto errJump;
				else
					us_err = eus_SUCCESS;
		//else eliminate the possibility of the special PGP rich-text 
		//	attachment being inherited into documents created via the @Command( 
		//	[MailForward]) mechanism or via forms having the "Inherit entire 
		//	selected document into the rich-text field ... as rich-text" 
		//	setting...
		}else	{
			//initialize the rich-text hidden paragraph we will use to store the 
			//	special object
			if (us_err = us_SetupRtfAttachParagraph( h_NOTE, &t_ctxAttachPgrph, 
																	pc_objNm))
				goto errJump;
			f_utilRtfStarted = TRUE;

			//Append the special ending hidden-paragraph rich-text to the our 
			//	adjusted main rich-text field. Since both above-mentioned 
			//	mechanisms ignore whatever's in hidden paragraphs, this method 
			//	avoids the inheritance issue and is cosmetically attractive to boot.
			if (us_err = eus_AppendItemsToRtf( &t_ctxAttachPgrph, &t_ctx))
				goto errJump;
		} //if (f_mailedByNotes)

		//commit the updated rich-text field to the note, replacing the current 
		//	actual rich-text content
		us_err = eus_CommitChangedRtf( h_NOTE, pc_FLDNM, &t_ctx);
	//Else if the special PGP rich-text attachment is present without a 
	//	corresponding hotspot, the message probably came into the system via 
	//	the client POP3/IMAP4 "Direct to Internet" mechanism...
	}else if (us_err = eus_getAttachmentInfo( h_NOTE, NULL, mpc_fileNmPgpRtf, 
														NULL, NULL, NULL, NULL, 
														&bid_itm, &bid_ctnts))
		goto errJump;
	else if (bid_ctnts.pool)	{
		//if the message was put in the mail by Notes...
		if (f_mailedByNotes)	{
			//Change the "host type" of the special attachment to a type that 
			//	Notes will not inherit into documents created via the 
			//	mechanisms described above. This is an acceptable thing to do 
			//	for _received_ messages, since this message won't be going 
			//	through a SMTP MTA anymore, so we don't care about the fact 
			//	that the MTA will not forward attachments with the STREAM host 
			//	type. Another nice by-product of doing this is that the 
			//	attachment will not show up "below the line" on the message 
			//	(i.e. it'll be hidden)
			FILEOBJECT *const  ptfo = (FILEOBJECT *) (OSLockBlock( WORD, 
																bid_ctnts) + 1);

			ptfo->HostType = HOST_STREAM;
			OSUnlockBlock( bid_ctnts);
		//else delete the special attachment since it's very unlikely that 
		//	its contents remain valid (e.g. the attachment originated in a 
		//	Notes plug-in client-sent e-mail to a non-Notes e-mail client, then 
		//	the attachment was forwarded on to a plug-in-enabled Notes client, 
		//	so the attachment contains the contents of the original message, 
		//	not the forwarded message, not a good thing)
		}else
			us_err = NSFNoteDetachFile( h_NOTE, bid_itm);
	} //if (us_err = eus_getAttachmentInfo(

errJump:
	if ((us_err || f_fail) && f_utilRtfStarted)
		ef_FreeRtfContext( &t_ctxAttachPgrph);
	ef_FreeRtfContext( &t_ctx);

	return us_err + f_fail;
} //xus_SetupPgpRtfObj(


/** DllMain( ***
Win32 entry point for loading and unloading this DLL.  We use the unload 
event to free statically allocated resources.

--- parameters & return ---
h_DllInstance: the overall handle to this DLL's runtime information, settings
ul_reason: parameter tells why the function was called
pv_reserved: just that, reserved

--- revision history ------
3/20/00 PR
+ support of rich-text reset functionality, part of changes needed for 
  Notes Mail R5-template compatibility 
+ adjustment in support of PGP 7.0

11/18/98 PR: created		*/
BOOL WINAPI DllMain( HINSTANCE  h_DllInstance, 
						DWORD  ul_reason, 
						LPVOID  pv_reserved)	{
	switch (ul_reason)	{
		case DLL_PROCESS_ATTACH:
			//Set up debugging aids and the memory-leak detector in 
			//	particular.  Lines are preprocessed out in Release builds.
			_CrtSetReportMode( _CRT_WARN, _CRTDBG_MODE_DEBUG | 
														_CRTDBG_MODE_WNDW);
			_CrtSetDbgFlag( _CRTDBG_LEAK_CHECK_DF | 
										_CrtSetDbgFlag( _CRTDBG_REPORT_FLAG));

			//keep ahold of the instance handle
			eh_Instance = h_DllInstance;

			//for some efficiency gain, tell system there's no need to tell 
			//	our DLL about thread attachment & detachment
			if (!DisableThreadLibraryCalls( h_DllInstance))
				return FALSE;

			break;

		case DLL_PROCESS_DETACH:
			//free any resources still allocated to a copy of rich-text 
			//	content stored in memory
			if (mt_RtfResettable.h_content)
				OSMemFree( mt_RtfResettable.h_content);
	} //switch (ul_reason)

	return TRUE;
} //DllMain(


/** eus_PreMailSend( ***
Purpose is to take any PGP action necessary before the message gets sent on to 
MAIL.BOX as the current mail-send event is carried through.

--- parameters & return ----
ppv_ARGV: address of the series of arguments provided by the PGP @DbCommand 
	used to call this DLL
ph: Output. Address of variable to receive handle to what will be the 
	@Formula's output content, a Notes number giving the code number of any 
	unanticipated error that occurred.
pul: Output. Address of variable to receive length of the @Formula's output 
	content.
RETURN:
	eus_SUCCESS if successful
	eus_ERR_INVLD_ARG if any input is obviously invalid

--- revision history -------
3/14/03 PR
+ signature adjustment to add error output and to change to a regular status 
  return value
+ listing format adjustment, documentation adjustment, token renaming, minor 
  exception-handling improvement

9/6/02 PR: minor documentation adjustment

3/20/00 PR
+ support of rich-text reset functionality, part of changes needed for Notes 
  Mail R5-template compatibility
+ token renaming

9/12/99 PR
+ logic adjustment to support enhancement of better emulation of Lotus Notes' 
  name lookup behavior
+ documentation adjustment, logic shortening

1/23/99 PR: created			*/
STATUS eus_PreMailSend( void *const  ppv_ARGV[], 
						HANDLE *const  ph, 
						DWORD *const  pul)	{
	const int  i_ARG_HANDLE = 0, i_ARG_PGP_FLGS = 1, i_ARG_RECIP_NMS = 2, 
				i_ARG_LKUP_EXHAUST = 3, i_ARG_LKUP_HOW = 4, i_ARG_ATCHMTS = 5, 
				i_ARG_RTF_FLDNM = 6;
	const char  pc_PGPFLG_SIGN[] = "SI", pc_PGPFLG_ENCRYPT[] = "EN";

	double  d;
	NOTEHANDLE  h_note;
	char * pc_fldNmRtf = NULL, * pc_lkupHow = NULL, * pc_recipList = NULL;
	BOOL  f_PgpSign, f_PgpEncrypt, f_lkupExhaust = FALSE, f_fail = FALSE;
	int  i_atchmts = 0;
	DWORD  ul;
	BYTE * puc;
	STATUS  us_err;
	short  s_err = NULL;

	if (!( ppv_ARGV && *ppv_ARGV && ph && pul))
		return eus_ERR_INVLD_ARG;

	//recover the handle to the calling note's session
	if (!ef_GetNumberListEntry( ppv_ARGV[ i_ARG_HANDLE], TRUE, 0, &d))	{
		us_err = eus_ERR_INVLD_ARG;
		goto errJump;
	}
	h_note = (NOTEHANDLE) (DWORD) d;

	//determine what sort of PGP encoding is to be performed
	f_PgpSign = ef_TextListContainsEntry( ppv_ARGV[ i_ARG_PGP_FLGS], TRUE, 
													pc_PGPFLG_SIGN, NULL, NULL);
	f_PgpEncrypt = ef_TextListContainsEntry( ppv_ARGV[ i_ARG_PGP_FLGS], TRUE, 
												pc_PGPFLG_ENCRYPT, NULL, NULL);

	//get the recipient-list string
	if (us_err = eus_CreateTextListEntryCopy( 0, ppv_ARGV[ i_ARG_RECIP_NMS], 
														TRUE, &pc_recipList))
		goto errJump;
	if (!pc_recipList && f_PgpEncrypt)	{
		us_err = eus_ERR_INVLD_ARG;
		goto errJump;
	}

	//if PGP security has been specified to be performed and if the list of 
	//	recipient names contains someone...
	if ((f_PgpSign || f_PgpEncrypt) && pc_recipList)	{
		//get the name of the rich-text field to process
		if ((us_err = eus_CreateTextListEntryCopy( 0, ppv_ARGV[ 
									i_ARG_RTF_FLDNM], TRUE, &pc_fldNmRtf)) || 
									(f_fail = !pc_fldNmRtf))
			goto errJump;

		//if we're to encrypt...
		if (f_PgpEncrypt)	{
			//get the number of attachments associated with the note
			if (!ef_GetNumberListEntry( ppv_ARGV[ i_ARG_ATCHMTS], TRUE, 0, 
																	&d))	{
				us_err = eus_ERR_INVLD_ARG;
				goto errJump;
			}
			i_atchmts = (int) d;

			//get the name of the user's mail (home) server
			if (us_err = eus_CreateTextListEntryCopy( 0, ppv_ARGV[ 
											i_ARG_LKUP_HOW], TRUE, &pc_lkupHow))
				goto errJump;
			if (!pc_lkupHow && !(pc_lkupHow = calloc( 1, sizeof( char))))
				goto errJump;

			//determine whether caller wants name lookups to be "exhaustive"
			if (f_fail = !ef_GetNumberListEntry( ppv_ARGV[ i_ARG_LKUP_EXHAUST], 
																TRUE, 0, &d))
				goto errJump;
			f_lkupExhaust = (BOOL) d;
		} //if (f_PgpEncrypt)

		//Initialize the information structure we use to hold onto a copy of 
		//	the PGP-encoded rich-text field we will be constructing. We may 
		//	need to reset the note's rich-text field to the PGP-encoded version 
		//	if the encoding was initiated by a user press of the "Send and 
		//	File" action button.
		if (mt_RtfResettable.h_note)	{
			OSMemFree( mt_RtfResettable.h_content);
			mt_RtfResettable.h_content = NULL;
		}
		mt_RtfResettable.h_note = h_note;

		//Prepare the message for sending in a PGP-secured manner. If failure 
		//	is encountered, flag that the structure used to hold a copy of the 
		//	PGP-encoded rich-text field is empty.
		if (s_err = xs_PgpSecureMessage( h_note, f_PgpSign, f_PgpEncrypt, 
										pc_recipList, f_lkupExhaust, 
										pc_lkupHow, i_atchmts, pc_fldNmRtf, 
										i_atchmts ? (ef_TextListContainsEntry( 
										ppv_ARGV[ i_ARG_PGP_FLGS], TRUE, 
										mpc_PGPFLG_HOTSPOT_6, NULL, NULL) ? 
										mpc_PGPFLG_HOTSPOT_6 : 
										mpc_PGPFLG_HOTSPOT_5) : NULL, 
										&mt_RtfResettable))
			mt_RtfResettable.h_note = NULL;
	} //if ((f_PgpSign || f_PgpEncrypt) && 

errJump:
	//free resources allocated via this procedure
	if (pc_recipList)
		free( pc_recipList);
	if (pc_fldNmRtf)
		free( pc_fldNmRtf);
	if (pc_lkupHow)
		free( pc_lkupHow);

	if (eus_SUCCESS == OSMemAlloc( NULL, ul = sizeof( WORD) + sizeof( RANGE) + 
													sizeof( NUMBER), ph))	{
		puc = (BYTE *) OSLockObject( *ph);
		memset( puc, NULL, ul);
		*((WORD *) puc)++ = TYPE_NUMBER_RANGE;
		(((RANGE *) puc)++)->ListEntries = 1;
		*(NUMBER *) puc = (double) (us_err + s_err + f_fail);
		OSUnlockObject( *ph);
		*pul = ul;
	}else
		return us_err + s_err + f_fail;

	return eus_SUCCESS;
} //eus_PreMailSend(


/** es_ReplaceMimeWithRtf( ***
Replaces the specified string of MIME-part fields with a previously stored 
Notes rich-text stream.

--- parameter & return ----
ppv_ARGV: address of the series of arguments provided by the PGP @DbCommand 
	used to call this DLL
RETURN:
	eus_SUCCESS if no errors occurred
	eus_ERR_INVLD_ARG if any input parameter is obviously invalid
	the Notes API error code otherwise

--- revision history ------
3/14/03 PR
+ signature adjustment in support of maintaining constness
+ listing format adjuatment, minor documentation adjustment

9/6/02 PR: listing format adjustment, minor exception-handling adjustment, 
	minor documentation adjustment
3/20/00 PR: created			*/
short es_ReplaceMimeWithRtf( void *const  ppv_ARGV[])	{
	const int  i_ARG_HANDLE = 0, i_ARG_RTF_FLDNM = 1;
	const WORD  us_TYPE_MIME_PART = 0x0019;

	NOTEHANDLE  h;
	double  d = NULL;
	char * pc;
	WORD  us;
	BOOL  f_RtfContextSet = FALSE;
	BYTE * puc;
	RtfContext  t;
	STATUS  us_err;

	if (!( ppv_ARGV && *ppv_ARGV && mt_RtfResettable.h_content))
		return eus_ERR_INVLD_ARG;

	//Recover the handle to the calling note's session. If it doesn't 
	//	correspond to the note associated with the previously stored rich-text 
	//	stream, short-circuit with failure.
	if (!( ef_GetNumberListEntry( ppv_ARGV[ i_ARG_HANDLE], TRUE, 0, &d) && d))
		return eus_ERR_INVLD_ARG;
	if ((h = (NOTEHANDLE) (DWORD) d) != mt_RtfResettable.h_note)
		return eus_ERR_INVLD_ARG;

	//obtain the name of the items to be replaced
	if (us_err = eus_CreateTextListEntryCopy( 0, ppv_ARGV[ i_ARG_RTF_FLDNM], 
																	TRUE, &pc))
		return (short) us_err;
	if (!*pc)	{
		us_err = eus_ERR_INVLD_ARG;
		goto errJump;
	}

	//if the first of the named items is not of type MIME Part, short-circuit 
	//	with failure
	if (us_err = NSFItemInfo( h, pc, (WORD) strlen( pc), NULL, &us, NULL, 
																	NULL))	{
		if (ERR( us_err) == ERR_ITEM_NOT_FOUND)
			us_err = eus_ERR_INVLD_ARG;
		goto errJump;
	}
	if (us != us_TYPE_MIME_PART)	{
		us_err = eus_ERR_INVLD_ARG;
		goto errJump;
	}

	//remove the MIME-part items
	if (us_err = eus_RemoveItem( h, pc, ebid_NULLBLOCKID))
		goto errJump;

	//set up a replacement field based on the already stored stream of rich-text
	puc = OSLockObject( mt_RtfResettable.h_content);
	us_err = eus_ReplaceRtfWithCdStream( puc, mt_RtfResettable.ul_len, 
												ept_InitUtilityRtfContext( &t));
	OSUnlockObject( mt_RtfResettable.h_content);
	f_RtfContextSet = TRUE;
	if (us_err)
		goto errJump;

	//commit the rich-text to the note under the same name used by the 
	//	MIME-part items
	us_err = eus_CommitChangedRtf( h, pc, &t);

errJump:
	//If an error occurred, free resources allocated to the stored version, and 
	//	flag that this has been done. We don't free if no error occurred 
	//	because the rich-text stream may be resed in the note's post-save (R5) 
	//	or query-close (R4) events.
	if (us_err)	{
		OSMemFree( mt_RtfResettable.h_content);
		memset( &mt_RtfResettable, NULL, sizeof( ResettableRtfInfo));
	}

	if (f_RtfContextSet)
		ef_FreeRtfContext( &t);
	if (pc)
		free( pc);

	return (short) us_err;
} //es_ReplaceMimeWithRtf(


/** xs_VetPluginReadiness( ***
Determines (or assists the subform in determining) whether the calling plug-in 
subform is compatible with this DLL component of the plug-in.

--- parameter & return ----
pc_PLGN_VER_SUBFM: address of string stating the version of the calling PGP 
	Plug-In subform
pc_MIN_CPTBL_VER_DLL: Optional. Address of string stating what the subform 
	considers the minimum version of this DLL with which it is compatible. If 
	null, procedure will consider that version to be the subform's own version, 
	meaning that a downlevel DLL is incompatible.
ps_status: Optional Output. Address of variable in which to store the relative 
	state of the subform component's version to this DLL component's version. 
	The output value mirrors what we would expect from a "cmp" function: Result 
	is less than zero if subform < DLL, zero if subform = DLL, greater than 
	zero if subform > DLL.
pc_instldVer: Optional Output, but required if ps_status output is requested. 
	Address of string buffer in which to copy the version of this DLL in case 
	the subform component is interested (as it might well be if the subform 
	component is of later version than the DLL).
ps_unEngaged: Optional Output, but required if ps_status output is requested. 
	Address of VisualBasic flag variable in which to note whether this DLL has 
	been loaded by the Notes client on a session-long basis (i.e. whether it's 
	been loaded yet as a "database driver" extension).
ps_prvIncompatibilityFound: Optional Output, but required if ps_status output 
	is requested. Address of VisualBasic flag variable in which to note whether 
	incompatibility had been found in a previous compatibility check during 
	this DLL session.
pv_hDll: Optional Output, but required if ps_status output is requested. 
	Address of variable in which to store the module handle of this DLL in case 
	the subform wishes to force the unloading of the DLL in order to replace it 
	with a preferred DLL of earlier or later version.
RETURN:
	eus_ERR_INVLD_ARG if any input parameter is found to be invalid
	eus_SUCCESS if this DLL is compatible with the calling subform component
	ei_USER_ABORT it this DLL is incompatible with the calling subform component

--- revision history ------
6/8/04 PR: upgraded plug-in version string to 2.3.3
8/21/03 PR : upgraded plug-in version string to 2.3.2
7/21/03 PR: upgraded plug-in version string to 2.3.1

6/26/03 PR
+ logic adjustment so function remembers incompatibility if DLL is noted as 
  incompatible because its version is less than that required by subform

3/14/03 PR: upgraded plug-in version string to 2.3
10/30/02 PR: upgraded plug-in version string to 2.2.2
9/6/02 PR: upgraded plug-in version string to 2.2.1, minor exception-handling 
	improvement

7/2/01 PR
+ Logic enhancment in support of overhaul of plug-in initialization. Included 
  addition of five output parameters following the two input parameters (the 
  first original, the second new). Procedure still supports old versions of the 
  plug-in subform which pass just the one input parameter.
+ updated plug-in version string to 2.2; minor token renaming

4/24/01 PR: updated plug-in version string to 2.1.8
11/16/00 PR: updated plug-in version string to 2.1.7
11/14/00 PR: updated plug-in version string to 2.1.6
10/7/00 PR: created			*/
short xs_VetPluginReadiness( const char  pc_PLGN_VER_SUBFM[], 
								const char  pc_MIN_CPTBL_VER_DLL[], 
								short *const  ps_status, 
								char  pc_instldVer[], 
								short *const  ps_unEngaged, 
								short *const  ps_prvIncompatibilityFound, 
								HMODULE *const  pv_hDll)	{
	static const char  pc_PLGN_VER_DLL[] = "2.3.3", 
						pc_MIN_CPTBL_VER_SUBFM[] = "2.1.6";

	static BOOL  f_incompatibilityFound;

	int  i_mainRslt, i_rslt, i_err;
	BOOL  f_compatible, f_downwardCptblPossibility = FALSE;

	if (!( pc_PLGN_VER_SUBFM && *pc_PLGN_VER_SUBFM))
		return eus_ERR_INVLD_ARG;

	//if the caller is using the latest version of this function which has 
	//	seven parameters instead of one...
	if (ps_status)	{
		//if any of the other "new" output parameters are obviously invalid...
		if (!( pc_instldVer && ps_unEngaged && ps_prvIncompatibilityFound && 
																	pv_hDll))
			//short-circuit with failure
			return eus_ERR_INVLD_ARG;

		//initialize all the "new" output parameters
		*pv_hDll = (HMODULE *) (*ps_status = *ps_unEngaged = 
							*ps_prvIncompatibilityFound = *pc_instldVer = NULL);

		//if the provided minimum-compatible DLL version was provided...
		if (pc_MIN_CPTBL_VER_DLL && *pc_MIN_CPTBL_VER_DLL)	{
			//if that DLL version is obviously invalid, short-circuit with 
			//	failure
			if (i_err = ei_verCmp( pc_MIN_CPTBL_VER_DLL, pc_PLGN_VER_SUBFM, 
																	&i_rslt))
				return (short) i_err;
			if (i_rslt > ei_SAME)	{
				if (!f_incompatibilityFound)
					f_incompatibilityFound = TRUE;
				else
					*ps_prvIncompatibilityFound = ms_VB_TRUE;
				return eus_ERR_INVLD_ARG;
			} //if (i_rslt > ei_SAME)

			//if the subform component supports any downlevel versions of the 
			//	DLL component, take note of that
			if (i_rslt < ei_SAME)
				f_downwardCptblPossibility = TRUE;
		} //if (pc_MIN_CPTBL_VER_DLL &&
	} //if (ps_status)

	//if this DLL's version is the same as the subform component's...
	if (i_err = ei_verCmp( pc_PLGN_VER_SUBFM, pc_PLGN_VER_DLL, &i_mainRslt))
		return (short) i_err;
	if (i_mainRslt == ei_SAME)	{
		//short-circuit with success
		if (ps_status)	{
			*ps_status = i_mainRslt;
			*ps_unEngaged = ef_LoadedSessionLong ? ms_VB_FALSE : ms_VB_TRUE;
			*ps_prvIncompatibilityFound = f_incompatibilityFound ? 
													ms_VB_TRUE : ms_VB_FALSE;
			*pv_hDll = eh_Instance;
		}
		return eus_SUCCESS;
	} //if (i_rslt == ei_SAME)

	//if this DLL's version is greater than the subform component's...
	if (i_mainRslt < ei_SAME)	{
		//determine whether the subform component is still compatible with this 
		//	DLL
		if (i_err = ei_verCmp( pc_PLGN_VER_SUBFM, pc_MIN_CPTBL_VER_SUBFM, 
																	&i_rslt))
			return (short) i_err;
		f_compatible = i_rslt >= ei_SAME;
	//else if the calling subform supports certain downlevel DLLs...
	}else if (f_downwardCptblPossibility)	{
		//determine whether this DLL is still compatible with the subform 
		//	component
		if (i_err = ei_verCmp( pc_PLGN_VER_DLL, pc_MIN_CPTBL_VER_DLL, &i_rslt))
			return (short) i_err;
		f_compatible = i_rslt >= ei_SAME;
	//else declare the subform component incompatible since we can't know any 
	//	better
	}else
		f_compatible = FALSE;

	//if the caller is using the latest version of this function which has 
	//	seven parameters instead of one, fill out the expected outputs
	if (ps_status)	{
		*ps_status = i_mainRslt;
		strcpy( pc_instldVer, pc_PLGN_VER_DLL);
		*ps_unEngaged = ef_LoadedSessionLong ? ms_VB_FALSE : ms_VB_TRUE;
		*ps_prvIncompatibilityFound = f_incompatibilityFound ? 
													ms_VB_TRUE : ms_VB_FALSE;
		*pv_hDll = eh_Instance;
	} //if (ps_status)

	//if it hasn't been encountered already in a previous call, note whether 
	//	incompatibility has been found during this DLL session
	if (!f_incompatibilityFound)
		f_incompatibilityFound = !f_compatible;

	return f_compatible ? eus_SUCCESS : (short) ei_USER_ABORT;
} //xs_VetPluginReadiness(


/** xs_PgpSecureMessage( ***
PGP encode the specified Notes Mail message (meaning its Notes rich-text field 
and any associated file attachments) according to caller instructions.

--- parameters & return ----
h_NOTE: handle to the note to undergo PGP encoding
f_sign: flag telling whether the message should be PGP signed
f_encrypt: flag telling whether the message should be PGP encrypted
pc_recipList: Optional. Address of a string of user addresses, delimited by 
	semicolon, to be used in the encoding process. The "addresses" will be 
	fully resolved as needed against the Domino Directory. Required only if PGP 
	encryption is specified. String may not be preserved because strtok() may 
	be used to parse the string.
f_LOOKUP_EXHAUST: Optional. Flag telling whether the addresses provided will be 
	checked exhaustively for ambiguity against the Domino Directory 
	configuration currently employed by the caller. Required only if PGP 
	encryption is specified.
pc_lkupHow: Optional. Address of the name of the server holding the Domino 
	Directory to be used potentially in the resolution process. Required only 
	if PGP encryption is specified. String may not be preserved because strtok() 
	may be used to parse the string.
i_ATTCHMTS: Optional. The number of attachments included in the message. 
	Ignored if PGP encryption is not specified.
pc_FLDNM: address of string telling the name of the rich-text field to be 
	used in the encoding
pc_HOTSPT_VER: Optional. Address of string telling which style to use when 
	writing the special attachment-action hotspots for PGP-encoded attachments. 
	If null, style will default to what's expected for the version of Notes 
	currently being run.
pt_RtfResettable: Optional Input & Output. Address of the information structure 
	which may be used in later resetting the message's rich-text field to the 
	encoded version to be created by this procedure. The need for this 
	functionality is driven by peculiarities of the "Send and File" action 
	button in the R5 version of the Notes Mail template and of the R5 client's 
	MIME rendering during mailing. The h_note property of the information 
	structure is used as a safety check on the execution of this functionality. 
	In the context of this procedure, it is used to ensure the caller is aware 
	of what it's doing in using this parameter by checking that its value 
	equals that specified in the primary h_NOTE parameter described above. The 
	t_RtfContext property of the structure will be filled upon successful 
	completion of this procedure. If parameter is null, the procedure 
	understands that the rich-text field reset functionality has not been 
	engaged by the caller.
RETURN: eus_SUCCESS if no error occured; the Notes API error code otherwise

--- revision history -------
3/14/03 PR
+ signature and logic adjustment in support of Notes-version-specific writing 
  of the special attachment-action hotspots written for PGP-encoded attachments
+ logic enhancement in support of enabling the Tempest viewer in the plug-in
+ minor documentation adjustment, token renaming

10/30/02 PR: logic enhancement to support gracefully user-cancelation during 
	key-server searches
9/6/02 PR: listing format adjustment, token renaming, minor documentation 
	adjustment

3/20/00 PR
+ support of rich-text reset functionality, part of changes needed for Notes 
  Mail R5-template compatibility
+ enhancement to delete the PGP-encoded rich-text attachment if error is 
  encountered after the attachment has been accomplished
+ completed standard documentation

9/12/99 PR: logic adjustments to support enhancement of better emulation of 
	Lotus Notes' name-lookup behavior, including removal of recipient-count 
	parameter

1/19/99 PR: created			*/
//					static FILE * Log;
STATUS xs_PgpSecureMessage( const NOTEHANDLE  h_NOTE, 
							BOOL  f_sign, 
							BOOL  f_encrypt, 
							char  pc_recipList[], 
							const BOOL  f_LOOKUP_EXHAUST, 
							char  pc_lkupHow[], 
							const int  i_ATTCHMTS, 
							const char  pc_FLDNM[], 
							const char  pc_HOTSPT_VER[], 
							ResettableRtfInfo *const  pt_RtfResettable)	{
	const BOOL  f_RESETTABLE = pt_RtfResettable && pt_RtfResettable->h_note;

	RtfCursor  t_crsr;
	RtfContext  t_rtCtx, t_rtCtxUtil;
	char * * ppc_recips = NULL, * pc_outp = NULL;
	UINT  ui_recips;
	PgpEncodeContext  t_encdCtx;
	BOOL  f_PgpEncdCtxSetUp = FALSE, f_RtfAttchPgraph = FALSE, f_SyncUnkKeys, 
			f_ambig, f_fail = FALSE;
	BLOCKID  bid_itmAttch;
	STATUS  us_err;
	int  i_err = NULL;

	_ASSERTE( h_NOTE && (f_sign || f_encrypt) && (f_encrypt ? (BOOL) 
									pc_recipList : TRUE) && pc_FLDNM && 
									(f_RESETTABLE ? pt_RtfResettable->h_note == 
									h_NOTE : TRUE));
/*if (!( Log = fopen( "nPGPLog.txt", "wtc")))
	return !eus_SUCCESS;
if (setvbuf( Log, NULL, _IONBF, NULL) != eus_SUCCESS)
	return !eus_SUCCESS;
fprintf( Log, "Started message log\n");
fclose( Log);
Log = fopen( "nPGPLog.txt", "atc");
setvbuf( Log, NULL, _IONBF, NULL);
*/
	//initialize resources associated with the rich-text handling we're going 
	//	to do
	if (us_err = eus_InitializeRtfContext( h_NOTE, pc_FLDNM, &t_crsr, 
																	&t_rtCtx))
		return us_err;

	//initialize the PGP context for encoding content
	if (i_err = ei_SetUpPgpEncodeContext( f_sign = !!f_sign, f_encrypt = 
									!!f_encrypt, &t_encdCtx, &f_SyncUnkKeys))
		goto errJump;
	f_PgpEncdCtxSetUp = TRUE;

	//if message is to be encrypted...
	if (f_encrypt)	{
		//as much as possible, resolve recipient addressses and create a 
		//	character-string array of the addresses, the format expected by the 
		//	PGP infrastructure
		if (us_err = us_CreateRecipientsArray( pc_recipList, 
											!!f_LOOKUP_EXHAUST, pc_lkupHow, 
											&ppc_recips, &ui_recips, &f_ambig))
			goto errJump;

		//match as much as possible the recipient addresses with PGP keys, 
		//	wherever those keys may reside, be the addresses Notes names or 
		//	SMTP names
		if ((i_err = i_MatchPgpKeys( f_SyncUnkKeys, ui_recips, ppc_recips, 
										&t_encdCtx)) && i_err != ei_USER_ABORT)
			goto errJump;

		//obtain the final list of encryption keys for use in the ensuing 
		//	encoding, using the standard PGP client infrastructure (e.g. the 
		//	encryption-keys dialog)
		if (i_err = ei_ResolveEncryptionKeys( ppc_recips, ui_recips, f_ambig, 
													f_SyncUnkKeys, &t_encdCtx))
			goto errJump;
	} //if (f_encrypt)

	//PGP-encode all the textual content of the rich-text field into a buffer
	if (i_err = i_PgpEncodeRtfText( &t_encdCtx, &t_rtCtx, &pc_outp))
		goto errJump;

	//if necessary, PGP Armor each attachment in the message
	if (i_ATTCHMTS && f_encrypt)
		if (i_err = i_PgpEncodeAttachments( &t_encdCtx, h_NOTE, pc_HOTSPT_VER, 
															t_crsr, &t_rtCtx))
			goto errJump;

	//all manipulation done, if not overridden by user wanting use of a secure 
	//	viewer, PGP-encode the rich-text field as a PGP-Armored file and attach 
	//	it to the note and reference it in an ending, hidden paragraph
	if (!t_encdCtx.f_asciiOnlyBdy)	{
		f_RtfAttchPgraph = TRUE;
		if (i_err = i_PgpEncodeRtfAsAttachment( &t_encdCtx, h_NOTE, &t_rtCtx, 
												ept_InitUtilityRtfContext( 
												&t_rtCtxUtil), &bid_itmAttch))
			goto errJump;
	}

	//completely replace the original rich-text field with the PGP-encoded 
	//	textual content, in Courier 10 font
	if (us_err = eus_ReplaceRtfWithStandardText( pc_outp, TRUE, &t_rtCtx))
		goto errJump;

	//if not in ASCII-only mode, append the special ending hidden-paragraph 
	//	item to the new virtual rich-text field
	if (!t_encdCtx.f_asciiOnlyBdy)
		if (us_err = eus_AppendItemsToRtf( &t_rtCtxUtil, &t_rtCtx))
			goto errJump;

	//Commit the updated rich-text field to the note, replacing the current 
	//	actual rich-text content
	if (us_err = eus_CommitChangedRtf( h_NOTE, pc_FLDNM, &t_rtCtx))
		if (!t_encdCtx.f_asciiOnlyBdy)
			ef_UnappendRtfItems( &t_rtCtxUtil, &t_rtCtx);

errJump:
	if (pc_outp)
		free( pc_outp);

	//if an error occurred and context for PGP's hidden rich-text paragraph has 
	//	been initialized...
	if ((i_err || us_err) && f_RtfAttchPgraph)	{
		//if the encoded version of the rich-text field has been encapsulated 
		//	as an attachment to the note, remove that attachment
		if (us_err)
			f_fail = NSFNoteDetachFile( h_NOTE, bid_itmAttch);

		//free any resources allocated to PGP's hidden rich-text paragraph
		ef_FreeRtfContext( &t_rtCtxUtil);
	} //if ((i_err || us_err) && f_RtfAttchPgraph)

	if (f_PgpEncdCtxSetUp)
		f_fail = !ef_FreePgpEncodeContext( &t_encdCtx);
	if (ppc_recips)
		e_FreeStringArray( &ppc_recips, ui_recips);
	_ASSERTE( !f_fail);

	//if caller wants a copy of the encoded version of the rich-text field 
	//	available for a potential reset of the field later, copy the version 
	//	content into memory
	if (f_RESETTABLE && !(us_err || i_err))
		us_err = eus_CopyRtfIntoBuffer( &t_rtCtx, &pt_RtfResettable->h_content, 
											&pt_RtfResettable->ul_len, NULL);

	//free all resources associated with the encoded rich-text field 
	//	constructed by this procedure
	ef_FreeRtfContext( &t_rtCtx);

	return us_err + (short) i_err;
} //xs_PgpSecureMessage(


/** i_PgpEncodeAttachments( ***
PGP encode the attachments referenced in a given rich-text field, and customize 
the associated attachment hotspots to give us control over the decoding 
process, at least when invoked from the Notes client.

--- parameters & return ----
pt_encdCtx: Input & Output. Address of the PGP information structure 
	being used in the current round of encoding. The opaque structure may be 
	updated if user adjusts presented defaults.
h_NOTE: handle to the note to which the encoded rich-text field will be 
	attached as an attachment
pc_HOTSPT_VER: Optional. Address of string telling which style to use when 
	writing the special attachment-action hotspots for PGP-encoded attachments. 
	If null, style will default to what's expected for the version of Notes 
	currently being run.
t_crsr: rich-text cursor set to where the search should start for attachemnt 
	hotspots whose parent attachments should be encoded
pt_rtCtx: Input & Output. Address of the rich-text context structure describing 
	the rich-text field to be searched and updated with PGP-encoded 
	attachment-action hotspots. Structure may undergo change even if an error 
	occurs.
RETURN: eus_SUCCESS if successful; the Notes API or PGP SDK error code if 
	unsuccessful

--- suggested enhancment ---
3/20/00 PR: any way to improve safety by providing roll-back if something goes 
	wrong?
  3/14/03 PR: A good start would be to make two passes through the field. The 
		first to detach, encode & wipe (in that order). The second to 
		hotspot-fixup, replace-attach & wipe (in that order).

--- revision history -------
3/14/03 PR
+ signature change and logic adjustment in support of Notes-version-specific 
  writing of the special action-attachment hotspots written for PGP-encoded 
  attachments
+ logic adjustment to take advantage of f_PgpExtension()
+ logic enhancement in support of enabling the Tempest viewer in the plug-in

9/6/02 PR
+ logic enhancement to support high-ASCII (international) characters in 
  attachment handling
+ token renaming, listing format adjustment, minor buffer tightening

9/16/00 PR: completed enhancement associated with improved handling of 
  PGP-encoded attachments

8/9/00 PR
+ got rid of hack for attaching encoded files without Notes trying to sign them 
  when sending the message in MIME format
+ started enhancement associated with improved handling of PGP-encoded 
  attachments

5/30/00 PR
+ extension to wrap attachments within an action hotspot that allows for custom 
  handling
+ standard documentation, improved safety handling

3/20/00 PR: enhancement to prevent attachments already PGP encoded from being 
	encoded again; associated documentation adjustments, logic shortening
9/12/99 PR: documentation adjustment
1/30/99 PR: created			*/
static int i_PgpEncodeAttachments( PgpEncodeContext *const  pt_encdCtx, 
									const NOTEHANDLE  h_NOTE, 
									const char  pc_HOTSPT_VER[], 
									RtfCursor  t_crsr, 
									RtfContext *const  pt_rtCtx)	{
	const WORD  us_LEN_ITMNM_STD_ATTCH = (WORD) strlen( epc_ITMNM_STD_ATTCH);

	static char  pc_dirNmTemp[ MAXPATH - 2];
	char * pc_objNm, * pc_fileNm;
	RtfSpan  t_span;
	BLOCKID  bid;
	STATUS  us_err;
	int  i_err, i_error;

	_ASSERTE( pt_encdCtx && pt_encdCtx->f_Encrypt && h_NOTE && 
								t_crsr.puc_location && t_crsr.us_recLength && 
								pt_rtCtx && NSFItemIsPresent( h_NOTE,
								epc_ITMNM_STD_ATTCH, us_LEN_ITMNM_STD_ATTCH));

	//if this is the first time through, initialize the path to the user's 
	//	temporary directory
	if (!*pc_dirNmTemp)
		if (!epc_getTempDirNm( pc_dirNmTemp, MAXPATH - 2))
			return !eus_SUCCESS;

	//advance the rich-text cursor to the next file-attachment hotspot, which 
	//	may be the current CD record 
	if (!ef_CursorToAttachmentHotspot( &t_crsr, pt_rtCtx, FALSE, &t_span, 
														&pc_fileNm, &pc_objNm))
		return !eus_SUCCESS;

	//loop until no further file-attachment hotspots exist in the rich-text 
	//	field
	while (t_crsr.puc_location)	{
		//if the attachment hasn't already been PGP encoded, get the attachment 
		//	item that corresponds to the attachment referenced in the hotspot
		bid.pool = NULL;
		if (!f_PgpExtension( pc_fileNm, strlen( pc_fileNm)))
			if (us_err = eus_getAttachmentInfo( h_NOTE, epc_ITMNM_STD_ATTCH, 
														pc_objNm, NULL, NULL, 
														NULL, NULL, &bid, NULL))
				return us_err;

		//if the attachment should be encoded...
		if (bid.pool)	{
			char  pc[ MAXPATH], * pc_fileNmNew, pc_extFileNmTmp[ MAXPATH], 
					pc_extFileNmNewOs[ MAXPATH], pc_extFileNmNew[ MAXPATH];

			//if the ultimate filename would exceed the maximum length allowed, 
			//	short-circuit with failure
			if (strlen( pc_fileNm) + mui_LEN_ARMOR_EXT_ASC + 1 > 
														mi_MAXLEN_ATTCH_OBJNM)
				return !eus_SUCCESS;

			//Extract the attachment to a file in the user's temporary 
			//	directory. Need to use the real file name so PGP will default 
			//	to this name when the file is ultimately decoded from the file 
			//	system by the user.
			if (us_err = NSFNoteExtractFile( (NOTEHANDLE) h_NOTE, bid, 
										strcat( strcpy( pc_extFileNmTmp, 
										pc_dirNmTemp), pc_fileNm), NULL))	{
				_ASSERTE( !(ERR( us_err) == ERR_NOEXTRACT_ENCRYPTED || ERR( 
											us_err) == ERR_NOTE_BADATTSIGN));
				return us_err;
			}

			//translate our filename to the native character set
			if (!OSTranslate( OS_TRANSLATE_LMBCS_TO_NATIVE, pc_extFileNmTmp, 
											(WORD) strlen( pc_extFileNmTmp), 
											pc, sizeof( pc)))
				return !eus_SUCCESS;

			//PGP encode the file
			i_err = ei_PgpEncodeFile( pt_encdCtx, pc, strcat( strcpy( 
														pc_extFileNmNewOs, pc), 
														mpc_PGP_ARMOR_EXT_ASC));

			//delete the original file copied to the temporary directory 
			if (i_error = ei_PgpWipeFile( pc))	{
				int i_err = remove( pc);
				_ASSERTE( i_err == eus_SUCCESS);
			}

			//if any error occurred during PGP encoding or deletion, 
			//	short-circuit with failure
			if (i_err)
				return i_err;
			if (i_error)
				return i_error;

			//if we're not in ASCII-only mode, wrap a PGP action hotspot around 
			//	the file-attachment hotspot
			if (!pt_encdCtx->f_asciiOnlyBdy)	{
				strcat( strcpy( pc_extFileNmNew, pc_extFileNmTmp), 
														mpc_PGP_ARMOR_EXT_ASC);
				if (us_err = us_ActionWrapAttachment( &t_span, pc_fileNmNew = 
										strrchr( pc_extFileNmNew, 
										ec_PATH_SPECIFIER) + 1, NULL, h_NOTE, 
										TRUE, pc_HOTSPT_VER, pt_rtCtx))
					return us_err;
			} //if (!pt_encdCtx->f_asciiOnlyBdy)

			//write the encoded file back into the mail database as a file 
			//	object, replacing the file's unencoded counterpart
			if (us_err = NSFNoteDetachFile( (NOTEHANDLE) h_NOTE, bid))
				return us_err;
//PGP SHORTCUT: not checking on unique attachment name!!
			if (us_err = eus_AttachFileAsObject( pc_extFileNmNewOs, NULL, 
												h_NOTE, epc_ITMNM_STD_ATTCH, 
												pc_fileNmNew, HOST_MSDOS))
				return us_err;

			//Delete the encoded file written to the temporary directory. 
			//	Ignore any failure of this operation.
			if (ei_PgpWipeFile( pc_extFileNmNewOs) != eus_SUCCESS)	{
				i_error = remove( pc_extFileNmNewOs);
				_ASSERTE( i_error == eus_SUCCESS);
			}
		} //if (bid.pool)

		//advance the rich-text cursor to the next file-attachment hotspot
		if (!ef_CursorToAttachmentHotspot( &t_crsr, pt_rtCtx, TRUE, &t_span, 
														&pc_fileNm, &pc_objNm))
			return !eus_SUCCESS;
	} //while (t_crsr.puc_location)

	return eus_SUCCESS;
} //i_PgpEncodeAttachments(


/** us_ActionWrapAttachment( ***
Wraps the specified Notes rich-text file-attachment hotspot with a custom 
action hotspot that enables custom PGP handling.

--- parameters & return ------
pt_SPN: Optional. Address of rich-text span structure giving the cordinates of 
	a file-attachment hotspot to be wrapped. Null address signifies that a new 
	generic file-attachment hotspot should be constructed and wrapped at the 
	end of the rich-text field (used for below-the-line attachments that don't 
	have asssociated hotspots in the rich-text).
pc_FILENM: address of string giving the filename of the attachment being wrapped
pc_OBJNM: Optional. Address of string giving the object name of the attachment 
	being wrapped. If null, the object name will be set in the default manner 
	used by our module handling rich-text processing.
h_NOTE: Required only if pc_OBJNM provided. Handle to the note being operated 
	upon.
f_RESET: If rich-text span input is provided, flag tells whether filenames 
	within the file-attachment hotspot should be reset to reflect the filename 
	given in pc_FILENM. If no rich-text span input is provided, flag tells 
	whether a new paragraph should be started before adding the attachment 
	hotspot.
pt_ctx: Input & Output. Address of the rich-text context structure describing 
	the rich-text field to be searched and updated with PGP-encoded 
	attachment-action hotspots. Structure may undergo change even if an error 
	occurs.
RETURN: eus_SUCCESS if no error occured; the Notes API error code otherwise

--- suggested enhancement ----
10/11/03 PR: see in-lined to-do
9/6/02 PR: get rid of PGP development shortcut

--- revision history ---------
3/14/03 PR
+ signature and logic adjustment in support of Notes-version-specific writing 
  of the special attachment-action hotspots written for PGP-encoded attachments 
  (basically, make the hotspot "empty" and so non-clickable, but still present 
  for Notes user-interface behavior purposes)
+ documentation correction
+ token renaming
9/6/02 PR: created via adaptation of existing code		*/
static STATUS us_ActionWrapAttachment( const RtfSpan *const  pt_SPN, 
										const char  pc_FILENM[], 
										const char  pc_OBJNM[], 
										const NOTEHANDLE  h_NOTE, 
										const BOOL  f_RESET, 
										const char  pc_HOTSPT_VER[], 
										RtfContext *const  pt_ctx)	{
	static const char *const  ppc_FRMULA[] = { "%s%s%s%s%s%s%s", 
								"@If( !@IsNumber( xn_hNote);\n\t@Command( "
								"[AttachmentProperties]) & @Return(\"\");"
								"\n\t\"\");\n\nv_result := @DbCommand( "
								"\"PGP\"; \"", "\" : \"", "\"; xn_hNote);"
								"\n\n@If( @IsError( v_result);\n\t@Prompt( "
								"[OK]; \"", "\"; \"An error occurred in "
								"handling the PGP encrypted attachment, \" + "
								"@Char(10) + \"translated by Notes as \\\"\" + "
								"@Text( v_result) + \"\\\"\" + @Repeat( "
								"@Char(10); 2) + \"The usual Notes attachment "
								"commands are still available.\") & @Command( "
								"[AttachmentProperties]);\n\t\"\")"}, 
						pc_ENCRYPTD_TAG[] = "<PGP_encrypted> ";

	static const BYTE * puc_gnericAttchBmp;
	static WORD  us_lenGnericAttchBmp;
	static BOOL  f_Notes6;

	char  pc[ 0x400];
	RtfCursor  t_crsr, * pt_crsr;
	RtfContext  t_ctxUtil;
	STATUS  us_err;
	BOOL  f_fail = FALSE;

	_ASSERTE( (pt_SPN ? pt_SPN->t_crsrBgin.puc_location && 
											pt_SPN->t_crsrBgin.us_recLength : 
											TRUE) && pt_ctx);

	//if caller hasn't given particular PGP-encoded-attachment-hotspot encoding 
	//	instructions...
	if (!(pc_HOTSPT_VER && *pc_HOTSPT_VER))	{
		//Assume the encoding type according to what version of Notes wes're 
		//	running. If Notes 6, the special Notes-6 type, else the traditional 
		//	type.
		if (!mus_build)	{
			DBHANDLE  h;
			NSFNoteGetInfo( (NOTEHANDLE) h_NOTE, _NOTE_DB, &h);
			NSFDbGetBuildVersion( h, &mus_build);
			mf_Notes6 = mus_build >= mus_BLD_1ST_6;
		}
		f_Notes6 = mf_Notes6;
	//else take note of which type of encoding we're to do
	}else
		f_Notes6 = strcmp( pc_HOTSPT_VER, mpc_PGPFLG_HOTSPOT_6) == ei_SAME;

	//initialize a pointer to the primary rich-text cursor we'll be using to 
	//	navigate the hotspot during the encoding
	pt_crsr = pt_SPN ? &pt_SPN->t_crsrBgin : memset( &t_crsr, NULL, 
															sizeof( RtfCursor));

	//if this is a below-the-line attachment...
	if (!pt_SPN)
		//initialize a utility rich-text context into which we will construct 
		//	what we need
		ept_InitUtilityRtfContext( &t_ctxUtil);
	//else if the attachment hotspot is immediately preceded by the opening of 
	//	an action hotspot, we'll assume that it has already been wrapped with 
	//	the PGP-handling action hotspot (e.g. this may be a recursive 
	//	decoding), and so just short-circuit with success
	else	{
		BOOL  f;
//TODO: figure out how to catch collapsed Notes6-style specially handled 
//	attachments!!
		if (us_err = eus_ActionHotspotJustBefore( pt_crsr, pt_ctx, &f))
			return us_err;
		if (f)
			return eus_SUCCESS;
	} //if (!pt_SPN)

	//if caller wants an attachment hotspot constructed as well and has further 
	//	specified that a new paragraph should first be added, add a visible 
	//	paragraph
	if (!pt_SPN && f_RESET)
		if (us_err = eus_AppendRtParagraph( 
0xCBA8, 
										&mt_RT_PGRPH_NORMAL, &t_ctxUtil, NULL))
			goto errJump;

	//write head & guts of wrapper action hotspot that will allow custom PGP 
	//	attachment handling
	sprintf( pc, ppc_FRMULA[0], ppc_FRMULA[1], pc_FILENM, ppc_FRMULA[2], 
							pc_FILENM, ppc_FRMULA[3], epc_APPNM, ppc_FRMULA[4]);
	if (us_err = eus_StartFormulaActionHotspot( pc, pt_crsr, pt_SPN ? 
														pt_ctx : &t_ctxUtil))
		goto errJump;

	//if caller's having us construct the attachment hotspot as well...
	if (!pt_SPN)	{
		char  pc_objNm[ mi_MAXLEN_ATTCH_OBJNM] = {NULL};

		//if not done yet, load the resource containing the generic attachment 
		//	bitmap CD records we will need
		if (!puc_gnericAttchBmp)	{
			const HRSRC h_RSRC = FindResource( eh_Instance, MAKEINTRESOURCE( 
										mi_IDR_BLANK_ATTACH_CDS), RT_RCDATA);

			HGLOBAL  h;

			if (f_fail = !h_RSRC)
				goto errJump;
			if (f_fail = !( us_lenGnericAttchBmp = (WORD) SizeofResource( 
														eh_Instance, h_RSRC)))
				goto errJump;
			if (f_fail = !( h = LoadResource( eh_Instance, h_RSRC)))
				goto errJump;
			if (f_fail = !(puc_gnericAttchBmp = LockResource( h)))
				goto errJump;
		} //if (!puc_gnericAttchBmp)

		//Insert graphic and the name of the file in the manner of what the 
		//	Domino SMTP mail-receiver normally constructs for attachments. 
		//	If we're in Notes 6, append the graphic and text, outside of an 
		//	attachment hotspot since Notes 6 attachments are difficult to 
		//	manage for PGP plug-in purposes
		strcat( strcpy( pc, " - "), pc_FILENM);
		if (f_Notes6)
			if (us_err = eus_AppendCdsToRtf( puc_gnericAttchBmp, 
											us_lenGnericAttchBmp, &t_ctxUtil))
				goto errJump;

		//Append an attachment hotspot. If we're in Notes 6, it will be an 
		//	"empty" hotspot, our workaround for the aspects of Notes 6 
		//	attachment hotspots that are difficult to manage for PGP plug-in 
		//	purposes. If not in Notes 6, it will include the generic-hotspot CD 
		//	records and so will be clickable as a normal attachment if the 
		//	plug-in can't for some reason handle the click action.
		if (pc_OBJNM)
			strcpy( pc_objNm, pc_OBJNM);
		if (us_err = eus_InsertAttachHotspot( pt_crsr, pc_FILENM, pc_objNm, 
								h_NOTE, f_Notes6 ? NULL : puc_gnericAttchBmp, 
								(WORD) (f_Notes6 ? NULL : 
								us_lenGnericAttchBmp), f_Notes6 ? pc : NULL, 
								f_Notes6 ? NULL : pc, NULL, NULL, &t_ctxUtil))
			goto errJump;

		//tack on an end-hotspot record to close our wrapper action hotspot
		if (us_err = eus_InsertHotspotEnd( *pt_crsr, &t_ctxUtil))
			goto errJump;

		//append our work to the main rich-text field being procecessed
		return eus_AppendItemsToRtf( &t_ctxUtil, pt_ctx);

errJump:
		ef_FreeRtfContext( &t_ctxUtil);
		return us_err + f_fail;
	//else if caller wants to reset the filenames held by the hotspot...
	}else if (f_RESET)	{
		//if we're in Notes 6, we need to work around the aspects of Notes 6 
		//	attachment hotspots that are difficult to manage for PGP plug-in 
		//	purposes...
		if (f_Notes6)	{
			RtfCursor  t_crsr = *pt_crsr;

			//first, copy the graphic elements in the current hotspot to follow 
			//	just after the beginning of the action hotspot started above
			if (us_err = eus_AppendHotspotInnardsToVirtuality( &t_crsr, pt_ctx))
				return us_err;

			//next, add a tag indicating the attachment is PGP encoded (because 
			//	the hotspot picture is not being changed and probably provides 
			//	the non-PGP-encoded filename)
			if (us_err = eus_InsertTextAtHotspotEnd( pc_ENCRYPTD_TAG, t_crsr, 
																		pt_ctx))
				return us_err;

			//Last, reset the filenames in the attachment hotspot to refer to 
			//	the PGP-encoded versions of themselves. This has the happy 
			//	byproduct of collapsing the attachment hotspot so it won't 
			//	interfere with the operation of our special-dialog-invoking 
			//	action hotspot.
			if (us_err = eus_ResetAttachHotspotNames( pc_FILENM, pc_OBJNM && 
											*pc_OBJNM ? pc_OBJNM : pc_FILENM, 
											*pt_crsr, TRUE, pt_ctx))
				return us_err;
		}else	{
//PGP development shortcut: not checking for unique filenames!
			//reset the filenames and add a tag indicating the attachment is 
			//	PGP encoded (because the hotspot picture is not being changed 
			//	and probably provides the non-PGP-encoded filename)
			if (us_err = eus_ResetAttachHotspotNames( pc_FILENM, pc_OBJNM && 
											*pc_OBJNM ? pc_OBJNM : pc_FILENM, 
											*pt_crsr, FALSE, pt_ctx))
				return us_err;
			if (us_err = eus_InsertTextAtHotspotEnd( pc_ENCRYPTD_TAG, *pt_crsr, 
																		pt_ctx))
				return us_err;
		} //if (f_Notes6)
	//else if we're in Notes 6, adjust the positioning of the attachment 
	//	hotspot to work around the aspects of Notes 6 attachment hotspots that 
	//	are difficult to manage for PGP plug-in purposes
	}else if (f_Notes6)	{
		RtfSpan t = *pt_SPN;
		if (us_err = eus_CollapseToEndAttachWrap( &t, pt_ctx))
			return us_err;
	} //if (!pt_SPN)

	//advance a rich-text cursor to just past the attachment's end-hotspot 
	//	record, and insert there the end-hotspot record to close our wrapper 
	//	action hotspot (thus producing two end-hotspot records in a row, oh boy)
	t_crsr = pt_SPN->t_crsrEnd;
	pt_crsr = &t_crsr;
	if (us_err = eus_CursorAdvance( pt_crsr, pt_ctx))
		return us_err;
	return eus_InsertHotspotEnd( *pt_crsr, pt_ctx);
} //us_ActionWrapAttachment(


/** es_SpecialDecryptAttachment( ***
Carries out for a particular attachment the plug-in's special treatment of 
PGP-encrypted attachments.

--- suggested enhancement ---
10/7/00 PR: enable the <Esc> key for canceling the dialog!

--- side effect -------------
If the user executes the launch, not the extract, choice from the choice dialog 
shown, the extended filename of the launched file will be added to the 
associated text-list item on the note, thus notifying front-end code that the 
file should be deleted when the parent message is closed.

--- parameters & return -----
ppv_ARGV: Address of the series of arguments provided by the associated PGP 
	@DbCommand used to call this DLL. First element provides the object name 
	and the original filename of the PGP-encrypted attachment to be handled. 
	Second element provides the handle of the note currently being processed 
	and containing the target attachment.
RETURN:
	eus_SUCCESS if no errors occurred
	eus_ERR_INVLD_ARG if any input parameter is obviously invalid
	!eus_SUCCESS if a Windows API error occurs
	the Notes API error code otherwise

--- revision history -------
10/11/03 PR: fixed bug somehow introduced where detachment of encrypted files 
	was not working
7/21/03 PR: logic improvement for safety (prevent crashes) to prevent crash if 
  expected attachment is not found (as may occur if multiple attachments of the 
  same name are attached to a message)

3/14/03 PR
+ signature adjustment in support of maintaining constness
+ fixed bug somehow introduced where file detachment was not working, though 
  file launching was

9/6/02 PR
+ logic enhancement to support high-ASCII (international) characters in 
  attachment handling
+ minor exception-handling adjustment, listing format adjustment, minor 
  documentation adjustment

10/7/00 PR: bug fixes, adjusted "launched" item's name
9/16/00 PR: completed code
8/9/00 PR: created			*/
short es_SpecialDecryptAttachment( void *const  ppv_ARGV[])	{
	static const char * ppc_OVR_WRT[] = { "%s%s%s", "The file \'", 
												"\' already exists.\n\nDo you "
												"wish to overwrite it?"};

	//static so last filename is maintained between calls
	static char  pc_extFileNm[ MAXPATH];

	BYTE * puc_names;
	double  dbl;
	NOTEHANDLE  h;
	char  * pc_objNm, * pc_fileNm = NULL, * pc, 
			* pc_outFileNmOs = NULL, pc_fileNmOs[ 0x60], 
			pc_LaunchExtFileNm[ MAXPATH] = {NULL}, pc_buf[ MAXPATH + 40];
	int  i_choice;
	DlgIoExtract  t_in = { NULL, pc_extFileNm, &i_choice};
	BLOCKID  bid;
	BOOL  f_extPgp;
	STATUS  us_err;
	int  i_err;

	//validate environment, short-circuiting if we fail
	if (!(*(WORD *) (puc_names = ppv_ARGV[0]) == TYPE_TEXT_LIST && 
									ef_GetNumberListEntry( ppv_ARGV[1], TRUE, 
									0, &dbl) && (h = (NOTEHANDLE) (long) dbl)))
		return eus_ERR_INVLD_ARG;
	if (us_err = eus_CreateTextListEntryCopy( 0, puc_names, TRUE, &pc_objNm))
		return us_err;
	if (us_err = eus_CreateTextListEntryCopy( 1, puc_names, TRUE, &pc_fileNm))
		goto errJump;
	if (!( *pc_objNm && *pc_fileNm))	{
		us_err = eus_ERR_INVLD_ARG;
		goto errJump;
	}

	//after completing its inputs, show the extract-choice dialog
	if (!OSTranslate( OS_TRANSLATE_LMBCS_TO_NATIVE, pc_fileNm, (WORD) strlen( 
													pc_fileNm), pc_fileNmOs, 
													sizeof( pc_fileNmOs)))	{
		us_err = !eus_SUCCESS;
		goto errJump;
	}
	t_in.pc_fileNm = pc_fileNmOs;
	if ((i_err = DialogBoxParam( eh_Instance, MAKEINTRESOURCE( 
									mi_IDD_EXTRACT), eh_mainWnd, 
									f_DlgProcExtract, (long) &t_in)) <= 0)	{
		us_err = !eus_SUCCESS;
		goto errJump;
	}

	//if choice was to cancel, short-circuit with success
	if (i_err == mi_CANCEL)	{
		i_err = eus_SUCCESS;
		goto errJump;
	}

	//if our code intentionally threw an error...
	if (i_err != mi_SUCCESS)	{
		//short-circuit with failure
		us_err = !eus_SUCCESS;
		goto errJump;
	//else clear the error variable for future use
	}else
		i_err = eus_SUCCESS;

	//if the user chose to extract, not launch, the file...
	if (us_err = eus_getAttachmentInfo( h, NULL, pc_objNm, NULL, NULL, NULL, 
															NULL, &bid, NULL))
		goto errJump;
	if (!bid.pool)	{
		us_err = ERR_ITEM_NOT_FOUND;
		goto errJump;
	}
	if ((i_choice & mi_IDC_RD_EXTR) == mi_IDC_RD_EXTR)	{
		//ensure that a PGP extension is included for the extract location, as 
		//	the file will be extracted initially in its encoded state
		if (!(f_extPgp = f_PgpExtension( pc = pc_extFileNm, strlen( 
																pc_extFileNm))))
			pc = strcat( pc_extFileNm, mpc_PGP_ARMOR_EXT_ASC);
	//else the choice must be to decode & launch the file, so set the extract 
	//	location into the user's "temp" directory
	}else	{
		if (!epc_getTempDirNm( pc_LaunchExtFileNm, MAXPATH))	{
			us_err = !eus_SUCCESS;
			goto errJump;
		}
		pc = strcat( pc_LaunchExtFileNm, pc_fileNmOs);
	} //if ((i_choice & mi_IDC_RD_EXTR) ==

	//if a file of the same name already exists in the location just 
	//	determined, inform user, allowing her to abort
	if (ei_FileAccess( pc, ei_FILE_ACCS_EXIST, TRUE) == eus_SUCCESS)	{
		sprintf( pc_buf, ppc_OVR_WRT[0], ppc_OVR_WRT[1], pc, ppc_OVR_WRT[2]);
		if (IDNO == MessageBox( eh_mainWnd, pc_buf, epc_APPNM, MB_YESNO | 
															MB_ICONQUESTION))
			goto errJump;
	}

	//extract the file in its encoded state to the location just determined
	if (!OSTranslate( OS_TRANSLATE_NATIVE_TO_LMBCS, pc, (WORD) strlen( pc), 
												pc_buf, sizeof( pc_buf)))	{
		us_err = !eus_SUCCESS;
		goto errJump;
	}
	if (us_err = NSFNoteExtractFile( h, bid, pc_buf, NULL))			
		goto errJump;

	//if we need to do more than just extract the file in its encoded state...
	if (i_choice != mi_IDC_RD_EXTR)	{
		int  i_error;

		//decode the file just extracted
		i_err = ei_PgpDecodeFile( pc, &pc_outFileNmOs);

		//safe erase (wipe) the encoded file
		if (i_error = ei_PgpWipeFile( pc))	{
			int i_err = remove( pc);
			_ASSERTE( i_err == eus_SUCCESS);
		}

		//if any problem occurred during the decode or erase, short-circuit 
		//	with failure
		if (i_err)	{
			if (i_err == ei_USER_ABORT)
				i_err = eus_SUCCESS;
			goto errJump;
		}
		if (i_error)	{
			i_err = i_error;
			goto errJump;
		}

		//if choice was to just decrypt and the decoded file does not have the 
		//	same name as what the user specified in the dialog... (PGP includes 
		//	the original decoded filename when encoding *.pgp files and inists 
		//	on using it when decoding. Also, the "shared" codebase may adjust 
		//	filenames in another way as well, it seems. In any case, there 
		//	seems to be no foolproof way to specify the output filename.)
		if (i_choice & mi_MASK_DCRYPTD && strnicmp( pc_outFileNmOs, 
											pc_extFileNm, strlen( 
											pc_outFileNmOs)) != ei_SAME)	{
			//produce the extended filename the user asked for
			pc_extFileNm[ strlen( pc_extFileNm) - (f_extPgp ? 
												mui_LEN_ARMOR_EXT_PGP : 
												mui_LEN_ARMOR_EXT_ASC)] = NULL;

			//if a file of the same name already exists in the location...
			if (ei_FileAccess( pc, ei_FILE_ACCS_EXIST, TRUE) == 
															eus_SUCCESS)	{
				//if the user does not wish to overwrite the existing file... 
				sprintf( pc_buf, ppc_OVR_WRT[0], ppc_OVR_WRT[1], pc_extFileNm, 
																ppc_OVR_WRT[2]);
				if (IDNO == MessageBox( eh_mainWnd, pc_buf, epc_APPNM, 
											MB_YESNO | MB_ICONQUESTION))	{
					//safe erase (wipe) the decoded file, then short-circuit
					if (i_err = ei_PgpWipeFile( pc_outFileNmOs))	{
						i_error = remove( pc_outFileNmOs);
						_ASSERTE( i_error == eus_SUCCESS);
					}
					goto errJump;
				//else safe erase the file we're "overwriting"
				}else if (i_err = ei_PgpWipeFile( pc_extFileNm))	{
					int i_error = remove( pc_extFileNm);
					_ASSERTE( i_error == eus_SUCCESS);
					goto errJump;
				} //if (IDNO == MessageBox(
			} //if (ei_FileAccess( pc, ei_FILE_ACCS_EXIST) ==

			//rename the PGP generated file to the filename requested by user
			i_error = rename( pc_outFileNmOs, pc_extFileNm);
			_ASSERTE( i_error == eus_SUCCESS);
		//else if choice was to launch...
		}else if ((i_choice & mi_IDC_RD_LAUNCH) == mi_IDC_RD_LAUNCH)	{
			static char  pc_ITMNM_LAUNCHED[] = "xlt_Launched";

			//note that the decoded file should be deleted once parent 
			//	message closes
			if (!OSTranslate( OS_TRANSLATE_NATIVE_TO_LMBCS, pc_outFileNmOs, 
												(WORD) strlen( pc_outFileNmOs), 
												pc_buf, sizeof( pc_buf)))	{
				us_err = !eus_SUCCESS;
				goto errJump;
			}
			if (us_err = NSFItemAppendTextList( h, pc_ITMNM_LAUNCHED, pc_buf, 
												(WORD) strlen( pc_buf), FALSE))
				goto errJump;

			//if the file fails to launch...
			if ((i_err = (int) ShellExecute( eh_mainWnd, NULL, pc_outFileNmOs, 
										NULL, NULL, SW_SHOWNORMAL)) <= 32)	{
				const char * pc = strrchr( pc_outFileNmOs, ec_PATH_SPECIFIER);

				//inform the user
				sprintf( pc_buf, "%s%s%s", "The PGP decoded file \'", pc ? pc + 
													1 : pc_outFileNmOs, "\'\n"
													"could not be launched.");
				MessageBox( eh_mainWnd, pc_buf, epc_APPNM, MB_OK | 
															MB_ICONEXCLAMATION);

				//safe erase (wipe) the decoded file
				if (ei_PgpWipeFile( pc_outFileNmOs) != eus_SUCCESS)	{
					i_error = remove( pc_outFileNmOs);
					_ASSERTE( i_error == eus_SUCCESS);
				}
			}else
				i_err = NULL;
		} //if (i_choice & mi_MASK_DCRYPTD && strnicmp(
	} //if (i_choice != mi_IDC_RD_EXTR)

errJump:
	if (pc_outFileNmOs)
		e_FreePgpMem( pc_outFileNmOs);
	if (pc_fileNm)
		free( pc_fileNm);
	free( pc_objNm);

	return (short) (us_err ? us_err : i_err);
} //es_SpecialDecryptAttachment(


/** f_DlgProcExtract( ***
Handles Windows messages directed at the "extract" dialog.

--- parameters & return ------
H: handle of dialog window
US: message sent to dialog
ui_W: "word" parameter associated with given message. With WM_INITDIALOG, 
	specifies handle of the control the dialog template has for receipt of 
	start-up focus.
l_L: "long" parameter associated with given message. With WM_INITDIALOG 
	message, specifies dialog-initiation inputs in a DlgIoExtract instance.
RETURN:
	per the Windows API spec: TRUE if message is completely handled by this 
		routine, FALSE otherwise
	EndDialog() returns
		eus_ERR_INVLD_ARG if the necessary initiation inputs were not provided 
			in the kick-off DialogBoxParam() call
		the Windows API error code if available
		!eus_SUCCESS if an unspecified error occurred
		eus_SUCCESS otherwise

--- suggested enhancement ----
7/21/03 PR: enable <Esc> press to mean Cancel click!

--- revision history ---------
3/14/03 PR: logic adjustment to take advantage of f_PgpExtension()
9/6/02 PR: minor exception-handling adjustment
7/2/01 PR: listing format adjustment
9/16/00 PR: created			*/
static BOOL CALLBACK f_DlgProcExtract( HWND  H, 
										UINT  UI, 
										WPARAM  ui_W, 
										LPARAM  l_L)	{
	//the first time thru, specify some default state for the dialog: the 
	//	radio-button choice should be "Launch," and the "decrypted" should be 
	//	checked
	static DlgStateExtract  t_st = {NULL, mi_IDC_RD_LAUNCH, TRUE};

	DWORD  ul_err = NULL;

	switch (UI)	{
	static DlgIoExtract * pt_io;
	static BOOL  f_fileClear, f_dcryptdChecked_orig;
	static int  i_choice_orig;

	case WM_INITDIALOG:	{
		const HWND h_FOCUS = (HWND) ui_W;

		//if we obvoiously didn't get valid input from the dialog initiator or 
		//	if the focus parameter is invalid, short-circuit with failure
		pt_io = (DlgIoExtract *) l_L;
		if (!( pt_io && pt_io->pc_extFileNm && pt_io->pc_fileNm && 
									*pt_io->pc_fileNm && pt_io->pi_choice))	{
			ul_err = eus_ERR_INVLD_ARG;
			goto errJump;
		}else if (!ui_W)	{
			ul_err = !eus_SUCCESS;
			goto errJump;
		} //if (!( pt_io && pt_io->pc_extFileNm &&

		//set up the dialog and initialize state
		*pt_io->pi_choice = NULL;
		if (ul_err = ul_ExtractDlgInit( H, pt_io, h_FOCUS, &t_st))
			goto errJump;
		f_fileClear = FALSE;
		i_choice_orig = t_st.i_choice;
		f_dcryptdChecked_orig = t_st.f_dcryptdChecked;

		//store the module-scope handle to the font that may have been created 
		//	for the bolding of the static-text filename control so that the 
		//	dynamically allocated resource can be freed when we shut down
		mh_fntFileCaption = t_st.h_fntFileCaption;

		//if needed because no focus has yet been, allow default processing to 
		//	continue (error in function call is harmless, so not handled)
		return GetDlgCtrlID( h_FOCUS) == t_st.i_choice ? FALSE : TRUE;
	} //case WM_INITDIALOG

	case WM_COMMAND:
	switch (LOWORD( ui_W))	{
		char  pc[ MAXPATH];
		size_t  ui;

		case mi_IDC_DECRYPT:
		switch (HIWORD( ui_W))	{
			case BN_CLICKED:	{
				UINT  ui_len;

				//toggle the state variable tracking the current checkbox 
				//	choice and, if appropriate, reset the extended filename 
				//	accordingly
				t_st.f_dcryptdChecked = !t_st.f_dcryptdChecked;
				if (ui_len = GetWindowText( t_st.h_ebxExtFileNm, pc, 
																MAXPATH))	{
					BOOL  f = stricmp( pc + (ui = ui_len - 
											mui_LEN_ARMOR_EXT_ASC), 
											mpc_PGP_ARMOR_EXT_ASC) == ei_SAME;

					if (f && t_st.f_dcryptdChecked)	{
						pc[ ui] = NULL;
						SetWindowText( t_st.h_ebxExtFileNm, pc);
					}else if (!f && !t_st.f_dcryptdChecked && stricmp( 
										pc + ui_len - mui_LEN_ARMOR_EXT_PGP, 
										mpc_PGP_ARMOR_EXT_PGP) != ei_SAME)	{
						strcat( pc, mpc_PGP_ARMOR_EXT_ASC);
						SetWindowText( t_st.h_ebxExtFileNm, pc);
					} //if (f && t_st.f_dcryptdChecked)
				} //if (ui_len = GetWindowText( t_st.h_ebxExtFileNm,
			} //case BN_CLICKED
			} //switch (HIWORD( ui_W))
			break;

		case mi_IDC_BROWSE:
			switch (HIWORD( ui_W))	{
			case BN_CLICKED:	{
				//static for speed
				static const char  pc_FLTR[] = "All Files - *.*\0*.*\0";

				OPENFILENAME  ofn;

				//if the user canceled her navigation to the save-as choice, do 
				//	nothing
				memset( &ofn, NULL, sizeof( OPENFILENAME));
				ofn.lStructSize = sizeof( OPENFILENAME);
				ofn.hwndOwner = H;
				GetWindowText( t_st.h_ebxExtFileNm, pc, MAXPATH);
				ofn.lpstrFilter = pc_FLTR;
				ofn.lpstrFile = pc;
				ofn.nMaxFile = MAXPATH;
				ofn.Flags = OFN_ENABLESIZING | OFN_HIDEREADONLY;
				if (!GetSaveFileName( &ofn))	{
					if (ul_err = CommDlgExtendedError())
						goto errJump;

				//else set the edit-box control accordingly, accounting for 
				//	whether the user has chosen to extract the file in encoded 
				//	or decoded form...
				}else	{
					//if the user wants it extracted encoded and the returned 
					//	filename does not reflect that, tack on a standard PGP 
					//	extension to the filename
					if (!t_st.f_dcryptdChecked && strlen( pc) + 
											mui_LEN_ARMOR_EXT_ASC < MAXPATH && 
											!f_PgpExtension( pc, strlen( pc)))
						strcat( pc, mpc_PGP_ARMOR_EXT_ASC);

					//set the edit-box control
					if (!SetWindowText( t_st.h_ebxExtFileNm, pc))	{
						ul_err = GetLastError();
						goto errJump;
					}
				} //if (!GetSaveFileName( &ofn))
			} //case BN_CLICKED
			} //switch (HIWORD( ui_W))
			break;

		case mi_IDC_EXT_FILENM:
			switch (HIWORD( ui_W))	{
			case EN_CHANGE:	{
				static HWND  h;

				//if there was no text in the edit-box before this change...
				if (f_fileClear)	{
					//enable the OK button
					EnableWindow( h, TRUE);
					f_fileClear = FALSE;
				//else if all the text has been cleared from the edit-box, 
				//	disable the OK button
				}else if (!GetWindowTextLength( (HWND) l_L)) 	{
					if (!( h = GetDlgItem( H, mi_IDOK)))	{
						ul_err = GetLastError();
						goto errJump;
					}
					EnableWindow( h, FALSE);
					f_fileClear = TRUE;
				} //if (f_fileClear)
			} //case EN_CHANGE:
			} //switch (HIWORD( ui_W))
			break;

		case mi_IDOK:
			switch (HIWORD( ui_W))	{
			case BN_CLICKED:
				//output the user's choice
				if ((*pt_io->pi_choice = t_st.i_choice) == mi_IDC_RD_EXTR)	{
					GetWindowText( t_st.h_ebxExtFileNm, pt_io->pc_extFileNm, 
																	MAXPATH);
					*pt_io->pi_choice |= t_st.f_dcryptdChecked ? 
														mi_MASK_DCRYPTD : NULL;
				}
				EndDialog( H, mi_SUCCESS);
				return TRUE;
			} //switch (HIWORD( ui_W))

		case mi_IDCANCEL:
			switch (HIWORD( ui_W))	{
			case BN_CLICKED:
				//reset UI-associated variables back to the state they had when 
				//	dialog was created
				t_st.i_choice = i_choice_orig;
				t_st.f_dcryptdChecked = f_dcryptdChecked_orig;

				//return that user canceled
				EndDialog( H, mi_CANCEL);
				return TRUE;
			} //switch (HIWORD( ui_W))
	} //switch (LOWORD( ui_W))
	break;

	case WM_CLOSE:
	case WM_DESTROY:	{
		//remove the override (subclass) on the radio buttons
		if (t_st.h_rdExtract)	{
			ClearRdOverride( t_st.h_rdExtract);
			t_st.h_rdExtract = NULL;
		}
		if (t_st.h_rdLaunch)	{
			ClearRdOverride( t_st.h_rdLaunch);
			t_st.h_rdLaunch = NULL;
		}
	} //case WM_CLOSE, WM_DESTROY
	} //switch (UI)

	return FALSE;

errJump:
	//remove the override (subclass) on the radio buttons
	if (t_st.h_rdExtract)	{
		ClearRdOverride( t_st.h_rdExtract);
		t_st.h_rdExtract = NULL;
	}
	if (t_st.h_rdLaunch)	{
		ClearRdOverride( t_st.h_rdLaunch);
		t_st.h_rdLaunch = NULL;
	}

	//Return the most descriptive error possible. For GDI errors, only NT will 
	//	provide problem indication.
	if (!ul_err)
		ul_err = mt_Os.dwPlatformId == VER_PLATFORM_WIN32_NT ? GetLastError() : 
																!eus_SUCCESS;

	EndDialog( H, ul_err);
	return TRUE;
} //f_DlgProcExtract(


/** ClearRdOverride( ***
Clears out the override and associated properties set on the specified 
radio-button on the plug-in's special extract dialog.

--- parameter ----------
H: handle to the window (Extract dialog radio-button, presumably) from which 
	the override should be cleared

--- revision history ---
9/16/00 PR: created			*/
static __inline void ClearRdOverride( const HWND  H)	{
	WNDPROC  pr;

	_ASSERTE( H);

	RemoveProp( H, mpc_PROPNM_EXTR_DLG_CHOICE);
	if (pr = RemoveProp( H, mpc_PROPNM_ORIG_WNDPROC))
		SetWindowLong( H, GWL_WNDPROC, (long) pr);
} //ClearRdOverride(


/** e_FreeGdiResources( ***
Free any statically allocated Windows GDI resources.

--- revision history ---
9/16/00 PR: created			*/
void e_FreeGdiResources()	{
	if (mh_fntFileCaption)
		DeleteObject( mh_fntFileCaption);
} //e_FreeGdiResources(


/** ul_ExtractDlgInit( ***
Initializes the extract dialog before display to user.

--- parameters & return ----
H: handle of dialog window
PT: address of structure of dialog-initiation inputs
h_FOCUS: handle of the control the dialog template has for receipt of 
	start-up focus
pt_st: Input & Output. Address of information structure in which dialog state 
	is maintained. If font member (for filename static text control) is null, 
	the appropriate font will be constructed and output.  Handles to the 
	radio-button controls' windows will also be determined and output.
RETURN:
	the Windows API error code if available
	!eus_SUCCESS if an unspecified error occurred
	eus_SUCCESS otherwise

--- revision history ------
7/2/01 PR: listing format adjustment
9/16/00 PR: created			*/
static DWORD ul_ExtractDlgInit( const HWND  H, 
								const DlgIoExtract *const  PT, 
								const HWND  h_FOCUS, 
								DlgStateExtract *const  pt_st)	{
	static BOOL  f_firstTime = TRUE;

	const HWND  h_FILENM = GetDlgItem( H, mi_IDC_FILENM);

	char * pc_extFileNm;
	HWND  h_rdLaunch, h_rdExtract, h;
	WNDPROC  pr;
	size_t  ui, ui_len;
	DWORD  ul_err = NULL;

	_ASSERTE( H && pt_st && PT && PT->pc_extFileNm && PT->pc_fileNm && 
															*PT->pc_fileNm);

	//if the expected filename static-text control isn't found on the dialog, 
	//	short-circuit with failure
	if (!h_FILENM)
		return GetLastError();

	//for safety, nullify the radio-button handle outputs
	pt_st->h_rdExtract = pt_st->h_rdLaunch = NULL;

	//if this is the first time through...
	if (f_firstTime)	{
		HFONT  h_fnt = (HFONT) SendMessage( h_FILENM, WM_GETFONT, NULL, NULL);
		LOGFONT  t_fnt;

		//if we haven't already, gather info on the environment we're running 
		//	(needed for error handling below)
		if (!mt_Os.dwPlatformId)
			if (!GetVersionEx( &mt_Os))
				return GetLastError();

		//Construct the bold font we want to use with the filename static-text 
		//	control. Use the font style already associated with the control as 
		//	a base. If there's not one associated, use the common system style 
		//	instead.
		if (!h_fnt)	{
			const HDC  h_DC = GetDC( h_FILENM);

			if (!( h_DC && (h_fnt = GetCurrentObject( h_DC, OBJ_FONT))))
				goto errJump;
		}
		if (!( GetObject( h_fnt, sizeof( LOGFONT), &t_fnt)))
			goto errJump;
		t_fnt.lfWeight = FW_SEMIBOLD;
		if (!( pt_st->h_fntFileCaption = CreateFontIndirect( &t_fnt)))
			goto errJump;
	} //if (f_firstTime)

	//override (subclass) the message-dispatch procedures of the radio buttons 
	//	on the dialog so we can rect directly to a user's change in activity 
	//	choice
	if (!( h_rdLaunch = GetDlgItem( H, mi_IDC_RD_LAUNCH)))	{
		ul_err = GetLastError();
		goto errJump;
	}
	if (!( h_rdExtract = GetDlgItem( H, mi_IDC_RD_EXTR)))	{
		ul_err = GetLastError();
		goto errJump;
	}
	if (!( pr = (WNDPROC) SetWindowLong( h_rdLaunch, GWL_WNDPROC, 
												(long) WndProcExtractRdo)))	{
		ul_err = GetLastError();
		goto errJump;
	}
	pt_st->h_rdLaunch = h_rdLaunch;
	if (!SetProp( h_rdLaunch, mpc_PROPNM_ORIG_WNDPROC, pr))	{
		ul_err = GetLastError();
		goto errJump;
	}
	if (!SetProp( h_rdLaunch, mpc_PROPNM_EXTR_DLG_CHOICE, &pt_st->i_choice))	{
		ul_err = GetLastError();
		goto errJump;
	}
	if (!( pr = (WNDPROC) SetWindowLong( h_rdExtract, GWL_WNDPROC, 
												(long) WndProcExtractRdo)))	{
		ul_err = GetLastError();
		goto errJump;
	}
	pt_st->h_rdExtract = h_rdExtract;
	if (!SetProp( h_rdExtract, mpc_PROPNM_ORIG_WNDPROC, pr))	{
		ul_err = GetLastError();
		goto errJump;
	}
	if (!SetProp( h_rdExtract, mpc_PROPNM_EXTR_DLG_CHOICE, &pt_st->i_choice))	{
		ul_err = GetLastError();
		goto errJump;
	}

	//set up the dialog with user context: dialog title, target filename, 
	//	default extract path
	if (!SetWindowText( H, epc_APPNM))	{
		ul_err = GetLastError();
		goto errJump;
	}
	if (!SetWindowText( h_FILENM, PT->pc_fileNm))	{
		ul_err = GetLastError();
		goto errJump;
	}

	//emphasize the target filename by bolding it
	SendMessage( h_FILENM, WM_SETFONT, (DWORD) pt_st->h_fntFileCaption, TRUE);

	//if there's no previously entered extract filepath...
	pc_extFileNm = PT->pc_extFileNm;
	if (f_firstTime)	{
		//default it to the Notes data directory
		OSGetDataDirectory( pc_extFileNm);
		strcat( pc_extFileNm, epc_PATH_SPECIFIER);

		//note that we've completed any first-time only stuff done here 
		//	(static local variable)
		f_firstTime = FALSE;
	//else pare the filepath to just the path portion
	}else	{
		char * pc = strrchr( pc_extFileNm, ec_PATH_SPECIFIER);
		if (pc)
			pc[1] = NULL;
		else if (*pc_extFileNm)
			*pc_extFileNm = NULL;
	}//if (f_firstTime)

	//set the extract edit-box to the last path used by the user, if any, or 
	//	to its utter default, adding on the appropriate version of the 
	//	filename
	ui_len = strlen( pc_extFileNm) + strlen( PT->pc_fileNm);
	_ASSERTE( ui_len < MAXPATH);
	strcat( pc_extFileNm, PT->pc_fileNm);
	if (pt_st->f_dcryptdChecked && (stricmp( pc_extFileNm + (ui = ui_len - 
							mui_LEN_ARMOR_EXT_PGP), mpc_PGP_ARMOR_EXT_PGP) == 
							ei_SAME || stricmp( pc_extFileNm + (ui = ui_len - 
							mui_LEN_ARMOR_EXT_ASC), mpc_PGP_ARMOR_EXT_ASC) == 
							ei_SAME))
		pc_extFileNm[ ui] = NULL;
	if (!( h = GetDlgItem( H, mi_IDC_EXT_FILENM)))	{
		ul_err = GetLastError();
		goto errJump;
	}
	if (!SetWindowText( h, pc_extFileNm))
		goto errJump;

	//Set the radio-button choice and the "decrypted" checkbox to the way the 
	//	user last left them, if known, else to their utter defaults. 
	if (!CheckRadioButton( H, mi_IDC_RD_LAUNCH, mi_IDC_RD_EXTR, 
															pt_st->i_choice))
		goto errJump;
	if (!CheckDlgButton( H, mi_IDC_DECRYPT, pt_st->f_dcryptdChecked))
		goto errJump;

	//store handle to the edit-box for ongoing use
	pt_st->h_ebxExtFileNm = h;

	return eus_SUCCESS;

errJump:
	//since an error occurred, back out whatever configuration we've done
	if (pt_st->h_rdExtract)	{
		RemoveProp( h_rdExtract, mpc_PROPNM_EXTR_DLG_CHOICE);
		RemoveProp( h_rdExtract, mpc_PROPNM_ORIG_WNDPROC);
		SetWindowLong( h_rdExtract, GWL_WNDPROC, (long) pr);
		pt_st->h_rdExtract = (HWND) pr = NULL;
	}
	if (pt_st->h_rdLaunch)	{
		const WNDPROC PR = RemoveProp( h_rdLaunch, mpc_PROPNM_ORIG_WNDPROC);

		RemoveProp( h_rdLaunch, mpc_PROPNM_EXTR_DLG_CHOICE);
		if (pr)
			SetWindowLong( h_rdLaunch, GWL_WNDPROC, (long) pr);
		else if (PR)
			SetWindowLong( h_rdLaunch, GWL_WNDPROC, (long) PR);
		pt_st->h_rdLaunch = NULL;
	}
	if (f_firstTime && pt_st->h_fntFileCaption)	{
		DeleteObject( pt_st->h_fntFileCaption);
		pt_st->h_fntFileCaption = NULL;
	}

	//Return the most descriptive error possible. For GDI errors, only NT 
	//	will provide problem indication.
	if (!ul_err)
		ul_err = mt_Os.dwPlatformId == VER_PLATFORM_WIN32_NT ? 
												GetLastError() : !eus_SUCCESS;

	return ul_err;
} //ul_ExtractDlgInit(


/** WndProcExtractRdo( ***
Subclassing window-message procedure for the radio buttons of the Extract 
dialog. Allows direct control of the radio-button "choice change" event, 
which is needed for straightforward enabling/disabling of the controls 
dependant on the "Extract" choice.

--- parameters & return ----
H: handle of the radio button receiving the message
UI: identifier of the message being passed to the procedure
ui_W: the WORD parameter associated with the message
ul_L: the long parameter associated with the message
RETURN: The result of the message. Use of the return varies from message to 
	message.

--- revision history -------
9/16/00 PR: created			*/
static LRESULT CALLBACK WndProcExtractRdo( const HWND  H, 
											const UINT  UI, 
											const WPARAM  ui_W, 
											const LPARAM  ul_L)	{
	static HWND  h_dlg;

	//determine which radio button is receiving the message
	const int  i_ID = GetDlgCtrlID( H);

	WNDPROC  pr;
	DWORD  ul_err;

	//if we failed to determine the recipient radio button, short-circuit 
	//	with failure
	if (!i_ID)	{
		ul_err = GetLastError();
		goto errJump;
	}

	switch (UI)	{
	case BM_SETCHECK:	{
		static HWND  h_extFileNm, h_dcryptd, h_brwse, h_ok;

		HWND  h;

		//if this is a button-check event...
		if (BST_CHECKED == ui_W)	{
			int * pi;

			//if not yet gotten, get handles to the parent dialog and the 
			//	controls associated with the Extract choice
			if (!( h = GetParent( H)))	{
				ul_err = GetLastError();
				goto errJump;
			}
			if (h_dlg != h)	{
				if (!( h_extFileNm = GetDlgItem( h_dlg = h, 
												mi_IDC_EXT_FILENM)))	{
					ul_err = GetLastError();
					goto errJump;
				}
				if (!( h_dcryptd = GetDlgItem( h_dlg, mi_IDC_DECRYPT)))	{
					ul_err = GetLastError();
					goto errJump;
				}
				if (!( h_brwse = GetDlgItem( h_dlg, mi_IDC_BROWSE)))	{
					ul_err = GetLastError();
					goto errJump;
				}
				if (!( h_ok = GetDlgItem( h_dlg, mi_IDOK)))	{
					ul_err = GetLastError();
					goto errJump;
				}
			} //if (h_dlg != h)

			//if the Extract choice has been selected...
			if (mi_IDC_RD_EXTR == i_ID)	{
				//enable the controls associated with the Extract choice
				EnableWindow( h_extFileNm, TRUE);
				EnableWindow( h_dcryptd, TRUE);
				EnableWindow( h_brwse, TRUE);

				//if there's no text in the filename edit-box, disable the OK 
				//	button
				if (!GetWindowTextLength( h_extFileNm))
					EnableWindow( h_ok, FALSE);
			//else...
			}else	{
				//disable the controls associated with the Extract choice
				EnableWindow( h_extFileNm, FALSE);
				EnableWindow( h_dcryptd, FALSE);
				EnableWindow( h_brwse, FALSE);

				//if there's no text in the filename edit-box, enable the OK 
				//	button
				if (!GetWindowTextLength( h_extFileNm))	
					EnableWindow( h_ok, TRUE);
			} //if (mi_IDC_RD_EXTR == i_ID)

			//store the user's latest choice so other code may know of it 
			//	directly
			if (!( pi = GetProp( H, mpc_PROPNM_EXTR_DLG_CHOICE)))
				goto errJump;
			*pi = i_ID;
		} //if (BST_CHECKED == ui_W)
	} //case BM_SETCHECK
	} //switch (UI)

	//pass the current message down the procedure chain
	if (!( pr = GetProp( H, mpc_PROPNM_ORIG_WNDPROC)))
		goto errJump;
	return CallWindowProc( pr, H, UI, ui_W, ul_L);

errJump:
	//Return the most descriptive error possible. For GDI errors, only NT 
	//	will provide problem indication.
	if (!ul_err)
		ul_err = mt_Os.dwPlatformId == VER_PLATFORM_WIN32_NT ? 
												GetLastError() : !eus_SUCCESS;
	if (!h_dlg)
		h_dlg = GetParent( H);
	if (h_dlg)	{
		EndDialog( h_dlg, ul_err);
		h_dlg = NULL;
	}
	return FALSE;		//arbitrary return
} //WndProcExtractRdo(


/** i_PgpEncodeRtfAsAttachment( ***
PGP-encode a copy of the given rich-text field and attach it as an object to 
the specified note. So that the attachment may be hidden from the user, the 
caller is also provided a rich-text hidden paragraph which references the 
attachment and so inhibits its display "below the line" in the Notes 
user-interface.

--- parameters & return ----
pt_encdCtx: Input & Output. Address of the PGP information structure being used 
	in the current round of encoding. The opaque structure may be updated if 
	user adjusts presented defaults.
h_NOTE: handle to the note to which the encoded rich-text field will be 
	attached as an attachment
pt_RT_CTX: address of the rich-text context structure describing the rich-text 
	field to be copied, encoded and encapsulated as an attachment
pt_AttchPgrph: Output. Address of the rich-text context structure by which a 
	hidden rich-text paragraph will be constructed which includes a reference 
	to the generated attachment. Caller is responsible for having initialized 
	the structure prior to calling this procedure. If procedure is 
	unsuccessful, it is possible that the structure will have undergone change 
	even so.
pbid_itm: Output. Address of the structure to fill with the Notes BLOCKID 
	associated with the $FILE item that describes the attachment created by 
	this procedure.
RETURN: eus_SUCCESS if successful; the Notes API or PGP SDK error code if 
	unsuccessful

--- revision history -------
3/14/03 PR
+ signature change in support of switch to casting away const when needed due 
  to Notes' disregard of constness
+ listing format adjustment, minor documentation adjustment, token renaming

9/6/02 PR: token renaming, listing format adjustment, minor logic shortening
5/30/00 PR: documentation adjustment

3/20/00 PR
+ adjustments associated with a change to the eus_CopyRtfIntoBuffer() signature
+ adjusted signature to provide the ultimate attachment name to caller and to 
  allow a PGP error-code return as well as a Notes error-code return
+ documentation adjustment

1/29/99 PR: created			*/
static int i_PgpEncodeRtfAsAttachment( PgpEncodeContext *const  pt_encdCtx, 
										const NOTEHANDLE  h_NOTE, 
										const RtfContext *const  pt_RT_CTX, 
										RtfContext *const  pt_AttchPgrph, 
										BLOCKID *const  pbid_itm)	{
	DWORD  ul, ul_lenOutp;
	BYTE * puc_inp, * puc_outp = NULL;
	char  pc_objNm[ mi_MAXLEN_ATTCH_OBJNM] = {NULL};
	HANDLE  h;
	int  i_err;
	STATUS  us_err;

	_ASSERTE( pt_encdCtx && h_NOTE && pt_RT_CTX && pt_AttchPgrph && pbid_itm);

	//stream the now-complete virtual rich-text content into a buffer
	if (us_err = eus_CopyRtfIntoBuffer( pt_RT_CTX, &h, &ul, &puc_inp))
		return us_err;

	i_err = ei_PgpEncodeBuffer( puc_inp, (long) ul, pt_encdCtx, TRUE, 
														&ul_lenOutp, &puc_outp);
	OSUnlockObject( h);
	OSMemFree( h);
	if (i_err)
		return i_err;

	//initialize the rich-text hidden paragraph we will use to store the 
	//	special object
	if (us_err = us_SetupRtfAttachParagraph( h_NOTE, pt_AttchPgrph, pc_objNm))
		goto errJump;

	//Attach the appropriate buffer content (encrypted or not) to the note as a 
	//	file object. The MS-DOS host format is used here at encoding-time to 
	//	ensure that the SMTP MTA will include it if the message goes through 
	//	it. The STREAM format is for some reason ignored and dropped by the MTA 
	//	(in Domino R4 at least).
	if (us_err = eus_AttachBufferAsObject( puc_outp, ul_lenOutp, NULL, h_NOTE, 
														epc_ITMNM_STD_ATTCH, 
														pc_objNm, HOST_MSDOS))
		goto errJump;

	//retrieve for the caller the item-BLOCKID of the attachment just created
	us_err = eus_getAttachmentInfo( h_NOTE, NULL, pc_objNm, NULL, NULL, NULL, 
														NULL, pbid_itm, NULL);

errJump:
	e_FreePgpMem( puc_outp);

	return us_err;
} //i_PgpEncodeRtfAsAttachment(


/** us_SetupRtfAttachParagraph( ***


--- parameters & return ----

RETURN: eus_SUCCESS if no error occured; the Notes API error code otherwise

--- revision history -------
9/6/02 PR: token renaming, listing format adjustment
1/29/99 PR: created			*/
//DOC!!
static STATUS us_SetupRtfAttachParagraph( NOTEHANDLE  h_NOTE, 
											 RtfContext *const  pt_AttchPgrph, 
											 char *const  pc_objNm)	{
	STATUS  us_err;
//NOTE: might be able the make the module-scope variables in this function 
//	local
	_ASSERTE( pc_objNm && h_NOTE && pt_AttchPgrph);

	if (us_err = eus_AppendRtParagraph( 
0xCBA9, 
													&mt_RT_PGRPH_HIDDEN, 
													ept_InitUtilityRtfContext( 
													pt_AttchPgrph), NULL))
		return us_err;

	//Include an attachment hotspot for the object in the special hidden-
	//	paragraph rich-text item. This will keep the attachment from showing up 
	//	"below-the-line," as it would if not referenced by an attachment 
	//	hotspot in a rich-text field on the document. Since the hotspot always 
	//	remains hidden, there's no need to include a graphic in the hotspot.
	if (!*mpc_fileNmPgpRtf)
		strcat( strcpy( mpc_fileNmPgpRtf, mpc_ROOTFILENM_PGP_RTF), 
														mpc_PGP_ARMOR_EXT_ASC);
	us_err = eus_AppendAttachmentHotspot( h_NOTE, mpc_fileNmPgpRtf, pc_objNm, 
													NULL, NULL, pt_AttchPgrph);

	if (us_err)
		ef_FreeRtfContext( pt_AttchPgrph);

	return us_err;
} //us_SetupRtfAttachParagraph(


/** us_CreateRecipientsArray( ***
Purpose is to convert a string containing the current message recipients into a 
string array, the format expected by the PGP infrastructure. In doing this, the 
procedure resolves the recipients against the Domino Directory using the 
specified lookup configuration. All members of an ambiguous address resolution 
are included in the ultimate list, as are recipients that do not resolve.

--- parameters & return ----
pc_RecipientsList: Address of the string containing the message recipients as 
	currently understood, delimited by semi-colons. String may not be preserved 
	because strtok() may be used to parse the string.
f_LOOKUP_EXHAUST: Flag telling whether the directories should be searched 
	exhaustively for each name so as to be sure all matches are accounted for.
pc_LookupHow: Address of the name of the server holding the Domino Directory to 
	be used potentially in the resolution process. String may not be preserved 
	because strtok() may be used to parse the string.
pppc_recipients: Output. Pointer to the string array variable to populate with 
	the list of recipients PGP should try to match encryption keys to. CALLER 
	IS RESPONSIBLE for freeing the resources allocated to the array.
pui_recipients: Output. Pointer to the variable in which to store the number of 
	elements placed in the string array (pppc_recipients).
pf_ambiguous: Output. Pointer to the flag variable to set according to whether 
	ambiguous resolutions were encountered.
RETURN: eus_SUCCESS if no error occured; the Notes API error code otherwise

--- revision history -------
8/21/03 PR: logic enhancement to address bug in resolution of SMTP addresses 
	not resolved within the Notes/Domino lookup environment

3/14/03 PR
+ support of change to ef_AddStringNodeFifo() function, renamed to 
  ef_AddStringNode()
+ documentation adjustment

9/6/02 PR: listing format adjustment, minor logic shortening

9/12/99 PR
+ logic overhaul to support enhancement of better emulation of Lotus Notes' 
  name lookup behavior
+ documentation adjustment

12/20/98 PR: created		*/
static STATUS us_CreateRecipientsArray( char  pc_RecipientsList[], 
										const BOOL  f_LOOKUP_EXHAUST, 
										char  pc_LookupHow[], 
										char * * *const  pppc_recipients, 
										UINT *const  pui_recipients, 
										BOOL *const  pf_ambiguous)	{
	const char  pc_LIST_DELIMITER[] = ";";

	UINT  ui, ui_entries = 0;
	char * pc_recip, * pc, * * ppc = NULL;
	NameFoundNode * pt_unresolved = NULL, * pt;
	StringNode * pt_resolved = NULL, * pt_nd;
	STATUS  us_err = eus_SUCCESS;
	BOOL  f_fail;

	_ASSERTE( pc_RecipientsList && pppc_recipients && pf_ambiguous);

	*pppc_recipients = (char * *) *pui_recipients = NULL;
	*pf_ambiguous = FALSE;

	//for each entry in the text list...
	pc_recip = strtok( pc_RecipientsList, pc_LIST_DELIMITER);
	_ASSERTE( pc_recip);
	do	{
		//allocate space for a copy of the entry, and copy the entry into it
		if (f_fail = !(pc = malloc( ui = strlen( pc_recip) + 1)))
			goto errJump;
		strcpy( pc, pc_recip);

		//string on a new entry to the unresolved list, transferring ownership 
		//	of the name string to the entry
		pt = pt_unresolved;
		if (f_fail = !ef_AddNameFoundNodeFifo( pc, FALSE, TRUE, &pt))
			goto errJump;
		if (!pt_unresolved)
			pt_unresolved = pt;
	} while (pc_recip = strtok( NULL, pc_LIST_DELIMITER));
	pc = NULL;

	//if there are any recipient names...
	if (pt_unresolved)	{
		char * pc, * pc_, * pc_strt, * pc_end;

		//attempt to resolve the names against the default Domino Directory set
		if (us_err = eus_ResolveMailAddresses( pt_unresolved, f_LOOKUP_EXHAUST, 
									epc_strtokStrict( pc_LookupHow, 
									pc_LIST_DELIMITER), NULL, &pt_resolved, 
									&ui_entries, pf_ambiguous))
			goto errJump;

		//if a further server to resolve against has been specified...
		if ((pc = epc_strtokStrict( NULL, pc_LIST_DELIMITER)) && *pc)	{
			//attempt to resolve the names against the server's Domino 
			//	Directory set, if necessary
			if (!f_LOOKUP_EXHAUST)	{
				pt = pt_unresolved;
				do
					if (!pt->pt_name->f_found)
						break;
				while (pt = pt->pt_next);
			}
			if (f_LOOKUP_EXHAUST || pt)	{
				if (us_err = eus_ResolveMailAddresses( pt_unresolved, 
										f_LOOKUP_EXHAUST, pc, NULL, 
										&pt_resolved, &ui, 
										*pf_ambiguous ? NULL : pf_ambiguous))
					goto errJump;
				ui_entries += ui;
			}
		} //if (pc = strtok( NULL,

		//if not done yet, populate a "constant" string buffer holding valid 
		//	SMTP address characters
		if (!*mpc_validSmtpAddrChars)
			strcat( strcpy( mpc_validSmtpAddrChars, epc_ALPHANUM), 
										mpc_VALID_NON_ALPHANUM_SMTP_ADDR_CHARS);

		//for each still unresolved address...
		pt = pt_unresolved;
		do	{
			if (pt->pt_name->f_found)
				continue;

			//if the address is an SMTP address in RFC 822 format (phrase 
			//	[a.k.a. display name] + base address), pare it down to just the 
			//	base address
			if ((pc_strt = pc_ = strchr( pc = pt->pt_name->pc_nm, '<')) && 
								(pc = strchr( pc_ ? ++pc_ : pc, '@')) && 
								strchr( mpc_validSmtpAddrChars, *(pc - 1)) && 
								strchr( mpc_validSmtpAddrChars, *(pc + 1)) && 
								(pc_ = strrchr( ++pc, '.')) > pc && strchr( 
								mpc_validSmtpAddrChars, *++pc_) && (pc_end = 
								strchr( pc_ + 1, '>')))	{
				pc_strt++;
				memmove( pt->pt_name->pc_nm, pc_strt, pc_end - pc_strt);
				pt->pt_name->pc_nm[ pc_end - pc_strt] = NULL;
			} //if ((pc = strchr( pc_ ?

			//if unique, transfer ownership of the unresolved address to a new 
			//	entry in the resolved list
			pt_nd = pt_resolved;
			if (f_fail = !ef_AddStringNodeFifoUnique( pt->pt_name->pc_nm, 
														FALSE, FALSE, &pt_nd))
				goto errJump;
			if (pt_nd)	{
				if (!pt_resolved)
					pt_resolved = pt_nd;
				pt->pt_name->pc_nm = NULL;
				ui_entries++;
			} //if (pt_nd)
		} while (pt = pt->pt_next);
	} //if (pt_unresolved)

	//transfer control of the resolved list to a string array
	if (ui_entries)	{
		if (f_fail = !( ppc = calloc( ui_entries, sizeof( char *))))
			goto errJump;
		pt_nd = pt_resolved;
		for (ui = 0; ui < ui_entries; ui++)	{
			ppc[ ui] = pt_nd->pc;
			pt_nd = pt_nd->pt_next;
		}
		_ASSERTE( !pt_nd);

		*pppc_recipients = ppc;
		*pui_recipients = ui_entries;
	} //if (ui_entries)

errJump:
	//Free allocated resources no longer needed. If we've been successful, the 
	//	string array now owns the strings in the resolved list.
	if (pt_unresolved)
		e_FreeNameFoundList( &pt_unresolved);
	if (pt_resolved)
		e_FreeList( &pt_resolved, us_err || f_fail);
	if (pc)
		free( pc);

	return us_err + f_fail;
} //us_CreateRecipientsArray(


/** i_PgpEncodeRtfText( ***

--- parameters & return ----

RETURN:
	eus_SUCCESS if no error occured
	the Notes API error code otherwise

--- revision history -------
3/14/02 PR: logic enhancement to provide better handling of input buffers 64K or greater 
	in size

9/6/02 PR
+ logic enhancement to support high-ASCII (international) characters in message 
  body
+ token renaming, listing format adjustment

12/15/98 PR: created		*/
//DOC!!
static int i_PgpEncodeRtfText( PgpEncodeContext *const  pt_encdCtx, 
								RtfContext *const  pt_rtCtx, 
								char * *const  ppc_outp)	{
	const int  i_PGPERR_OUT_OF_MEM = -11999;	//kPGPError_OutOfMemory

	char * pc_ctnt, * pc_outpOs = NULL, * pc_ctntOs = NULL;
	ULONG  ul_len;
	int  i_err;
	BOOL  f_fail = FALSE;

	_ASSERTE( pt_encdCtx && (pt_encdCtx->f_Encrypt || pt_encdCtx->f_Sign) && 
														pt_rtCtx && ppc_outp);

	//get a copy of the rich-text field's textual content
	if (eul_ERR_FAILURE == (ul_len = eul_GetRtfText( pt_rtCtx, NULL, TRUE, 
																	&pc_ctnt)))
		return !eus_SUCCESS;

	//if the field has content...
	if (ul_len > 1)	{
		ULONG  ul, ul_;
		WORD  us, us_;

		//if the content can be translated to the native character set, PGP 
		//	encode it
		if (!( pc_ctntOs = malloc( ul = ul_ = ul_len)))	{
			i_err = i_PGPERR_OUT_OF_MEM;		
			goto errJump;
		}
		pc_ctntOs[ ul_len - 1] = NULL;
		do	{
			us = ul > MAXWORD ? MAXWORD : (WORD) ul;
			if (f_fail = !(us_ = OSTranslate( OS_TRANSLATE_LMBCS_TO_NATIVE, 
											pc_ctnt + ul_len - ul, (WORD) (us - 
											1), pc_ctntOs + ul_len - ul_, us)))
				goto errJump;
		} while (ul_ -= us_, (ul -= us - 1) > 1);
		if (i_err = ei_PgpEncodeBuffer( pc_ctntOs, strlen( pc_ctntOs), 
										pt_encdCtx, FALSE, NULL, &pc_outpOs))
			goto errJump;
		free( pc_ctntOs);
		pc_ctntOs = NULL;

		//Translate the result back to the Notes LMBCS character set so it 
		//	displays properly in the Notes client and so the SMTP mailer will 
		//	translate it properly back to the native character set if sending 
		//	the message out. (All this effectively comes into play with SMTP 
		//	mailing of clear-signed content.)
		if (!( *ppc_outp = malloc( ul = ul_ = ul_len = strlen( pc_outpOs) + 
																	1)))	{
			i_err = i_PGPERR_OUT_OF_MEM;
			goto errJump;
		}
		(*ppc_outp)[ ul_len - 1] = NULL;
		do	{
			us = ul > MAXWORD ? MAXWORD : (WORD) ul;
			if (f_fail = !(us_ = OSTranslate( OS_TRANSLATE_NATIVE_TO_LMBCS, 
										pc_outpOs + ul_len - ul, (WORD) (us - 
										1), *ppc_outp + ul_len - ul_, us)))
				goto errJump;
		} while (ul_ -= us_, (ul -= us - 1) > 1);
	//else PGP encode the blank content
	}else	{
		if (i_err = ei_PgpEncodeBuffer( pc_ctnt, NULL, pt_encdCtx, FALSE, NULL, 
																	&pc_outpOs))
			goto errJump;
		if (!( *ppc_outp = malloc( ul_len = strlen( pc_outpOs) + 1)))
			i_err = i_PGPERR_OUT_OF_MEM;
		else
			memcpy( *ppc_outp, pc_outpOs, ul_len);
	} //if (ul_len > 1)

errJump:
	if (pc_ctntOs)
		free( pc_ctntOs);
	if (pc_outpOs)
		e_FreePgpMem( pc_outpOs);
	free( pc_ctnt);

	return i_err + f_fail;
} //i_PgpEncodeRtfText(


/** i_MatchPgpKeys( ***
Match as much as possible recipient addresses with PGP keys, be they local or 
accessible via key servers, and be some addresses Notes names or SMTP 
addresses. In doing so, allow users to gracefully break out of key-server 
searching and get on with regular local PGP processing.

--- parameters & return ----
f_SYNC_UNK_KYS: Flag telling whether names not found on the user's default 
	keyring should be sought on the PGP key servers she's specified. If false, 
	SMTP addresses won't be processed because no further processing is 
	necessary before sending to the encryption-keys dialog.
ui_RECPTS: the number of members in the list of recipients
ppc_recpts: Input & Output. Address of the string-array list of recipients. 
	Notes names which may be switched to abbreviaed format while preserving a 
	match will be switched. (A Notes name will remain in canonicalized format 
	only if the canonicalized version is the only one for which a matching key 
	can be found.)
pt_encdCtx: Input & Output. Address of the PGP information structure being used 
	in the current round of encoding. If f_SYNC_UNK_KYS is TRUE, the opaque 
	structure may be updated if names are located via a PGP key-server search.
RETURN:
	!eus_SUCCESS if out-of-memory condition encountered
	ei_USER_ABORT if server-lookup operation was user-canceled
	the PGP error that occurred, if any
	eus_SUCCESS otherwise

--- revision history -------
6/26/03 PR
+ logic adjustment in support of signature chage to i_PgpMatchSmtpAddresses()
+ token renaming

3/14/03 PR: fixed variable-initialization bug
10/30/02 PR: created		*/
static int i_MatchPgpKeys( const BOOL  f_SYNC_UNK_KYS, 
							const UINT  ui_RECPTS, 
							char *const *const  ppc_recpts, 
							PgpEncodeContext *const  pt_encdCtx)	{
	int  i_err = NULL, i_error;

	//if necessary, seek PGP-key matches for any SMTP recipeint addresses
	if (f_SYNC_UNK_KYS && (i_err = i_PgpMatchSmtpAddresses( f_SYNC_UNK_KYS, 
										ui_RECPTS, ppc_recpts, 
										pt_encdCtx)) && i_err != ei_USER_ABORT)
		return i_err;

	//seek PGP-key matches for any Notes names in the recipients' list, 
	//	adjusting as needed most canonicalized Notes names to the more 
	//	user-friendly abbreviated format
	if (i_error = i_PgpMatchNotesNames( f_SYNC_UNK_KYS && !i_err, ui_RECPTS, 
														ppc_recpts, pt_encdCtx))
		return i_error;

	//pull down any additional decyrption keys (ADKs) associated with the 
	//	recipient keys but missing from the local keyring
	if (f_SYNC_UNK_KYS && !i_err && pt_encdCtx->pv_missngAdks && (i_error = 
										ei_PgpLookupMissingAdks( pt_encdCtx)))
		return i_error;

	return i_err;
} //i_MatchPgpKeys(


/** i_PgpMatchSmtpAddresses( ***
Match as possible any SMTP addresses found in the specified recipient list with 
PGP keys, be they local or accessible via key servers.

--- parameters & return ----
f_SYNC_UNK_KYS: Flag telling whether names not found on the user's default 
	keyring should be sought on the PGP key servers she's specified. If false, 
	SMTP addresses won't be processed because no further processing is 
	necessary before sending to the encryption-keys dialog.
ui_RECPTS: the number of members in the list of recipients
ppc_recpts: Input. Address of the string-array list of recipients. Non-SMTP 
	addresses will be ignored. The list is assumed to contain no duplicates and 
	all included SMTP addresses are in the format desired for PGP-key-server 
	lookup.
pt_encdCtx: Input & Output. Address of the PGP information structure being used 
	in the current round of encoding. If f_SYNC_UNK_KYS is TRUE, the opaque 
	structure may be updated if names are located via a PGP key-server search.
RETURN:
	!eus_SUCCESS if out-of-memory condition encountered
	ei_USER_ABORT if server-lookup operation was user-canceled
	the PGP error that occurred, if any
	eus_SUCCESS otherwise

--- revision history -------
8/21/03 PR: documentation improvement

6/26/03 PR
+ extension to allow determination of whether requested alternative PGP 
  decryption keys (ADKs) are missing from the local keyrings; attendant 
  signature change
+ token renaming

3/14/03 PR: support of change to ef_AddListNodeFifo() function, renamed to 
	ef_AddListNode()
10/30/02 PR: created		*/
static int i_PgpMatchSmtpAddresses( const BOOL  f_SYNC_UNK_KYS, 
									const UINT  ui_RECPTS, 
									char *const *const  ppc_recpts, 
									PgpEncodeContext *const  pt_encdCtx)	{
	NameFoundNode * pt_toFind = NULL, * pt_nd = NULL;
	NameFoundInfo * pt;
	UINT  ui;
	char * pc, * pc_;
	BOOL  f_fail;
	int  i_err;

	_ASSERTE( ppc_recpts && pt_encdCtx);

	//if not done yet, populate a "constant" string buffer holding valid SMTP 
	//	address characters
	if (!*mpc_validSmtpAddrChars)
		strcat( strcpy( mpc_validSmtpAddrChars, epc_ALPHANUM), 
										mpc_VALID_NON_ALPHANUM_SMTP_ADDR_CHARS);

	//for each name in the full list...
	for (ui = 0; ui < ui_RECPTS; ui++)	{
		//if the name obviously isn't a valid SMTP address, iterate to the next 
		//	name in the full list
		pc_ = strchr( pc = ppc_recpts[ ui], '<');
		if (!( (pc = strchr( pc_ ? ++pc_ : pc, '@')) && strchr( 
								mpc_validSmtpAddrChars, *(pc - 1)) && 
								strchr( mpc_validSmtpAddrChars, *(pc + 1)) && 
								(pc_ = strrchr( ++pc, '.')) > pc && strchr( 
								mpc_validSmtpAddrChars, *++pc_)))
			continue;

		//create a list node to hold the base e-mail address information
		if (f_fail = !(pt = calloc( 1, sizeof( NameFoundInfo))))
			goto errJump;
		pt->pc_nm = ppc_recpts[ ui];

		//add the new node to the to-find list
		if (f_fail = !ef_AddListNode( pt, TRUE, &pt_nd))	{
			free( pt);
			goto errJump;
		}
		if (!pt_toFind)
			pt_toFind = pt_nd;
	} //for (ui = 0; ui < ui_RECPTS

	//if no SMTP addresses were present, short-circuit with success
	if (!pt_toFind)
		return eus_SUCCESS;

	//check locally within PGP and mark the SMTP addresses it knows of
	if (i_err = ei_PgpLookupEmailLocal( f_SYNC_UNK_KYS, pt_encdCtx, pt_toFind))
		goto errJump;

	//if caller wants to seek out names not found within the local keyring...
	if (f_SYNC_UNK_KYS)	{
		//if any name remains not found...
		pt_nd = pt_toFind;
		do
			if (!( !*pt_nd->pt_name->pc_nm || pt_nd->pt_name->f_found))
				break;
		while (pt_nd = pt_nd->pt_next);
		if (pt_nd)	{
			//check servers within PGP and mark accordingly the names found 
			//	this way
			i_err = ei_PgpLookupEmailViaServers( pt_encdCtx, pt_toFind);
		} //if (pt_nd)
	} //if (f_SYNC_UNK_KYS)

errJump:
	if (pt_toFind)
		e_FreeList( &pt_toFind, TRUE);

	return f_fail + i_err;
} //i_PgpMatchSmtpAddresses(


/** i_PgpMatchNotesNames( ***
To accommodate the intuitive UI desired in the context of PGP keys, default any 
Notes names to the user-friendly abbreviated format, albeit while maintaining 
backward compatibility with the canonicalized format used prior to PGP 6.5.1.

--- parameters & return ----
f_SYNC_UNK_KYS: flag telling whether names not found on the user's default 
	keyring should be sought on the PGP key servers she's specified
ui_RECPTS: the number of members in the list of recipients
ppc_recpts: Input & Output. Address of the string-array list of recipients to 
	check for Notes names which may be switched safely to abbreviaed format. 
	Such names will be switched. A Notes name will remain in canonicalized 
	format only if the canonicalized version is the only one for which a 
	matching key can be found within the PGP infrastructure.
pt_encdCtx: Input & Output. Address of the PGP information structure being used 
	in the current round of encoding. If f_SYNC_UNK_KYS is TRUE, the opaque 
	structure may be updated if names are located via a PGP key-server search.
RETURN: the PGP error that occurred, if any; out-of-memory condition causes a 
	!eus_SUCCESS return; otherwise eus_SUCCESS is returned

--- revision history -------
10/13/03 PR: in-line documentation improvement

6/26/03 PR
+ extension to allow determination of whether requested alternative PGP 
  decryption keys (ADKs) are missing from the local keyrings
+ token renaming

3/14/03 PR: support of change to ef_AddListNodeFifo() function, renamed to 
	ef_AddListNode()
10/30/02 PR
+ logic enhancement to support gracefully user-cancelation during key-server 
  searches
+ listing format adjustment, token renaming, documentation improvement

5/30/00 PR: documentation adjustment

3/20/00 PR
+ fixed null-pointer bug that occurred when all names were accounted for in 
  Notes abbreviated format and the user has specified that not-found names 
  should be looked up against her list of PGP key servers
+ minor documentation adjustment

9/12/99 PR: created			*/
static int i_PgpMatchNotesNames( const BOOL  f_SYNC_UNK_KYS, 
									const UINT  ui_RECPTS, 
									char *const *const  ppc_recpts, 
									PgpEncodeContext *const  pt_encdCtx)	{
	NameFoundNode * pt_abrvd = NULL, * pt_canonicl = NULL, * pt_node = NULL, 
					* pt_nd = NULL;
	NameFoundInfoEx * pt, * pt_nm;
	UINT  ui;
	char * pc = NULL, * pc_src;
	BOOL  f_fail;
	int  i_err;

	_ASSERTE( ppc_recpts && pt_encdCtx);

	//for each name in the full list...
	for (ui = 0; ui < ui_RECPTS; ui++)	{
		//if the name obviously isn't a canonicalized Notes name, iterate to 
		//	the next name in the full list
		if (memcmp( ppc_recpts[ ui], mpc_TKN_NOTES_CANONICAL, 
										mui_LEN_TKN_NOTES_CANONICAL) != ei_SAME)
			continue;

		//Create an abbreviated version of the name. However if it turns out 
		//	that the name is not really a canonicalized name, iterate to the 
		//	next name in the full list.
		if (f_fail = !( pc = malloc( strlen( (pc_src = ppc_recpts[ ui]) + 
												mui_LEN_TKN_NOTES_CANONICAL))))
			goto errJump;
		if (f_fail = !epc_NotesNmAbbreviate( pc_src, pc))	{
			free( pc);
			pc = NULL;
			continue;
		}

		//create a list node to hold the name information, transferring 
		//	ownership of the abbreviated version to it
		if (f_fail = !( pt = calloc( 1, sizeof( NameFoundInfoEx))))
			goto errJump;
		pt->pc_parent = pc_src;
		pt->t.pc_nm = pc;
		pc = NULL;

		//add the new node to the abbreviated-names list
		if (f_fail = !ef_AddListNode( pt, TRUE, &pt_node))	{
			free( pt);
			goto errJump;
		}
		if (!pt_abrvd)
			pt_abrvd = pt_node;
	} //for (ui = 0; ui < ui_RECPTS

	//if no Notes names were present, short-circuit with success
	if (!pt_abrvd)
		return eus_SUCCESS;

	//check locally within PGP and mark the abbreviated names it knows of
	if (i_err = ei_PgpLookupEmailLocal( f_SYNC_UNK_KYS, pt_encdCtx, pt_abrvd))
		goto errJump;

	//for each name in the list of abbreviated names...
	pt_node = pt_abrvd;
	do	{
		//If the name has already been found, reset the corresponding name in 
		//	the full list, and then iterate to the next name. [Since an 
		//	abbreviated Notes name is always shorter than it's canonicalized 
		//	counterpart, the simple strcpy() is safe.]
		if ((pt_nm = (NameFoundInfoEx *) pt_node->pt_name)->t.f_found)	{
			strcpy( pt_nm->pc_parent, pt_nm->t.pc_nm);
			*pt_nm->t.pc_nm = NULL;
			continue;
		}

		//create a list node to hold the name information where the 
		//	canonicalized version is primary (for use if the abbreviated 
		//	version can't be found)
		if (f_fail = !( pt = calloc( 1, sizeof( NameFoundInfoEx))))
			goto errJump;
		pt->pc_parent = pt_nm->t.pc_nm;
		pt->t.pc_nm = pt_nm->pc_parent;
		if (f_fail = !ef_AddListNode( pt, TRUE, &pt_nd))	{
			free( pt);
			goto errJump;
		}
		if (!pt_canonicl)
			pt_canonicl = pt_nd;
	} while (pt_node = pt_node->pt_next);

	//if a list of canonicalized names was populated...
	if (pt_canonicl)	{
		//check locally within PGP and mark accordingly the canonicalized names 
		//	it knows of
		if (i_err = ei_PgpLookupEmailLocal( f_SYNC_UNK_KYS, pt_encdCtx, 
																pt_canonicl))
			goto errJump;

		//for each of the names found this way, nullify the corresponding name 
		//	entry in the abbreviated list
		pt_nd = pt_canonicl;
		do
			if (pt_nd->pt_name->f_found)
				*((NameFoundInfoEx *) pt_nd->pt_name)->pc_parent = NULL;
		while (pt_nd = pt_nd->pt_next);
	} //if (pt_canonicl)

	//if the user has specified that unknown names should be sought via the PGP 
	//	key servers she's specified...
	if (f_SYNC_UNK_KYS)	{
		//if any Notes name remains not found...
		pt_nd = pt_abrvd;
		do
			if (*pt_nd->pt_name->pc_nm && !pt_nd->pt_name->f_found)
				break;
		while (pt_nd = pt_nd->pt_next);
		if (pt_nd)	{
			//check servers within PGP and mark accordingly the abbreviated 
			//	names it knows of
			if ((i_err = ei_PgpLookupEmailViaServers( pt_encdCtx, pt_abrvd)) && 
														i_err != ei_USER_ABORT)
				goto errJump;

			//for each node in the abbreviated list...
			pt_node = pt_abrvd;
			pt_nd = pt_canonicl;
			do	{
				//if the name wasn't just found, iterate to the next list node
				if (!( *(pt = (NameFoundInfoEx *) 
								pt_node->pt_name)->t.pc_nm && pt->t.f_found))
					continue;

				//flag the associated node in the canonical list that the name 
				//	has been found
				strcpy( pt->pc_parent, pt->t.pc_nm);
				do
					if (pt->t.pc_nm == ((NameFoundInfoEx *) 
												pt_nd->pt_name)->pc_parent)	{
						pt_nd->pt_name->f_found = TRUE;
						break;
					}
				while (pt_nd = pt_nd->pt_next);
				*pt->t.pc_nm = NULL;
			} while (pt_node = pt_node->pt_next);
		} //if (pt_nd)

		//if the possibility exists, determine whether any name in the 
		//	canonicalized list remains not found
		if ((pt_nd = pt_canonicl) && !i_err)
			do
				if (!pt_nd->pt_name->f_found)
					break;
			while (pt_nd = pt_nd->pt_next);

		//if any name remains not found...
		if (pt_nd && !i_err)	{
			//check servers within PGP and mark accordingly the canonicalized 
			//	names it knows of
			if (i_err = ei_PgpLookupEmailViaServers( pt_encdCtx, 
										pt_canonicl) && i_err != ei_USER_ABORT)
				goto errJump;

			//for each of the canonicalized names marked as found, nullify the 
			//	corresponding name entry in the abbreviated list
			pt_nd = pt_canonicl;
			do
				if (pt_nd->pt_name->f_found)
					*((NameFoundInfoEx *) pt_nd->pt_name)->pc_parent = NULL;
			while (pt_nd = pt_nd->pt_next);
		} //if (pt_nd)
	} //if (f_SYNC_UNK_KYS)

	//for each remaining name in the list of abbreviated names still not 
	//	resolved, replace the corresponding entry in the full list with the 
	//	abbreviated entry (so it'll be displayed that way in the 
	//	encryption-keys dialog)
	pt_nd = pt_abrvd;
	do
		if (*pt_nd->pt_name->pc_nm)	{
			strcpy( ((NameFoundInfoEx *) pt_nd->pt_name)->pc_parent, 
														pt_nd->pt_name->pc_nm);
			_ASSERTE( !pt_nd->pt_name->f_found);
		}
	while (pt_nd = pt_nd->pt_next);

errJump:
	if (pt_canonicl)
		e_FreeList( &pt_canonicl, TRUE);
	if (pt_abrvd)
		e_FreeNameFoundList( &pt_abrvd);
	if (pc)
		free( pc);

	return f_fail + i_err;
} //i_PgpMatchNotesNames(


/** xul_R45getHandleIllegit( ***


--- parameter & return ----


--- revision history ------
7/2/01 PR
+ added safety logic
+ documentation adjustment

10/7/00 PR: removed logic to initialize this DLL's PGP connection due to 
	update in the plug-in subform's handling of this issue 
3/20/00 PR: moved from RevealNoteHandle module to nPGPNts module
12/13/98 PR: created		*/
//DOC!!
unsigned long xul_R45getHandleIllegit( 
									  const BYTE *const  puc_NotesDocument)	{
	const int  i_45_OFFSET_TO_HANDLE = 0xEC;

	if (!puc_NotesDocument)
		return NULL;

	return *(unsigned long *) (puc_NotesDocument + i_45_OFFSET_TO_HANDLE);
} //xul_R45getHandleIllegit(


/** xus_ResetToPgpEncodedRtf( ***
Resets the specified note's rich-text field to the PGP-encoded version saved in 
memory via a prior call to eus_PreMailSend. This is necessary when the Notes R5 
mail template is in use. More specifically, the R5 template implements the 
"Save and File" action differently from the R4 template, driving the need for 
the reset functionality. For more specificis, see the documentation in the PGP 
subform concerning this issue.

--- parameters & return ----
h_NOTE: handle to the note whose rich-text field is to be reset to the 
	PGP-encoded version
pc_FLDNM: address of string telling the name of the rich-text field to be 
	used in the encoding
RETURN: eus_SUCCESS if no error occured; the Notes API error code otherwise

--- revision history -------
3/14/03 PR: token renaming, minor documentation adjustment
3/20/00 PR: created		*/
unsigned short xus_ResetToPgpEncodedRtf( const NOTEHANDLE  h_NOTE, 
											char  pc_FLDNM[])	{
	RtfContext  t_ctx;
	BYTE * puc;
	STATUS  us_err;
//BLOCKID  bid;
	if (!( h_NOTE && pc_FLDNM))
		return !eus_SUCCESS;

	//if no PGP-encoded rich-text field is ready to be written to the note, 
	//	short-circuit with a general failure
	if (mt_RtfResettable.h_note != h_NOTE)
		return !eus_SUCCESS;
	_ASSERTE( mt_RtfResettable.h_content);

/*if (!FALSE)	{
if (us_err = OSMemAlloc( NULL, mt_RtfResettable.ul_len, &bid.pool))
	goto errJump;
bid.block = NULLBLOCK;
puc = OSLockBlock( BYTE, bid);
memcpy( puc, OSLockObject( mt_RtfResettable.h_content), 
													mt_RtfResettable.ul_len);
OSUnlockBlock( bid);
OSUnlockObject( mt_RtfResettable.h_content);
if (us_err = NSFItemDelete( h_NOTE, pc_FLDNM, (WORD) strlen( pc_FLDNM)))
	goto errJump;
us_err = NSFItemAppendByBLOCKID( h_NOTE, ITEM_SIGN | ITEM_SEAL, pc_FLDNM, 
												(WORD) strlen( pc_FLDNM), bid, 
												mt_RtfResettable.ul_len, NULL);
if (us_err)
	OSMemFree( bid.pool);
OSMemFree( mt_RtfResettable.h_content);
memset( &mt_RtfResettable, NULL, sizeof( ResettableRtfInfo));
return us_err;
} //CONTROL IF
*/	//initialize resources associated with the rich-text handling we're going 
	//	to do
	if (us_err = eus_InitializeRtfContext( h_NOTE, pc_FLDNM, NULL, &t_ctx))
		return us_err;

	//replace the current rich-text field with the PGP-encoded version stored 
	//	during the "PreMailSend" that must have just before taken place
	puc = OSLockObject( mt_RtfResettable.h_content);
	us_err = eus_ReplaceRtfWithCdStream( puc, mt_RtfResettable.ul_len, &t_ctx);
	OSUnlockObject( mt_RtfResettable.h_content);
	if (us_err)
		goto errJump;

	//commit the updated rich-text field to the note, overwriting the current 
	//	actual rich-text content
	us_err = eus_CommitChangedRtf( h_NOTE, pc_FLDNM, &t_ctx);

errJump:
	//free resources allocated to the stored version, and flag that this has 
	//	been done
	OSMemFree( mt_RtfResettable.h_content);
	memset( &mt_RtfResettable, NULL, sizeof( ResettableRtfInfo));

	ef_FreeRtfContext( &t_ctx);

	return us_err;
} //xus_ResetToPgpEncodedRtf(


/** xs_PrepCheckmarkMenuing( ***
Sets the environment by which the plug-in may monitor and work with Windows 
messages sent to the message's action-bar window.

--- suggestion enhancement ----
8/9/00 PR: use an integer return instead of a "boolean" so that an 
	out-of-memory condition may be indicated

--- return --------------------
RETURN: Visual Basic/LotusScript TRUE if successful, FALSE otherwise 

--- revision history ----
11/14/00 PR: documentation adjustment

9/16/00 PR
+ replaced window-procedure linked-list mechanism with the more 
  straightforward and more loosely coupled SetProp() & GetProp() combination
+ error-handling improvement
+ removed obsolete documentation & code

8/9/00 PR: created			*/
short xs_PrepCheckmarkMenuing()	{
	//static for speed
	static const char  pc_CLASSNM_ACTIONBAR[] = "ActionBar", 
						pc_CLASSNM_RTF_EDITBX[] = "IRIS.tedit", 
						pc_CLASSNM_NOTES_SUBPROG[] = "NotesSubprog", 
						pc_CLASSNM_RTF[] = "NotesRichText";

	HWND  h, h_bar;
	char  pc_strt[ 20];
	WNDPROC  pr;
	DWORD  ul_err;

	//if the cursor focus is starting out in an R5 address edit-box field...
	if (!( h = GetFocus()))
		return ms_VB_FALSE;
	if (!GetClassName( h, pc_strt, sizeof( pc_strt)))
		goto errJump;
	if (!( h = GetParent( h)))
		goto errJump;
	if (!( h = GetParent( h)))
		goto errJump;
	if (strcmp( pc_CLASSNM_RTF_EDITBX, pc_strt) == ei_SAME)	{
		//get the action-bar window handle, 2 up & 1 down
		if (!( h_bar = FindWindowEx( h, NULL, pc_CLASSNM_ACTIONBAR, NULL)))
			goto errJump;
	//else if the focus is starting out in the main window (anywhere in R4 
	//	mail template, Body field in R5 mail template...
	}else if (strcmp( pc_CLASSNM_RTF, pc_strt) == ei_SAME)	{
		HWND  h_prv, h_up1 = h;

		//get the action-bar window handle, 2 up & 2 down, but where the 
		//	first try down may be a dead end
		if (!( h = h_prv = FindWindowEx( h, NULL, pc_CLASSNM_NOTES_SUBPROG, 
																	NULL)))
			goto errJump;
		if (!( h_bar = FindWindowEx( h, NULL, pc_CLASSNM_ACTIONBAR, NULL)))	{
			if (!( h = FindWindowEx( h_up1, h_prv, pc_CLASSNM_NOTES_SUBPROG, 
																	NULL)))
				goto errJump;
			if (!( h_bar = FindWindowEx( h, NULL, pc_CLASSNM_ACTIONBAR, 
																	NULL)))
				goto errJump;
		} //if (!( h_bar = FindWindowEx( 
	//else the focus is in an unsupported place, so short-circuit with failure
	}else
		return ms_VB_FALSE;

	//override (subclass) the action-bar's window procedure with one that we 
	//	control, saving the original procedure so window messages can be 
	//	passed on for regular processing
	if (!( pr = (WNDPROC) SetWindowLong( h_bar, GWL_WNDPROC, 
													(long) ActionBarWndProc)))
		goto errJump;
	if (!SetProp( h_bar, mpc_PROPNM_ORIG_WNDPROC, pr))	{
		SetWindowLong( h_bar, GWL_WNDPROC, (long) pr);
		goto errJump;
	}

	return ms_VB_TRUE;

errJump:
	ul_err = GetLastError();
	return ms_VB_FALSE;
} //xs_PrepCheckmarkMenuing(


/** ActionBarWndProc( ***
Subclassing window-message procedure for the "action bar" of a document in 
the Notes client. The action bar handles all the drop-down menuing done by 
the action buttons on the bar. In the context of the PGP Plug-In, we use this 
procedure to adjust particular menu items hanging off of the PGP action 
button.

--- parameters & return ----
H: handle to the window being called
ui_MSG: identifier of the message being passed to the procedure
ui_W: the WORD parameter associated with the message
ul_L: the long parameter associated with the message
RETURN: The result of the message. Use of the return varies from message to 
	message

--- revision history -------
9/16/00 PR: replaced window-procedure linked-list mechanism with the more 
	straightforward and more loosely coupled SetProp() & GetProp() combination
8/9/00 PR: created			*/
static LRESULT CALLBACK ActionBarWndProc( const HWND  H, 
											const UINT  ui_MSG, 
											const WPARAM  ui_W, 
											const LPARAM  ul_L)	{
	char * pc = NULL;
	WNDPROC  pr;

	switch (ui_MSG)	{
		//if this is the popup menu command we are interested in inspecting...
		case WM_INITMENUPOPUP:	{
			static const char pc_MU_SIGNOFF[] = "Toggle Sign off", 
								pc_MU_ENCRYPTOFF[] = "Toggle Encrypt off", 
								pc_MU_SIGN[] = "Sign", 
								pc_MU_ENCRYPT[] = "Encrypt";
			static UINT  ui_POS_SIGN = 0, ui_POS_ENCRYPT = 1;

			MENUITEMINFO  nii;
			char * pc_tmp;

			//If the PGP-sign menu item needs to be checkmarked, simplify the 
			//	item's name and set the checkmark. The mask member should be 
			//	(and is) set according to whether we're running Win98/Win2000 
			//	or not.
			memset( &nii, NULL, sizeof( MENUITEMINFO));
			nii.cbSize = sizeof( MENUITEMINFO);
			nii.fMask = 
#if WINVER < 0x0500
						MIIM_TYPE;
#else
						MIIM_STRING;
#endif
			if (!GetMenuItemInfo( (HANDLE) ui_W, ui_POS_SIGN, TRUE, &nii))
				goto errJump;
			if (nii.cch == sizeof( pc_MU_SIGNOFF) - 1)	{
				if (!( nii.dwTypeData = pc = malloc( ++nii.cch)))
					goto errJump;
				if (!GetMenuItemInfo( (HANDLE) ui_W, ui_POS_SIGN, TRUE, &nii))
					goto errJump;
				if (stricmp( pc, pc_MU_SIGNOFF) == ei_SAME)	{
					strcpy( pc, pc_MU_SIGN);
					nii.fMask |= MIIM_STATE;
					nii.fState = MFS_CHECKED;
					if (!SetMenuItemInfo( (HANDLE) ui_W, ui_POS_SIGN, TRUE, 
																		&nii))
						goto errJump;
				} //if (stricmp( pc, pc_MU_SIGNOFF
			} //if (nii.cch == sizeof( pc_MU_SIGNOFF)

			//if the PGP-encrypt menu item needs to be checkmarked, simplify 
			//	the item's name and set the checkmark
			nii.dwTypeData = (char *) nii.cch = NULL;
			nii.fMask &= ~MIIM_STATE;
			if (!GetMenuItemInfo( (HANDLE) ui_W, ui_POS_ENCRYPT, TRUE, &nii))
				goto errJump;
			if (nii.cch == sizeof( pc_MU_ENCRYPTOFF) - 1)	{
				if (!( nii.dwTypeData = pc = realloc( pc_tmp = pc, 
															++nii.cch)))	{
					pc = pc_tmp;
					goto errJump;
				}
				if (!GetMenuItemInfo( (HANDLE) ui_W, ui_POS_ENCRYPT, TRUE, 
																		&nii))
					goto errJump;
				if (stricmp( pc, pc_MU_ENCRYPTOFF) == ei_SAME)	{
					strcpy( pc, pc_MU_ENCRYPT);
					nii.fMask |= MIIM_STATE;
					nii.fState = MFS_CHECKED;
					SetMenuItemInfo( (HANDLE) ui_W, ui_POS_ENCRYPT, TRUE, &nii);
				} //if (stricmp( pc, pc_MU_ENCRYPTOFF
			} //if (nii.cch == sizeof( pc_MU_ENCRYPTOFF)
		} //case WM_INITMENUPOPUP
		break;

		//if a window we're monitoring is going away, we have to put things 
		//	back the way we found them...
		case WM_DESTROY:
		case WM_CLOSE:	{
			DWORD  ul_err;

			if (!( pr = RemoveProp( H, mpc_PROPNM_ORIG_WNDPROC)))	{
				ul_err = GetLastError();
				return FALSE;	//should never get here, arbitrary return
			}

			//reset to the original window-procedure configuration, and pass 
			//	the close message down the chain
			if (!SetWindowLong( H, GWL_WNDPROC, (long) pr))
				ul_err = GetLastError();
			return CallWindowProc( pr, H, ui_MSG, ui_W, ul_L);
		} //case WM_CLOSE, WM_DESTROY
	} //switch (ui_MSG)

errJump:
	if (pc)
		free( pc);

	if (!( pr = GetProp( H, mpc_PROPNM_ORIG_WNDPROC)))
		return FALSE;	//should never get here, arbitrary return
	return CallWindowProc( pr, H, ui_MSG, ui_W, ul_L);
} //ActionBarWndProc(


/** x_ClearEncodedRtfCopy( ***
Free resources allocated to the copy of the PGP-encoded rich-text field that 
was stored in memory in case it was needed to reset the message's rich-text 
field with the encoded version (a functionality required due to how Lotus 
implemented its "Save and File" action in the R5 template).

--- parameter ----------
H: handle to the note initiating this procedure call

--- revision history ---
3/20/00 PR: created		*/
void x_ClearEncodedRtfCopy( const NOTEHANDLE  H)	{
	if (!( H && mt_RtfResettable.h_note == H))
		return;

	OSMemFree( mt_RtfResettable.h_content);
	memset( &mt_RtfResettable, NULL, sizeof( ResettableRtfInfo));
} //x_ClearEncodedRtfCopy(


