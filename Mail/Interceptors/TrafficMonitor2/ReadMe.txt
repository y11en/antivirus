========================================================================
       CONSOLE APPLICATION : WINSOCKTRACER2
========================================================================


-	интерфейс DETECT
		enum detect_code_t
		{
			dcProtocolUnknown = 0,           // Протокол не опознан
			dcProtocolDetected,              // Протокол опознан
			dcNeedMoreInfo,                  // Не достаточно данных для опознания протокола
			dcDataDetected,                  // Распознана команда передачи данных
		}
		enum data_source_t
		{
			dsClient,                        // Источник данных - клиент
			dsServer,                        // Источник данных - сервер
		}
		tERROR DETECT(
			IN tDWORD dwSessionID,           // Идентификатор сессии
			IN data_source_t dsDataSource,   // Источник данных
			IN tVOID* pLastReceivedData,     // Буфер с данными для оценки
			IN tULONG ulLastReceivedData,    // Размер буфера
			OUT detect_code_t* pdcDetectCode // Результат детектирования протокола
			)

-	интерфейс PROCESS
		tERROR PROCESS(
			IN tDWORD dwSessionID,           // Идентификатор сессии
			IN data_source_t dsDataSource,   // Источник данных
			IN tVOID* pData,                 // Блок данных
			IN tULONG ulDataSize             // Размер блока данных
			)

-	Принцип работы:
	При приеме данных последовательно вызываем метод DETECT, передавая в него только что принятый буфер. 
	Для оптимизации процесса вызываем DETECT на BookmarkCallback(ebcDelete), который происходит только 
	при переполнении BufferWindow и при переключении потока.
	Если из DETECT вернулся 
		dcDetectCode == dcNeedMoreInfo, то протоколлер перед возвратом управления сессии должен сам озаботиться 
			сохранением данных, т.к. в следующий раз ему отдадут новый буфер. 
			Слепить два буфера - его собственная задача.
		dcDetectCode == dcProtocolDetected, то исключаем все протоколлеры, кроме текущего из опроса 
		dcDetectCode == dcProtocolUnknown, то исключаем данный протоколлер из опроса 
			(???подлежит обсуждению, т.к. так мы можем промахнуться на SOCKS???)
		dcDetectCode == dcDataDetected, то все новые данные следует заливать в данный протоколлер, 
			вызывая pProtocoller->PROCESS

	Метод pProtocoller->PROCESS асинхронный. Это значит, что протоколлер копирует блок данных в свои буфера 
	и моментально возвращает управление сессии. После того, как данные будут накоплены, протоколлер начинает их 
	анализировать (в другом потоке), не прерывая работы сессии. 
	В любой момент pProtocoller может опубликовать сообщение pmcKEEP_ALIVE и предоставляет сессии направление 
	команды keep_alive (dsClient или dsServer) и буфер с командой. Если антивирус работает в режиме "read_only"
	(т.е. не изменяет проверяемые данные), то в команде keep_alive может передаваться часть данных. Таким 
	образом, прокси работает совершенно прозрачно для клиента, и практически не вносит задержек в траффик.
	По окончании обработки данных, протоколлер публикует сообщение pmcPROCESS_FINISHED и предоставляет сессии 
	свои буфера данных. 
	Сессия, наконец, пересылает эти данные на приемный сокет.
