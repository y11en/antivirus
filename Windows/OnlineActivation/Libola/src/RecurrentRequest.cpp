/* Generated by Together */
#include "stdafx.h"

#include <time.h>
#include <string>

#include "../include/AuthToken.h"
#include "../include/RequestObserver.h"
#include "../include/ActivationErrors.h"

#include "HttpResponse.h"
#include "HttpRequest.h"
#include "HttpConnection.h"
#include "InternetSession.h"
#include "RequestData.h"
#include "FutureResponse.h"
#include "RecurrentRequest.h"

namespace OnlineActivation
{
///////////////////////////////////////////////////////////////////////////////
namespace
{
	ServerError::ErrorCode TranslateServerError(unsigned long nCode)
	{
		switch (nCode)
		{
		case 600:
			return ServerError::KEY_NOT_FOUND;
		case 601: 
			return ServerError::KEY_OR_ACTIVATION_CODE_BLOCKED;
		case 602: 
			return ServerError::INTERNAL_SERVER_ERROR;
		case 603: 
			return ServerError::INTERNAL_SERVER_ERROR;
		case 620: 
			return ServerError::MANDATORY_PARAMETERS_MISSING;
		case 621: 
			return ServerError::WRONG_CUSTOMER_ID_OR_PASSWORD;
		case 622: 
			return ServerError::WRONG_ACTIVATION_CODE;
		case 623: 
			return ServerError::ACTIVATION_CODE_REQUIRED;
		case 624: 
			return ServerError::USE_MOBILE_ACTIVATION;
		case 633: 
			return ServerError::ACTIVATION_PERIOD_EXPIRED;
		case 634: 
			return ServerError::ACTIVATION_ATTEMPTS_EXHAUSTED;
		case 636: 
			return ServerError::WRONG_APPLICATION_ID;
		default:
			_ASSERTE(!"Unknown server error");
			break;
		}
		return ServerError::UNKNOWN_SERVER_ERROR;
	}
}
///////////////////////////////////////////////////////////////////////////////
RecurrentRequest::RecurrentRequest
(
	const boost::shared_ptr<InternetSession>& pSession,
	const boost::shared_ptr<RequestData>& pData,
	const std::vector<std::string>& urls
)
	: m_pSession(pSession)
	, m_pData(pData)
	, m_urls(urls.begin(), urls.end())
	, m_pObserver(0)
	, m_bAborted(0)
{
}
///////////////////////////////////////////////////////////////////////////////
RecurrentRequest::RecurrentRequest
(
	const boost::shared_ptr<InternetSession>& pSession,
	const boost::shared_ptr<RequestData>& pData,
	const std::list<std::string>& urls,
	const AuthTokenImp& authProxy,
	const AuthTokenImp& authServer,
	RequestObserver& observer
)
	: m_pSession(pSession)
	, m_pData(pData)
	, m_urls(urls)
	, m_authProxy(authProxy)
	, m_authServer(authServer)
	, m_pObserver(&observer)
	, m_bAborted(0)
{
}
///////////////////////////////////////////////////////////////////////////////
RecurrentRequest::RecurrentRequest
(
	const boost::shared_ptr<InternetSession>& pSession,
	const boost::shared_ptr<RequestData>& pData,
	const std::list<std::string>& urls,
	const AuthTokenImp& authProxy,
	const AuthTokenImp& authServer
)
	: m_pSession(pSession)
	, m_pData(pData)
	, m_urls(urls)
	, m_authProxy(authProxy)
	, m_authServer(authServer)
	, m_pObserver(0)
	, m_bAborted(0)
{
}
///////////////////////////////////////////////////////////////////////////////
boost::shared_ptr<Request> RecurrentRequest::CreateInitialRequest
(
	const boost::shared_ptr<InternetSession>& pSession,
	const boost::shared_ptr<RequestData>& pData,
	const std::vector<std::string>& urls
)
{
	// shuffle activation urls
	std::srand(static_cast<unsigned int>(time(0)));
	std::vector<std::string> shfl(urls);
	std::random_shuffle(shfl.begin(), shfl.end());
	return boost::shared_ptr<Request>(new RecurrentRequest(pSession, pData, shfl));
}
///////////////////////////////////////////////////////////////////////////////
boost::shared_ptr<Response> RecurrentRequest::Submit(RequestObserver& observer)
{
	std::auto_ptr<RecurrentRequest> pRequest
		(new RecurrentRequest(m_pSession, m_pData, m_urls, m_authProxy, m_authServer, observer));
	// create request object
	return boost::shared_ptr<Response>(new FutureResponse(pRequest));
}
///////////////////////////////////////////////////////////////////////////////
boost::shared_ptr<Request> RecurrentRequest::ComposeReply(const boost::shared_ptr<RequestData>& pData)
{
	return boost::shared_ptr<Request>
		(new RecurrentRequest(m_pSession, pData, m_urls, m_authProxy, m_authServer));
}
///////////////////////////////////////////////////////////////////////////////
boost::shared_ptr<HttpResponse> RecurrentRequest::Send()
{
	// at least one entry must exist
	_ASSERTE(!m_urls.empty() && "Activation URL list must not be empty");
	// iterate through activation urls and remove dead ones
	while(true)
	{
		try
		{
			// try to send request and handle RETRY response
			return SendHandleRetry();
		}
		// change url when HTTP 5xx error occurred
		catch (const HttpError& e)
		{
			// test for HTTP 5xx
			if (e.GetErrorCode() / 100 == 5)
			{
				// remove dead URL
				m_urls.pop_front();
				// continue if list is not empty
				if (!m_urls.empty())
					continue;
			}
			throw;
		}
		// change url when internal error occurred in the activation server's logic
		catch (const ServerError& e)
		{
			// test for internal server error
			if (e.GetErrorCode() == ServerError::INTERNAL_SERVER_ERROR)
			{
				// remove dead URL
				m_urls.pop_front();
				// continue if list is not empty
				if (!m_urls.empty())
					continue;
			}
			throw;
		}
		// TT#24630 change url when server has certificate problems
		catch (const SystemError& e)
		{
			// test for certificate problems
			switch(e.GetErrorCode())
			{
			case ERROR_INTERNET_SEC_CERT_DATE_INVALID:
			case ERROR_INTERNET_SEC_CERT_CN_INVALID:
			case ERROR_INTERNET_SEC_CERT_ERRORS:
			case ERROR_INTERNET_SEC_CERT_NO_REV:
			case ERROR_INTERNET_SEC_CERT_REV_FAILED:
			case ERROR_INTERNET_SEC_INVALID_CERT:
			case ERROR_INTERNET_SEC_CERT_REVOKED:
				// remove dead URL
				m_urls.pop_front();
				// continue if list is not empty
				if (!m_urls.empty())
					continue;
				break;
			}
			throw;
		}
		// change url when unknown server response received
		catch (const LogicalError& e)
		{
			// test for unknown server response
			if (e.GetErrorCode() == LogicalError::UNKNOWN_SERVER_RESPONSE)
			{
				// remove dead URL
				m_urls.pop_front();
				// continue if list is not empty
				if (!m_urls.empty())
					continue;
			}
			throw;
		}
	}
	_ASSERTE(!"Unreachable code executed");
}
///////////////////////////////////////////////////////////////////////////////
boost::shared_ptr<HttpResponse> RecurrentRequest::SendHandleRetry()
{
	// "RETRY N URL" loop, where N - wait timeout, URL - server url
	while (true)
	{
		const std::string& url = m_urls.front();
		// set components of interest: host name and resource
		URL_COMPONENTSA urlComp = { 0 };
		urlComp.dwStructSize = sizeof(URL_COMPONENTS);
		urlComp.dwHostNameLength = TRUE;
		urlComp.dwUrlPathLength = TRUE;
		// parse activation URL
		if(!InternetCrackUrlA(url.c_str(), url.length(), 0, &urlComp))
			throw SystemError(GetLastError());

		// default request flags
		DWORD dwRequestFlags = INTERNET_FLAG_KEEP_CONNECTION | INTERNET_FLAG_NO_CACHE_WRITE;
		// only HTTP and HTTPS schemes supported
		switch(urlComp.nScheme)
		{
		case INTERNET_SCHEME_HTTPS:
			// modify flags for HTTPS protocol
			dwRequestFlags |= INTERNET_FLAG_SECURE;
		case INTERNET_SCHEME_HTTP:
			break;
		default:
			throw SystemError(ERROR_INTERNET_UNRECOGNIZED_SCHEME);
			break;
		}
		std::string sHostName(urlComp.lpszHostName, urlComp.dwHostNameLength);
		// create connection object
		boost::shared_ptr<HttpConnection> pConnection
			(m_pSession->CreateConnection(sHostName.c_str(), urlComp.nPort));
		std::string sUrlPath(urlComp.lpszUrlPath, urlComp.dwUrlPathLength);
		// create request object
		boost::shared_ptr<HttpRequest> pRequest
			(pConnection->CreateRequest(HttpRequest::HTTP_VERB_POST, sUrlPath.c_str(), dwRequestFlags));
		// set notifications observer
		pRequest->SetObserver(this);
		// set request object
		m_pRequest = pRequest;
		// send request
		boost::shared_ptr<HttpResponse> pResponse = SendHandleAuth(*pRequest);
		// text/plain indicates RETRY request or server error
		if (pResponse->GetContentType() != "text/plain")
			return pResponse;
		// handle text/plain response
		HandleServerResponse(*pResponse);
	}
}
///////////////////////////////////////////////////////////////////////////////
boost::shared_ptr<HttpResponse> RecurrentRequest::SendHandleAuth(HttpRequest& httpRequest)
{
	const unsigned short HTTP_STATUS_LAST_SUCCESSFUL = 399;
	// authentication loop
	while (true)
	{
		if (IsAborted())
			throw LogicalError(LogicalError::OPERATION_ABORTED);
		// set proxy credentials
		SetProxyCredentials(httpRequest);
		// set server credentials
		SetServerCredentials(httpRequest);
		// try to send request
		boost::shared_ptr<HttpResponse> pResponse
			(httpRequest.Send(m_pData->GetHeaders(), m_pData->GetHeadersLength(), m_pData->GetData(), m_pData->GetDataSize()));
		// get status code
		unsigned short nCode = pResponse->GetStatusCode();
		// analyze server error
		switch(nCode)
		{
		// proxy authentication required
		case HTTP_STATUS_PROXY_AUTH_REQ:
			if (!m_pObserver->OnProxyAuthRequired(m_authProxy))
			{
				if (IsAborted())
					throw LogicalError(LogicalError::OPERATION_ABORTED);
				throw HttpError(nCode);
			}
			break;
		// server authentication required
		case HTTP_STATUS_DENIED:
			if (!m_pObserver->OnServerAuthRequired(m_authServer))
			{
				if (IsAborted())
					throw LogicalError(LogicalError::OPERATION_ABORTED);
				throw HttpError(nCode);
			}
			break;
		default:
			if (nCode > HTTP_STATUS_LAST_SUCCESSFUL)
				throw HttpError(nCode);
			// request successfully completed
			return pResponse;
		}
	}
	_ASSERTE(!"Unreachable code executed");
}
///////////////////////////////////////////////////////////////////////////////
void RecurrentRequest::HandleServerResponse(HttpResponse& httpResponse)
{
	// fill data buffer
	std::vector<char> buf
	(
		reinterpret_cast<const char*>(httpResponse.GetData()),
		reinterpret_cast<const char*>(httpResponse.GetData()) + httpResponse.GetDataSize()
	);
	// filter EOL-crap
	std::vector<char>::reverse_iterator it = 
		std::find_if(buf.rbegin(), buf.rend(), std::ptr_fun(&::isalpha));
	// insert string terminator
	buf.insert(it.base(), 0);
	// extract first token from the response
	if (const char* token = strtok(&buf[0], " "))
	{
		// retry reply received
		if (!_stricmp(token, "RETRY"))
		{
			// extract timeout value
			if (!(token = strtok(0, " ")))
				throw LogicalError(LogicalError::UNKNOWN_SERVER_RESPONSE);

			long nTimeout = atol(token);
			// timeout must be greater than 0
			_ASSERTE((nTimeout > 0) && "Invalid timeout value");

			// extract new url value
			if (!(token = strtok(0, " ")))
				throw LogicalError(LogicalError::UNKNOWN_SERVER_RESPONSE);
			// set new single activation URL
			m_urls.clear();
			m_urls.push_back(token);
			// notify the observer
			m_pObserver->OnWaitTimeout(nTimeout);
			// wait <timeout> seconds and check for cancellation
			for (time_t t = time(0); (time(0) - t < nTimeout); Sleep(100))
			{
				if (IsAborted())
					throw LogicalError(LogicalError::OPERATION_ABORTED);
			}
			// retry again
			return;
		}
		// server error code received
		else
		{
			// retrieve server error code
			long nError = atol(token);
			// notify about server error
			throw ServerError(TranslateServerError(nError));
		}
	}
	throw LogicalError(LogicalError::UNKNOWN_SERVER_RESPONSE);
}
///////////////////////////////////////////////////////////////////////////////
void RecurrentRequest::Update(DWORD dwStatus, LPVOID lpvInfo, DWORD dwInfoLen)
{
	switch(dwStatus)
	{
	case INTERNET_STATUS_RESOLVING_NAME:
		m_pObserver->OnResolvingName(reinterpret_cast<LPCSTR>(lpvInfo));
		break;
	case INTERNET_STATUS_NAME_RESOLVED:
		m_pObserver->OnNameResolved(reinterpret_cast<LPCSTR>(lpvInfo));
		break;
	case INTERNET_STATUS_CONNECTING_TO_SERVER:
		m_pObserver->OnConnectingToServer(reinterpret_cast<LPCSTR>(lpvInfo));
		break;
	case INTERNET_STATUS_CONNECTED_TO_SERVER:
		m_pObserver->OnConnectedToServer(reinterpret_cast<LPCSTR>(lpvInfo));
		break;
	case INTERNET_STATUS_SENDING_REQUEST:
		m_pObserver->OnSendingRequest();
		break;
	case INTERNET_STATUS_REQUEST_SENT:
		m_pObserver->OnRequestSent(*reinterpret_cast<LPDWORD>(lpvInfo));
		break;
	case INTERNET_STATUS_RECEIVING_RESPONSE:
		m_pObserver->OnReceivingResponse();
		break;
	case INTERNET_STATUS_RESPONSE_RECEIVED:
		m_pObserver->OnResponseReceived(*reinterpret_cast<LPDWORD>(lpvInfo));
		break;
	case INTERNET_STATUS_CLOSING_CONNECTION:
		m_pObserver->OnClosingConnection();
		break;
	case INTERNET_STATUS_CONNECTION_CLOSED:
		m_pObserver->OnConnectionClosed();
		break;
	case INTERNET_STATUS_DETECTING_PROXY:
		m_pObserver->OnDetectingProxy();
		break;
	case INTERNET_STATUS_REDIRECT:
		m_pObserver->OnRedirect(reinterpret_cast<LPCSTR>(lpvInfo));
		break;
	case INTERNET_STATUS_INTERMEDIATE_RESPONSE:
		m_pObserver->OnIntermediateResponse();
		break;
	case INTERNET_STATUS_STATE_CHANGE:
		m_pObserver->OnStateChange(*reinterpret_cast<LPDWORD>(lpvInfo));
		break;
	case INTERNET_STATUS_COOKIE_SENT:
		m_pObserver->OnCookieSent();
		break;
	case INTERNET_STATUS_COOKIE_RECEIVED:
		m_pObserver->OnCookieReceived();
		break;
	default:
		_ASSERT(!"Unknown status received.");
		break;
	}
}
///////////////////////////////////////////////////////////////////////////////
void RecurrentRequest::Abort()
{
	// set aborted flag
	InterlockedExchange(&m_bAborted, 1);
	// try to obtain request object
	if (boost::shared_ptr<HttpRequest> pRequest = m_pRequest.lock())
		// abort request
		pRequest->Abort();
}
///////////////////////////////////////////////////////////////////////////////
RequestObserver* RecurrentRequest::GetObserver() const
{
	return m_pObserver;
}
///////////////////////////////////////////////////////////////////////////////
bool RecurrentRequest::IsAborted() const
{
	return InterlockedExchangeAdd(const_cast<long*>(&m_bAborted), 0) ? true : false;
}
///////////////////////////////////////////////////////////////////////////////
void RecurrentRequest::SetProxyCredentials(HttpRequest& httpRequest)
{
	if (!m_authProxy.IsEmpty())
	{
		secure_buffer user, pass;
		m_authProxy.GetUserName(user);
		user.push_back(0);
		m_authProxy.GetPassword(pass);
		pass.push_back(0);
		httpRequest.SetProxyAuth(reinterpret_cast<const char*>(&user[0]), reinterpret_cast<const char*>(&pass[0]));
	}
}
///////////////////////////////////////////////////////////////////////////////
void RecurrentRequest::SetServerCredentials(HttpRequest& httpRequest)
{
	if (!m_authServer.IsEmpty())
	{
		secure_buffer user, pass;
		m_authServer.GetUserName(user);
		user.push_back(0);
		m_authServer.GetPassword(pass);
		pass.push_back(0);
		httpRequest.SetServerAuth(reinterpret_cast<const char*>(&user[0]), reinterpret_cast<const char*>(&pass[0]));
	}
}
///////////////////////////////////////////////////////////////////////////////
} // namespace OnlineActivation