forward interface RegistrySummator;
typedef RegistrySummator* hREGISTRY_SUMMATOR;




[
  mnemonic(IID_REGISTRYSUMMATOR)
  id(40016)
  c_type_name(hREGISTRY_SUMMATOR)
  comment_ex("Структура cSerializable высчитывается из локальной копии реестра. При высчитывании используется алгоритм OVERWRITE, позволяющий перекрывать настройки.
    
    Алгоритм OVERWRITE строится по следующей схеме:
    
    -	Запрашиваются данные из ветки <_data_> (имя ветки дано для примера)
    
    -	Данные вычитываются из ветки DEFAULT (если она существуют; в обратном случае данные инициализируеются hardcoded), находящейся на одном уровне с веткой <_data_>. В данной ветке должны быть указаны все параметры. Отсутствующие параметры инициализируются hardcoded.
    
    -	Полученные данные перекрываются данными из ветки <_data_> (если она существует). В данной ветке может быть указана только часть параметров.
    
    -	Полученные данные перекрываются данными из ветки OVERWRITE (если она существует), находящейся на одном уровне с веткой <_data_>. В данной ветке может быть указана только часть параметров.
    
    Алгоритм OVERWRITE предоставляется методом BL::getSettings (если свойство BL ненулевое) либо реализуется самостоятельно разработчиком плагина")
]
interface RegistrySummator { // Объект, предоставляющий структуру cSerializable по запросу

  // ------------------------------------

    [
      comment_ex("Interface version")
      id(130)
    ]
    prop tVERSION pgINTERFACE_VERSION; // Interface version

    [
      comment_ex("Interface comment")
      id(131)
    ]
    prop tSTRING pgINTERFACE_COMMENT; // Interface comment

    [
      id(4097)
      comment_ex("Копия реестра от текущего корня")
    ]
    prop hOBJECT pgREGISTRY_CLONE; // Локальная копия объекта реестра
    [ id(4096) ]  prop hOBJECT pgBL; // Указатель на объект BL

    [
      id(4098)
      comment_ex("В случае, если клиент RegSum не хочет, чтобы RegSum копировал  реестр, он может установить это свойство взамен REGISTRY_CLONE.")
    ]
    prop hOBJECT pgREGISTRY; // Объект реестра

    [
      id(4099)
      comment_ex("Можно установить это имя. если все операции с реестром предполагается проводить ниже данной ветки")
    ]
    prop tSTRING pgREGISTRY_ROOT; // Имя корневой ветки


  // ------------------------------------
    method tERROR GetSettings( // Предоставление структуры cSerializable из хранимой копии реестра
      const tCHAR* p_szFullBranchName, // IN Полное имя для вычитываемой структуры
      tPTR* p_pSettings, // IN OUT Сериализованная структура
      tBOOL p_bUnknownAsError // IN Возвращать ли ошибку в случае отсутствия запрашиваемой ветки реестра
    );

    [
      comment_ex("Данный метод позволяет получить новый экземпляр RegSum, чья область действия ограничена сверху указанной веткой реестра.
        
        Временем жизни предоставленного клона управляет данный экземпляр RegSum. Т.е. при удалении данного экземпляра RegSum будут удалены все его клоны.
        
        Оптимизация: Повторный вызов метода предоставляет указатель на уже созданного клона.")
    ]
    method tERROR CloneTuner( // Копия существующего объекта RegSum ниже ветки p_szFullBranchName
      hREGISTRY_SUMMATOR* result,
      tCHAR* p_szFullBranchName
    );

}

